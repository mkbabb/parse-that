{"version":3,"file":"parse-b8e34c1a.cjs","sources":["../src/parse/state.ts","../node_modules/prettier/doc.js","../src/parse/debug.ts","../src/parse/parse.ts"],"sourcesContent":["import { Parser } from \"./parse\";\n\nexport class ParserState<T> {\n    constructor(\n        public src: string,\n        public value: T = undefined,\n        public offset: number = 0,\n        public isError: boolean = false,\n        public furthest: number = 0\n    ) {}\n\n    ok<S>(value: S, offset: number = 0) {\n        offset += this.offset;\n        return new ParserState<S>(this.src, value, offset, false);\n    }\n\n    err<S>(value?: S, offset: number = 0) {\n        const nextState = this.ok(value, offset);\n        nextState.isError = true;\n        return nextState;\n    }\n\n    from<S>(value: S, offset: number = 0) {\n        offset += this.offset;\n        return new ParserState<S>(this.src, value, offset, this.isError);\n    }\n\n    getColumnNumber(): number {\n        const offset = this.offset;\n        const lastNewline = this.src.lastIndexOf(\"\\n\", offset);\n        const columnNumber = lastNewline === -1 ? offset : offset - (lastNewline + 1);\n        return Math.max(0, columnNumber);\n    }\n\n    getLineNumber(): number {\n        const newlineIndex = this.src.lastIndexOf(\"\\n\", this.offset);\n        return newlineIndex >= 0\n            ? this.src.slice(0, newlineIndex).split(\"\\n\").length\n            : 0;\n    }\n}\n\nexport const parserNames = [\n    \"string\",\n    \"regex\",\n    \"then\",\n    \"or\",\n    \"chain\",\n    \"map\",\n    \"many\",\n    \"lazy\",\n    \"memoize\",\n    \"mergeMemo\",\n    \"not\",\n    \"skip\",\n    \"next\",\n    \"trim\",\n    \"trimWhitespace\",\n    \"whitespace\",\n    \"wrap\",\n    \"sepBy\",\n    \"any\",\n    \"all\",\n    \"opt\",\n    \"lookAhead\",\n    \"lookBehind\",\n    \"eof\",\n    \"regexConcat\",\n    \"regexWrap\",\n    \"debug\",\n    \"mapState\",\n] as const;\n\nexport type ParserContext<T = any> = {\n    name?: (typeof parserNames)[number];\n    parser?: Parser<T>;\n    args?: any[];\n};\n\n// TODO: maybe reintroduce debug check.\nexport function createParserContext<T = any>(\n    name: (typeof parserNames)[number],\n    parser: Parser<T>,\n    ...args: any[]\n) {\n    return {\n        name,\n        parser,\n        args,\n    };\n}\n","(function (factory) {\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    module.exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else {\n    var root =\n      typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof self !== \"undefined\"\n        ? self\n        : this || {};\n    root.doc = factory();\n  }\n})(function() {\n  \"use strict\";\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\n  // dist/_doc.js.umd.js\n  var require_doc_js_umd = __commonJS({\n    \"dist/_doc.js.umd.js\"(exports, module) {\n      var __create = Object.create;\n      var __defProp = Object.defineProperty;\n      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n      var __getOwnPropNames2 = Object.getOwnPropertyNames;\n      var __getProtoOf = Object.getPrototypeOf;\n      var __hasOwnProp = Object.prototype.hasOwnProperty;\n      var __esm = (fn, res) => function __init() {\n        return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;\n      };\n      var __commonJS2 = (cb, mod) => function __require() {\n        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {\n          exports: {}\n        }).exports, mod), mod.exports;\n      };\n      var __export = (target, all) => {\n        for (var name in all)\n          __defProp(target, name, {\n            get: all[name],\n            enumerable: true\n          });\n      };\n      var __copyProps = (to, from, except, desc) => {\n        if (from && typeof from === \"object\" || typeof from === \"function\") {\n          for (let key of __getOwnPropNames2(from))\n            if (!__hasOwnProp.call(to, key) && key !== except)\n              __defProp(to, key, {\n                get: () => from[key],\n                enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n              });\n        }\n        return to;\n      };\n      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n      }) : target, mod));\n      var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", {\n        value: true\n      }), mod);\n      var init_define_process = __esm({\n        \"<define:process>\"() {\n        }\n      });\n      var require_doc_builders = __commonJS2({\n        \"src/document/doc-builders.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function concat(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"concat\",\n              parts\n            };\n          }\n          function indent(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"indent\",\n              contents\n            };\n          }\n          function align(widthOrString, contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"align\",\n              contents,\n              n: widthOrString\n            };\n          }\n          function group(contents) {\n            let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"group\",\n              id: opts.id,\n              contents,\n              break: Boolean(opts.shouldBreak),\n              expandedStates: opts.expandedStates\n            };\n          }\n          function dedentToRoot(contents) {\n            return align(Number.NEGATIVE_INFINITY, contents);\n          }\n          function markAsRoot(contents) {\n            return align({\n              type: \"root\"\n            }, contents);\n          }\n          function dedent(contents) {\n            return align(-1, contents);\n          }\n          function conditionalGroup(states, opts) {\n            return group(states[0], Object.assign(Object.assign({}, opts), {}, {\n              expandedStates: states\n            }));\n          }\n          function fill(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"fill\",\n              parts\n            };\n          }\n          function ifBreak(breakContents, flatContents) {\n            let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (false) {\n              if (breakContents) {\n                assertDoc(breakContents);\n              }\n              if (flatContents) {\n                assertDoc(flatContents);\n              }\n            }\n            return {\n              type: \"if-break\",\n              breakContents,\n              flatContents,\n              groupId: opts.groupId\n            };\n          }\n          function indentIfBreak(contents, opts) {\n            return {\n              type: \"indent-if-break\",\n              contents,\n              groupId: opts.groupId,\n              negate: opts.negate\n            };\n          }\n          function lineSuffix(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"line-suffix\",\n              contents\n            };\n          }\n          var lineSuffixBoundary = {\n            type: \"line-suffix-boundary\"\n          };\n          var breakParent = {\n            type: \"break-parent\"\n          };\n          var trim = {\n            type: \"trim\"\n          };\n          var hardlineWithoutBreakParent = {\n            type: \"line\",\n            hard: true\n          };\n          var literallineWithoutBreakParent = {\n            type: \"line\",\n            hard: true,\n            literal: true\n          };\n          var line = {\n            type: \"line\"\n          };\n          var softline = {\n            type: \"line\",\n            soft: true\n          };\n          var hardline = concat([hardlineWithoutBreakParent, breakParent]);\n          var literalline = concat([literallineWithoutBreakParent, breakParent]);\n          var cursor = {\n            type: \"cursor\",\n            placeholder: Symbol(\"cursor\")\n          };\n          function join(sep, arr) {\n            const res = [];\n            for (let i = 0; i < arr.length; i++) {\n              if (i !== 0) {\n                res.push(sep);\n              }\n              res.push(arr[i]);\n            }\n            return concat(res);\n          }\n          function addAlignmentToDoc(doc, size, tabWidth) {\n            let aligned = doc;\n            if (size > 0) {\n              for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n                aligned = indent(aligned);\n              }\n              aligned = align(size % tabWidth, aligned);\n              aligned = align(Number.NEGATIVE_INFINITY, aligned);\n            }\n            return aligned;\n          }\n          function label(label2, contents) {\n            return {\n              type: \"label\",\n              label: label2,\n              contents\n            };\n          }\n          module2.exports = {\n            concat,\n            join,\n            line,\n            softline,\n            hardline,\n            literalline,\n            group,\n            conditionalGroup,\n            fill,\n            lineSuffix,\n            lineSuffixBoundary,\n            cursor,\n            breakParent,\n            ifBreak,\n            trim,\n            indent,\n            indentIfBreak,\n            align,\n            addAlignmentToDoc,\n            markAsRoot,\n            dedentToRoot,\n            dedent,\n            hardlineWithoutBreakParent,\n            literallineWithoutBreakParent,\n            label\n          };\n        }\n      });\n      var require_end_of_line = __commonJS2({\n        \"src/common/end-of-line.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function guessEndOfLine(text) {\n            const index = text.indexOf(\"\\r\");\n            if (index >= 0) {\n              return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n            }\n            return \"lf\";\n          }\n          function convertEndOfLineToChars(value) {\n            switch (value) {\n              case \"cr\":\n                return \"\\r\";\n              case \"crlf\":\n                return \"\\r\\n\";\n              default:\n                return \"\\n\";\n            }\n          }\n          function countEndOfLineChars(text, eol) {\n            let regex;\n            switch (eol) {\n              case \"\\n\":\n                regex = /\\n/g;\n                break;\n              case \"\\r\":\n                regex = /\\r/g;\n                break;\n              case \"\\r\\n\":\n                regex = /\\r\\n/g;\n                break;\n              default:\n                throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);\n            }\n            const endOfLines = text.match(regex);\n            return endOfLines ? endOfLines.length : 0;\n          }\n          function normalizeEndOfLine(text) {\n            return text.replace(/\\r\\n?/g, \"\\n\");\n          }\n          module2.exports = {\n            guessEndOfLine,\n            convertEndOfLineToChars,\n            countEndOfLineChars,\n            normalizeEndOfLine\n          };\n        }\n      });\n      var require_get_last = __commonJS2({\n        \"src/utils/get-last.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = (arr) => arr[arr.length - 1];\n          module2.exports = getLast;\n        }\n      });\n      function ansiRegex() {\n        let {\n          onlyFirst = false\n        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const pattern = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n        return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n      }\n      var init_ansi_regex = __esm({\n        \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n          init_define_process();\n        }\n      });\n      function stripAnsi(string) {\n        if (typeof string !== \"string\") {\n          throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string}\\``);\n        }\n        return string.replace(ansiRegex(), \"\");\n      }\n      var init_strip_ansi = __esm({\n        \"node_modules/strip-ansi/index.js\"() {\n          init_define_process();\n          init_ansi_regex();\n        }\n      });\n      function isFullwidthCodePoint(codePoint) {\n        if (!Number.isInteger(codePoint)) {\n          return false;\n        }\n        return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);\n      }\n      var init_is_fullwidth_code_point = __esm({\n        \"node_modules/is-fullwidth-code-point/index.js\"() {\n          init_define_process();\n        }\n      });\n      var require_emoji_regex = __commonJS2({\n        \"node_modules/emoji-regex/index.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          module2.exports = function() {\n            return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n          };\n        }\n      });\n      var string_width_exports = {};\n      __export(string_width_exports, {\n        default: () => stringWidth\n      });\n      function stringWidth(string) {\n        if (typeof string !== \"string\" || string.length === 0) {\n          return 0;\n        }\n        string = stripAnsi(string);\n        if (string.length === 0) {\n          return 0;\n        }\n        string = string.replace((0, import_emoji_regex.default)(), \"  \");\n        let width = 0;\n        for (let index = 0; index < string.length; index++) {\n          const codePoint = string.codePointAt(index);\n          if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n            continue;\n          }\n          if (codePoint >= 768 && codePoint <= 879) {\n            continue;\n          }\n          if (codePoint > 65535) {\n            index++;\n          }\n          width += isFullwidthCodePoint(codePoint) ? 2 : 1;\n        }\n        return width;\n      }\n      var import_emoji_regex;\n      var init_string_width = __esm({\n        \"node_modules/string-width/index.js\"() {\n          init_define_process();\n          init_strip_ansi();\n          init_is_fullwidth_code_point();\n          import_emoji_regex = __toESM(require_emoji_regex());\n        }\n      });\n      var require_get_string_width = __commonJS2({\n        \"src/utils/get-string-width.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var stringWidth2 = (init_string_width(), __toCommonJS(string_width_exports)).default;\n          var notAsciiRegex = /[^\\x20-\\x7F]/;\n          function getStringWidth(text) {\n            if (!text) {\n              return 0;\n            }\n            if (!notAsciiRegex.test(text)) {\n              return text.length;\n            }\n            return stringWidth2(text);\n          }\n          module2.exports = getStringWidth;\n        }\n      });\n      var require_doc_utils = __commonJS2({\n        \"src/document/doc-utils.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = require_get_last();\n          var {\n            literalline,\n            join\n          } = require_doc_builders();\n          var isConcat = (doc) => Array.isArray(doc) || doc && doc.type === \"concat\";\n          var getDocParts = (doc) => {\n            if (Array.isArray(doc)) {\n              return doc;\n            }\n            if (doc.type !== \"concat\" && doc.type !== \"fill\") {\n              throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n            }\n            return doc.parts;\n          };\n          var traverseDocOnExitStackMarker = {};\n          function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n            const docsStack = [doc];\n            while (docsStack.length > 0) {\n              const doc2 = docsStack.pop();\n              if (doc2 === traverseDocOnExitStackMarker) {\n                onExit(docsStack.pop());\n                continue;\n              }\n              if (onExit) {\n                docsStack.push(doc2, traverseDocOnExitStackMarker);\n              }\n              if (!onEnter || onEnter(doc2) !== false) {\n                if (isConcat(doc2) || doc2.type === \"fill\") {\n                  const parts = getDocParts(doc2);\n                  for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n                    docsStack.push(parts[i]);\n                  }\n                } else if (doc2.type === \"if-break\") {\n                  if (doc2.flatContents) {\n                    docsStack.push(doc2.flatContents);\n                  }\n                  if (doc2.breakContents) {\n                    docsStack.push(doc2.breakContents);\n                  }\n                } else if (doc2.type === \"group\" && doc2.expandedStates) {\n                  if (shouldTraverseConditionalGroups) {\n                    for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n                      docsStack.push(doc2.expandedStates[i]);\n                    }\n                  } else {\n                    docsStack.push(doc2.contents);\n                  }\n                } else if (doc2.contents) {\n                  docsStack.push(doc2.contents);\n                }\n              }\n            }\n          }\n          function mapDoc(doc, cb) {\n            const mapped = /* @__PURE__ */ new Map();\n            return rec(doc);\n            function rec(doc2) {\n              if (mapped.has(doc2)) {\n                return mapped.get(doc2);\n              }\n              const result = process2(doc2);\n              mapped.set(doc2, result);\n              return result;\n            }\n            function process2(doc2) {\n              if (Array.isArray(doc2)) {\n                return cb(doc2.map(rec));\n              }\n              if (doc2.type === \"concat\" || doc2.type === \"fill\") {\n                const parts = doc2.parts.map(rec);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  parts\n                }));\n              }\n              if (doc2.type === \"if-break\") {\n                const breakContents = doc2.breakContents && rec(doc2.breakContents);\n                const flatContents = doc2.flatContents && rec(doc2.flatContents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  breakContents,\n                  flatContents\n                }));\n              }\n              if (doc2.type === \"group\" && doc2.expandedStates) {\n                const expandedStates = doc2.expandedStates.map(rec);\n                const contents = expandedStates[0];\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents,\n                  expandedStates\n                }));\n              }\n              if (doc2.contents) {\n                const contents = rec(doc2.contents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents\n                }));\n              }\n              return cb(doc2);\n            }\n          }\n          function findInDoc(doc, fn, defaultValue) {\n            let result = defaultValue;\n            let hasStopped = false;\n            function findInDocOnEnterFn(doc2) {\n              const maybeResult = fn(doc2);\n              if (maybeResult !== void 0) {\n                hasStopped = true;\n                result = maybeResult;\n              }\n              if (hasStopped) {\n                return false;\n              }\n            }\n            traverseDoc(doc, findInDocOnEnterFn);\n            return result;\n          }\n          function willBreakFn(doc) {\n            if (doc.type === \"group\" && doc.break) {\n              return true;\n            }\n            if (doc.type === \"line\" && doc.hard) {\n              return true;\n            }\n            if (doc.type === \"break-parent\") {\n              return true;\n            }\n          }\n          function willBreak(doc) {\n            return findInDoc(doc, willBreakFn, false);\n          }\n          function breakParentGroup(groupStack) {\n            if (groupStack.length > 0) {\n              const parentGroup = getLast(groupStack);\n              if (!parentGroup.expandedStates && !parentGroup.break) {\n                parentGroup.break = \"propagated\";\n              }\n            }\n            return null;\n          }\n          function propagateBreaks(doc) {\n            const alreadyVisitedSet = /* @__PURE__ */ new Set();\n            const groupStack = [];\n            function propagateBreaksOnEnterFn(doc2) {\n              if (doc2.type === \"break-parent\") {\n                breakParentGroup(groupStack);\n              }\n              if (doc2.type === \"group\") {\n                groupStack.push(doc2);\n                if (alreadyVisitedSet.has(doc2)) {\n                  return false;\n                }\n                alreadyVisitedSet.add(doc2);\n              }\n            }\n            function propagateBreaksOnExitFn(doc2) {\n              if (doc2.type === \"group\") {\n                const group = groupStack.pop();\n                if (group.break) {\n                  breakParentGroup(groupStack);\n                }\n              }\n            }\n            traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);\n          }\n          function removeLinesFn(doc) {\n            if (doc.type === \"line\" && !doc.hard) {\n              return doc.soft ? \"\" : \" \";\n            }\n            if (doc.type === \"if-break\") {\n              return doc.flatContents || \"\";\n            }\n            return doc;\n          }\n          function removeLines(doc) {\n            return mapDoc(doc, removeLinesFn);\n          }\n          var isHardline = (doc, nextDoc) => doc && doc.type === \"line\" && doc.hard && nextDoc && nextDoc.type === \"break-parent\";\n          function stripDocTrailingHardlineFromDoc(doc) {\n            if (!doc) {\n              return doc;\n            }\n            if (isConcat(doc) || doc.type === \"fill\") {\n              const parts = getDocParts(doc);\n              while (parts.length > 1 && isHardline(...parts.slice(-2))) {\n                parts.length -= 2;\n              }\n              if (parts.length > 0) {\n                const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));\n                parts[parts.length - 1] = lastPart;\n              }\n              return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n                parts\n              });\n            }\n            switch (doc.type) {\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"group\":\n              case \"line-suffix\":\n              case \"label\": {\n                const contents = stripDocTrailingHardlineFromDoc(doc.contents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  contents\n                });\n              }\n              case \"if-break\": {\n                const breakContents = stripDocTrailingHardlineFromDoc(doc.breakContents);\n                const flatContents = stripDocTrailingHardlineFromDoc(doc.flatContents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  breakContents,\n                  flatContents\n                });\n              }\n            }\n            return doc;\n          }\n          function stripTrailingHardline(doc) {\n            return stripDocTrailingHardlineFromDoc(cleanDoc(doc));\n          }\n          function cleanDocFn(doc) {\n            switch (doc.type) {\n              case \"fill\":\n                if (doc.parts.every((part) => part === \"\")) {\n                  return \"\";\n                }\n                break;\n              case \"group\":\n                if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n                  return \"\";\n                }\n                if (doc.contents.type === \"group\" && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n                  return doc.contents;\n                }\n                break;\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"line-suffix\":\n                if (!doc.contents) {\n                  return \"\";\n                }\n                break;\n              case \"if-break\":\n                if (!doc.flatContents && !doc.breakContents) {\n                  return \"\";\n                }\n                break;\n            }\n            if (!isConcat(doc)) {\n              return doc;\n            }\n            const parts = [];\n            for (const part of getDocParts(doc)) {\n              if (!part) {\n                continue;\n              }\n              const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];\n              if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {\n                parts[parts.length - 1] += currentPart;\n              } else {\n                parts.push(currentPart);\n              }\n              parts.push(...restParts);\n            }\n            if (parts.length === 0) {\n              return \"\";\n            }\n            if (parts.length === 1) {\n              return parts[0];\n            }\n            return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n              parts\n            });\n          }\n          function cleanDoc(doc) {\n            return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n          }\n          function normalizeParts(parts) {\n            const newParts = [];\n            const restParts = parts.filter(Boolean);\n            while (restParts.length > 0) {\n              const part = restParts.shift();\n              if (!part) {\n                continue;\n              }\n              if (isConcat(part)) {\n                restParts.unshift(...getDocParts(part));\n                continue;\n              }\n              if (newParts.length > 0 && typeof getLast(newParts) === \"string\" && typeof part === \"string\") {\n                newParts[newParts.length - 1] += part;\n                continue;\n              }\n              newParts.push(part);\n            }\n            return newParts;\n          }\n          function normalizeDoc(doc) {\n            return mapDoc(doc, (currentDoc) => {\n              if (Array.isArray(currentDoc)) {\n                return normalizeParts(currentDoc);\n              }\n              if (!currentDoc.parts) {\n                return currentDoc;\n              }\n              return Object.assign(Object.assign({}, currentDoc), {}, {\n                parts: normalizeParts(currentDoc.parts)\n              });\n            });\n          }\n          function replaceEndOfLine(doc) {\n            return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? replaceTextEndOfLine(currentDoc) : currentDoc);\n          }\n          function replaceTextEndOfLine(text) {\n            let replacement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : literalline;\n            return join(replacement, text.split(\"\\n\")).parts;\n          }\n          function canBreakFn(doc) {\n            if (doc.type === \"line\") {\n              return true;\n            }\n          }\n          function canBreak(doc) {\n            return findInDoc(doc, canBreakFn, false);\n          }\n          module2.exports = {\n            isConcat,\n            getDocParts,\n            willBreak,\n            traverseDoc,\n            findInDoc,\n            mapDoc,\n            propagateBreaks,\n            removeLines,\n            stripTrailingHardline,\n            normalizeParts,\n            normalizeDoc,\n            cleanDoc,\n            replaceTextEndOfLine,\n            replaceEndOfLine,\n            canBreak\n          };\n        }\n      });\n      var require_doc_printer = __commonJS2({\n        \"src/document/doc-printer.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            convertEndOfLineToChars\n          } = require_end_of_line();\n          var getLast = require_get_last();\n          var getStringWidth = require_get_string_width();\n          var {\n            fill,\n            cursor,\n            indent\n          } = require_doc_builders();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          var groupModeMap;\n          var MODE_BREAK = 1;\n          var MODE_FLAT = 2;\n          function rootIndent() {\n            return {\n              value: \"\",\n              length: 0,\n              queue: []\n            };\n          }\n          function makeIndent(ind, options) {\n            return generateInd(ind, {\n              type: \"indent\"\n            }, options);\n          }\n          function makeAlign(indent2, widthOrDoc, options) {\n            if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n              return indent2.root || rootIndent();\n            }\n            if (widthOrDoc < 0) {\n              return generateInd(indent2, {\n                type: \"dedent\"\n              }, options);\n            }\n            if (!widthOrDoc) {\n              return indent2;\n            }\n            if (widthOrDoc.type === \"root\") {\n              return Object.assign(Object.assign({}, indent2), {}, {\n                root: indent2\n              });\n            }\n            const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n            return generateInd(indent2, {\n              type: alignType,\n              n: widthOrDoc\n            }, options);\n          }\n          function generateInd(ind, newPart, options) {\n            const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n            let value = \"\";\n            let length = 0;\n            let lastTabs = 0;\n            let lastSpaces = 0;\n            for (const part of queue) {\n              switch (part.type) {\n                case \"indent\":\n                  flush();\n                  if (options.useTabs) {\n                    addTabs(1);\n                  } else {\n                    addSpaces(options.tabWidth);\n                  }\n                  break;\n                case \"stringAlign\":\n                  flush();\n                  value += part.n;\n                  length += part.n.length;\n                  break;\n                case \"numberAlign\":\n                  lastTabs += 1;\n                  lastSpaces += part.n;\n                  break;\n                default:\n                  throw new Error(`Unexpected type '${part.type}'`);\n              }\n            }\n            flushSpaces();\n            return Object.assign(Object.assign({}, ind), {}, {\n              value,\n              length,\n              queue\n            });\n            function addTabs(count) {\n              value += \"\t\".repeat(count);\n              length += options.tabWidth * count;\n            }\n            function addSpaces(count) {\n              value += \" \".repeat(count);\n              length += count;\n            }\n            function flush() {\n              if (options.useTabs) {\n                flushTabs();\n              } else {\n                flushSpaces();\n              }\n            }\n            function flushTabs() {\n              if (lastTabs > 0) {\n                addTabs(lastTabs);\n              }\n              resetLast();\n            }\n            function flushSpaces() {\n              if (lastSpaces > 0) {\n                addSpaces(lastSpaces);\n              }\n              resetLast();\n            }\n            function resetLast() {\n              lastTabs = 0;\n              lastSpaces = 0;\n            }\n          }\n          function trim(out) {\n            if (out.length === 0) {\n              return 0;\n            }\n            let trimCount = 0;\n            while (out.length > 0 && typeof getLast(out) === \"string\" && /^[\\t ]*$/.test(getLast(out))) {\n              trimCount += out.pop().length;\n            }\n            if (out.length > 0 && typeof getLast(out) === \"string\") {\n              const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");\n              trimCount += getLast(out).length - trimmed.length;\n              out[out.length - 1] = trimmed;\n            }\n            return trimCount;\n          }\n          function fits(next, restCommands, width, hasLineSuffix, mustBeFlat) {\n            let restIdx = restCommands.length;\n            const cmds = [next];\n            const out = [];\n            while (width >= 0) {\n              if (cmds.length === 0) {\n                if (restIdx === 0) {\n                  return true;\n                }\n                cmds.push(restCommands[--restIdx]);\n                continue;\n              }\n              const {\n                mode,\n                doc\n              } = cmds.pop();\n              if (typeof doc === \"string\") {\n                out.push(doc);\n                width -= getStringWidth(doc);\n              } else if (isConcat(doc) || doc.type === \"fill\") {\n                const parts = getDocParts(doc);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc.type) {\n                  case \"indent\":\n                  case \"align\":\n                  case \"indent-if-break\":\n                  case \"label\":\n                    cmds.push({\n                      mode,\n                      doc: doc.contents\n                    });\n                    break;\n                  case \"trim\":\n                    width += trim(out);\n                    break;\n                  case \"group\": {\n                    if (mustBeFlat && doc.break) {\n                      return false;\n                    }\n                    const groupMode = doc.break ? MODE_BREAK : mode;\n                    const contents = doc.expandedStates && groupMode === MODE_BREAK ? getLast(doc.expandedStates) : doc.contents;\n                    cmds.push({\n                      mode: groupMode,\n                      doc: contents\n                    });\n                    break;\n                  }\n                  case \"if-break\": {\n                    const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n                    const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n                    if (contents) {\n                      cmds.push({\n                        mode,\n                        doc: contents\n                      });\n                    }\n                    break;\n                  }\n                  case \"line\":\n                    if (mode === MODE_BREAK || doc.hard) {\n                      return true;\n                    }\n                    if (!doc.soft) {\n                      out.push(\" \");\n                      width--;\n                    }\n                    break;\n                  case \"line-suffix\":\n                    hasLineSuffix = true;\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (hasLineSuffix) {\n                      return false;\n                    }\n                    break;\n                }\n              }\n            }\n            return false;\n          }\n          function printDocToString(doc, options) {\n            groupModeMap = {};\n            const width = options.printWidth;\n            const newLine = convertEndOfLineToChars(options.endOfLine);\n            let pos = 0;\n            const cmds = [{\n              ind: rootIndent(),\n              mode: MODE_BREAK,\n              doc\n            }];\n            const out = [];\n            let shouldRemeasure = false;\n            const lineSuffix = [];\n            while (cmds.length > 0) {\n              const {\n                ind,\n                mode,\n                doc: doc2\n              } = cmds.pop();\n              if (typeof doc2 === \"string\") {\n                const formatted = newLine !== \"\\n\" ? doc2.replace(/\\n/g, newLine) : doc2;\n                out.push(formatted);\n                pos += getStringWidth(formatted);\n              } else if (isConcat(doc2)) {\n                const parts = getDocParts(doc2);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    ind,\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc2.type) {\n                  case \"cursor\":\n                    out.push(cursor.placeholder);\n                    break;\n                  case \"indent\":\n                    cmds.push({\n                      ind: makeIndent(ind, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"align\":\n                    cmds.push({\n                      ind: makeAlign(ind, doc2.n, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"trim\":\n                    pos -= trim(out);\n                    break;\n                  case \"group\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!shouldRemeasure) {\n                          cmds.push({\n                            ind,\n                            mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                            doc: doc2.contents\n                          });\n                          break;\n                        }\n                      case MODE_BREAK: {\n                        shouldRemeasure = false;\n                        const next = {\n                          ind,\n                          mode: MODE_FLAT,\n                          doc: doc2.contents\n                        };\n                        const rem = width - pos;\n                        const hasLineSuffix = lineSuffix.length > 0;\n                        if (!doc2.break && fits(next, cmds, rem, hasLineSuffix)) {\n                          cmds.push(next);\n                        } else {\n                          if (doc2.expandedStates) {\n                            const mostExpanded = getLast(doc2.expandedStates);\n                            if (doc2.break) {\n                              cmds.push({\n                                ind,\n                                mode: MODE_BREAK,\n                                doc: mostExpanded\n                              });\n                              break;\n                            } else {\n                              for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                                if (i >= doc2.expandedStates.length) {\n                                  cmds.push({\n                                    ind,\n                                    mode: MODE_BREAK,\n                                    doc: mostExpanded\n                                  });\n                                  break;\n                                } else {\n                                  const state = doc2.expandedStates[i];\n                                  const cmd = {\n                                    ind,\n                                    mode: MODE_FLAT,\n                                    doc: state\n                                  };\n                                  if (fits(cmd, cmds, rem, hasLineSuffix)) {\n                                    cmds.push(cmd);\n                                    break;\n                                  }\n                                }\n                              }\n                            }\n                          } else {\n                            cmds.push({\n                              ind,\n                              mode: MODE_BREAK,\n                              doc: doc2.contents\n                            });\n                          }\n                        }\n                        break;\n                      }\n                    }\n                    if (doc2.id) {\n                      groupModeMap[doc2.id] = getLast(cmds).mode;\n                    }\n                    break;\n                  case \"fill\": {\n                    const rem = width - pos;\n                    const {\n                      parts\n                    } = doc2;\n                    if (parts.length === 0) {\n                      break;\n                    }\n                    const [content, whitespace] = parts;\n                    const contentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: content\n                    };\n                    const contentBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: content\n                    };\n                    const contentFits = fits(contentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (parts.length === 1) {\n                      if (contentFits) {\n                        cmds.push(contentFlatCmd);\n                      } else {\n                        cmds.push(contentBreakCmd);\n                      }\n                      break;\n                    }\n                    const whitespaceFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: whitespace\n                    };\n                    const whitespaceBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: whitespace\n                    };\n                    if (parts.length === 2) {\n                      if (contentFits) {\n                        cmds.push(whitespaceFlatCmd, contentFlatCmd);\n                      } else {\n                        cmds.push(whitespaceBreakCmd, contentBreakCmd);\n                      }\n                      break;\n                    }\n                    parts.splice(0, 2);\n                    const remainingCmd = {\n                      ind,\n                      mode,\n                      doc: fill(parts)\n                    };\n                    const secondContent = parts[0];\n                    const firstAndSecondContentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: [content, whitespace, secondContent]\n                    };\n                    const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (firstAndSecondContentFits) {\n                      cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n                    } else if (contentFits) {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n                    } else {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n                    }\n                    break;\n                  }\n                  case \"if-break\":\n                  case \"indent-if-break\": {\n                    const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n                    if (groupMode === MODE_BREAK) {\n                      const breakContents = doc2.type === \"if-break\" ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n                      if (breakContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: breakContents\n                        });\n                      }\n                    }\n                    if (groupMode === MODE_FLAT) {\n                      const flatContents = doc2.type === \"if-break\" ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n                      if (flatContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: flatContents\n                        });\n                      }\n                    }\n                    break;\n                  }\n                  case \"line-suffix\":\n                    lineSuffix.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (lineSuffix.length > 0) {\n                      cmds.push({\n                        ind,\n                        mode,\n                        doc: {\n                          type: \"line\",\n                          hard: true\n                        }\n                      });\n                    }\n                    break;\n                  case \"line\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!doc2.hard) {\n                          if (!doc2.soft) {\n                            out.push(\" \");\n                            pos += 1;\n                          }\n                          break;\n                        } else {\n                          shouldRemeasure = true;\n                        }\n                      case MODE_BREAK:\n                        if (lineSuffix.length > 0) {\n                          cmds.push({\n                            ind,\n                            mode,\n                            doc: doc2\n                          }, ...lineSuffix.reverse());\n                          lineSuffix.length = 0;\n                          break;\n                        }\n                        if (doc2.literal) {\n                          if (ind.root) {\n                            out.push(newLine, ind.root.value);\n                            pos = ind.root.length;\n                          } else {\n                            out.push(newLine);\n                            pos = 0;\n                          }\n                        } else {\n                          pos -= trim(out);\n                          out.push(newLine + ind.value);\n                          pos = ind.length;\n                        }\n                        break;\n                    }\n                    break;\n                  case \"label\":\n                    cmds.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  default:\n                }\n              }\n              if (cmds.length === 0 && lineSuffix.length > 0) {\n                cmds.push(...lineSuffix.reverse());\n                lineSuffix.length = 0;\n              }\n            }\n            const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n            if (cursorPlaceholderIndex !== -1) {\n              const otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n              const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n              const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n              const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n              return {\n                formatted: beforeCursor + aroundCursor + afterCursor,\n                cursorNodeStart: beforeCursor.length,\n                cursorNodeText: aroundCursor\n              };\n            }\n            return {\n              formatted: out.join(\"\")\n            };\n          }\n          module2.exports = {\n            printDocToString\n          };\n        }\n      });\n      var require_doc_debug = __commonJS2({\n        \"src/document/doc-debug.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          function flattenDoc(doc) {\n            if (!doc) {\n              return \"\";\n            }\n            if (isConcat(doc)) {\n              const res = [];\n              for (const part of getDocParts(doc)) {\n                if (isConcat(part)) {\n                  res.push(...flattenDoc(part).parts);\n                } else {\n                  const flattened = flattenDoc(part);\n                  if (flattened !== \"\") {\n                    res.push(flattened);\n                  }\n                }\n              }\n              return {\n                type: \"concat\",\n                parts: res\n              };\n            }\n            if (doc.type === \"if-break\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                breakContents: flattenDoc(doc.breakContents),\n                flatContents: flattenDoc(doc.flatContents)\n              });\n            }\n            if (doc.type === \"group\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents),\n                expandedStates: doc.expandedStates && doc.expandedStates.map(flattenDoc)\n              });\n            }\n            if (doc.type === \"fill\") {\n              return {\n                type: \"fill\",\n                parts: doc.parts.map(flattenDoc)\n              };\n            }\n            if (doc.contents) {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents)\n              });\n            }\n            return doc;\n          }\n          function printDocToDebug(doc) {\n            const printedSymbols = /* @__PURE__ */ Object.create(null);\n            const usedKeysForSymbols = /* @__PURE__ */ new Set();\n            return printDoc(flattenDoc(doc));\n            function printDoc(doc2, index, parentParts) {\n              if (typeof doc2 === \"string\") {\n                return JSON.stringify(doc2);\n              }\n              if (isConcat(doc2)) {\n                const printed = getDocParts(doc2).map(printDoc).filter(Boolean);\n                return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;\n              }\n              if (doc2.type === \"line\") {\n                const withBreakParent = Array.isArray(parentParts) && parentParts[index + 1] && parentParts[index + 1].type === \"break-parent\";\n                if (doc2.literal) {\n                  return withBreakParent ? \"literalline\" : \"literallineWithoutBreakParent\";\n                }\n                if (doc2.hard) {\n                  return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";\n                }\n                if (doc2.soft) {\n                  return \"softline\";\n                }\n                return \"line\";\n              }\n              if (doc2.type === \"break-parent\") {\n                const afterHardline = Array.isArray(parentParts) && parentParts[index - 1] && parentParts[index - 1].type === \"line\" && parentParts[index - 1].hard;\n                return afterHardline ? void 0 : \"breakParent\";\n              }\n              if (doc2.type === \"trim\") {\n                return \"trim\";\n              }\n              if (doc2.type === \"indent\") {\n                return \"indent(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"align\") {\n                return doc2.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + printDoc(doc2.contents) + \")\" : doc2.n < 0 ? \"dedent(\" + printDoc(doc2.contents) + \")\" : doc2.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc2.contents) + \")\" : \"align(\" + JSON.stringify(doc2.n) + \", \" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"if-break\") {\n                return \"ifBreak(\" + printDoc(doc2.breakContents) + (doc2.flatContents ? \", \" + printDoc(doc2.flatContents) : \"\") + (doc2.groupId ? (!doc2.flatContents ? ', \"\"' : \"\") + `, { groupId: ${printGroupId(doc2.groupId)} }` : \"\") + \")\";\n              }\n              if (doc2.type === \"indent-if-break\") {\n                const optionsParts = [];\n                if (doc2.negate) {\n                  optionsParts.push(\"negate: true\");\n                }\n                if (doc2.groupId) {\n                  optionsParts.push(`groupId: ${printGroupId(doc2.groupId)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                return `indentIfBreak(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"group\") {\n                const optionsParts = [];\n                if (doc2.break && doc2.break !== \"propagated\") {\n                  optionsParts.push(\"shouldBreak: true\");\n                }\n                if (doc2.id) {\n                  optionsParts.push(`id: ${printGroupId(doc2.id)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                if (doc2.expandedStates) {\n                  return `conditionalGroup([${doc2.expandedStates.map((part) => printDoc(part)).join(\",\")}]${options})`;\n                }\n                return `group(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"fill\") {\n                return `fill([${doc2.parts.map((part) => printDoc(part)).join(\", \")}])`;\n              }\n              if (doc2.type === \"line-suffix\") {\n                return \"lineSuffix(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"line-suffix-boundary\") {\n                return \"lineSuffixBoundary\";\n              }\n              if (doc2.type === \"label\") {\n                return `label(${JSON.stringify(doc2.label)}, ${printDoc(doc2.contents)})`;\n              }\n              throw new Error(\"Unknown doc type \" + doc2.type);\n            }\n            function printGroupId(id) {\n              if (typeof id !== \"symbol\") {\n                return JSON.stringify(String(id));\n              }\n              if (id in printedSymbols) {\n                return printedSymbols[id];\n              }\n              const prefix = String(id).slice(7, -1) || \"symbol\";\n              for (let counter = 0; ; counter++) {\n                const key = prefix + (counter > 0 ? ` #${counter}` : \"\");\n                if (!usedKeysForSymbols.has(key)) {\n                  usedKeysForSymbols.add(key);\n                  return printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`;\n                }\n              }\n            }\n          }\n          module2.exports = {\n            printDocToDebug\n          };\n        }\n      });\n      init_define_process();\n      module.exports = {\n        builders: require_doc_builders(),\n        printer: require_doc_printer(),\n        utils: require_doc_utils(),\n        debug: require_doc_debug()\n      };\n    }\n  });\n  return require_doc_js_umd();\n});","import { createParserContext, ParserState } from \"./state\";\nimport { getLazyParser, Parser, lastState } from \"./parse\";\n\nimport { Options, RequiredOptions } from \"prettier\";\nimport { Doc } from \"prettier\";\nimport { builders as b, printer } from \"prettier/doc\";\nimport chalk from \"chalk\";\n\nconst MAX_LINES = 4;\nconst MAX_LINE_LENGTH = 80;\n\nconst defaultGroupOptions = {};\n\nconst defaultOptions = {\n    printWidth: 30,\n    tabWidth: 4,\n    useTabs: false,\n} as RequiredOptions;\n\nexport function prettierPrint(doc: Doc) {\n    return printer.printDocToString(doc, defaultOptions).formatted;\n}\n\nexport const summarizeLine = (line: string, maxLength: number = MAX_LINE_LENGTH) => {\n    const newLine = line.indexOf(\"\\n\");\n    const length = Math.min(line.length, newLine === -1 ? line.length : newLine);\n\n    if (length <= MAX_LINE_LENGTH) {\n        return line;\n    } else {\n        return line.slice(0, maxLength) + \"...\";\n    }\n};\n\nexport function addCursor(\n    state: ParserState<any>,\n    cursor: string = \"^\",\n    error: boolean = false\n): string {\n    const color = (error ? chalk.red : chalk.green).bold;\n\n    const lines = state.src.split(\"\\n\");\n    const lineIdx = Math.min(lines.length - 1, state.getLineNumber());\n    const startIdx = Math.max(lineIdx - MAX_LINES, 0);\n    const endIdx = Math.min(lineIdx + MAX_LINES + 1, lines.length);\n\n    const lineSummaries = lines.slice(startIdx, endIdx);\n\n    if (cursor) {\n        const cursorLine = \" \".repeat(state.getColumnNumber()) + color(cursor);\n        lineSummaries.splice(lineIdx - startIdx + 1, 0, cursorLine);\n    }\n\n    const resultLines = lineSummaries.map((line, idx) => {\n        const lineNum = startIdx + idx + 1;\n        let paddedLineNum = color.reset.black(String(lineNum));\n\n        line = lineNum === lineIdx + 1 ? color(line) : line;\n        const paddedLine = `      ${paddedLineNum}| ${line}`;\n\n        return paddedLine;\n    });\n\n    return resultLines.join(\"\\n\");\n}\n\nconst group = (docs: Doc, groupOptions: Options = {}) => {\n    return b.group(docs, { ...defaultOptions, ...groupOptions } as any);\n};\n\nconst opStyle = (op: string) => chalk.gray(op);\nconst PARSER_STRINGS = new Map<number, any>();\n\nexport function parserPrint(parser: Parser<any>) {\n    if (PARSER_STRINGS.has(parser.id)) {\n        return PARSER_STRINGS.get(parser.id);\n    }\n\n    const print = (innerParser: Parser<any>, id?: number) => {\n        if (PARSER_STRINGS.has(innerParser.id)) {\n            return PARSER_STRINGS.get(innerParser.id);\n        }\n\n        const { name, args, parser: innerInnerParser } = innerParser.context;\n        const parserString =\n            innerInnerParser != null\n                ? print(innerInnerParser, id)\n                : chalk.red.bold(\"unknown\");\n\n        let s = (() => {\n            switch (name) {\n                case \"string\":\n                    return chalk.yellow(`\"${args[0]}\"`);\n                case \"regex\":\n                case \"regexConcat\":\n                case \"regexWrap\":\n                    return chalk.redBright(`${args[0]}`);\n                case \"wrap\":\n                case \"trim\": {\n                    const [left, right] = args;\n                    return group([\n                        print(left, id),\n                        b.indent([b.softline, parserString]),\n                        b.softline,\n                        print(right, id),\n                    ]);\n                }\n                case \"trimWhitespace\":\n                    return group([parserString, opStyle(\"?w\")]);\n                case \"not\":\n                    return group([\"!\", parserString]);\n                case \"opt\":\n                    return group([parserString, opStyle(\"?\")]);\n                case \"next\":\n                    const [next] = args;\n                    return group([parserString, opStyle(\" >> \"), print(next, id)]);\n                case \"skip\":\n                    const [skip] = args;\n                    return group([parserString, opStyle(\" << \"), print(skip, id)]);\n\n                case \"map\":\n                    return parserString;\n                case \"all\":\n                case \"then\": {\n                    const delim = opStyle(\", \");\n                    return group([\n                        \"[\",\n                        b.indent([\n                            b.softline,\n                            b.join(\n                                [delim, b.softline],\n                                args.map((x) => print(x, id))\n                            ),\n                        ]),\n                        b.softline,\n                        \"]\",\n                    ]);\n                }\n                case \"any\":\n                case \"or\": {\n                    const delim = opStyle(\"| \");\n                    return group([\n                        [\n                            b.join(\n                                [b.softline, b.ifBreak(delim, \" \" + delim)],\n                                args.map((x) => print(x, id))\n                            ),\n                        ],\n                    ]);\n                }\n                case \"many\":\n                    const [min, max] = args;\n                    let bounds = max === Infinity ? `${min},` : `${min},${max}`;\n                    bounds = chalk.bold.gray(` {${bounds}}`);\n                    return group([parserString, bounds]);\n                case \"sepBy\":\n                    return group([\n                        parserString,\n                        b.indent([\" sepBy \", print(args[0], id)]),\n                    ]);\n                case \"lazy\": {\n                    const [lazy] = args;\n                    const p = getLazyParser(lazy);\n\n                    if (!id) {\n                        const s = print(p, p.id);\n                        PARSER_STRINGS.set(p.id, s);\n                        return s;\n                    } else {\n                        return chalk.bold.blue(name);\n                    }\n                }\n                case \"debug\":\n                    return parserString;\n            }\n        })();\n        s ??= chalk.red.bold(name);\n        if (id) {\n            PARSER_STRINGS.set(innerParser.id, s);\n        }\n        return s;\n    };\n\n    const doc = print(parser);\n    const s = prettierPrint(doc);\n    PARSER_STRINGS.set(parser.id, s);\n\n    return s;\n}\n\nexport function statePrint(\n    state: ParserState<any>,\n    name: string = \"\",\n    parserString: string = \"\"\n) {\n    const stateBgColor = !state.isError ? chalk.bgGreen : chalk.bgRed;\n    const stateColor = !state.isError ? chalk.green : chalk.red;\n\n    const finished = state.offset >= state.src.length;\n\n    const stateSymbol = !state.isError ? (finished ? \"\" : \"\") : \"\";\n    const stateName = !state.isError ? (finished ? \"Done\" : \"Ok\") : \"Err\";\n    const stateString = \" \" + stateName + \" \" + stateSymbol + \" \";\n\n    const header = group([\n        stateBgColor.bold(stateString),\n        stateColor(`\\t${name}\\t${state.offset}`),\n        b.softline,\n        \"\\t\" + chalk.yellow(parserString),\n    ]);\n\n    const body = (() => {\n        if (state.offset >= state.src.length) {\n            return chalk.bold.greenBright(addCursor(state, \"\", state.isError));\n        }\n        return addCursor(state, \"^\", state.isError);\n    })();\n\n    const headerBody = group([header, b.hardline, b.indent([body])]);\n\n    return prettierPrint(headerBody);\n}\n\nexport function parserDebug<T>(\n    parser: Parser<T>,\n    name: string = \"\",\n    recursivePrint: boolean = false,\n    logger: (...s: any[]) => void = console.log\n) {\n    const debug = (state: ParserState<T>) => {\n        const newState = parser.parser(state);\n\n        const parserString = recursivePrint ? parserPrint(parser) : parser.context.name;\n        const s = statePrint(newState, name, parserString);\n\n        logger(s);\n\n        return newState;\n    };\n    return new Parser(debug, createParserContext(\"debug\", parser, logger));\n}\n","import { createParserContext, ParserContext, ParserState } from \"./state\";\nimport { parserDebug, parserPrint } from \"./debug\";\n\ntype ExtractValue<T extends ReadonlyArray<Parser<any>>> = {\n    [K in keyof T]: T[K] extends Parser<infer V> ? V : never;\n};\n\ntype ParserFunction<T = string> = (val: ParserState<T>) => ParserState<T>;\n\nlet PARSER_ID = 0;\n\nconst MEMO = new Map<number, ParserState<any>>();\nconst LEFT_RECURSION_COUNTS = new Map<string, number>();\n\nlet lastState: ParserState<any> | undefined;\n\nexport function mergeErrorState(state: ParserState<any>) {\n    if (!lastState || (lastState && state.offset > lastState.offset)) {\n        lastState = state;\n    }\n    return lastState;\n}\n\nexport function getLazyParser<T>(fn: () => Parser<T>) {\n    if (fn.parser) {\n        return fn.parser;\n    }\n    return (fn.parser = fn());\n}\n\nexport class Parser<T = string> {\n    id: number = PARSER_ID++;\n    state: ParserState<T> | undefined;\n\n    constructor(public parser: ParserFunction<T>, public context: ParserContext = {}) {}\n\n    reset() {\n        lastState = undefined;\n        MEMO.clear();\n        LEFT_RECURSION_COUNTS.clear();\n    }\n\n    parse(val: string) {\n        this.reset();\n\n        const newState = this.parser(new ParserState(val));\n\n        this.state = mergeErrorState(newState);\n        this.state.isError = newState.isError;\n\n        return newState.value;\n    }\n\n    getCijKey(state: ParserState<T>) {\n        return `${this.id}${state.offset}`;\n    }\n\n    atLeftRecursionLimit(state: ParserState<T>) {\n        const cij = LEFT_RECURSION_COUNTS.get(this.getCijKey(state)) ?? 0;\n        return cij > state.src.length - state.offset;\n    }\n\n    memoize() {\n        const memoize = (state: ParserState<T>) => {\n            const cijKey = this.getCijKey(state);\n            const cij = LEFT_RECURSION_COUNTS.get(cijKey) ?? 0;\n\n            let cached = MEMO.get(this.id);\n\n            if (cached && cached.offset >= state.offset) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            LEFT_RECURSION_COUNTS.set(cijKey, cij + 1);\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n\n            if (cached && cached.offset > newState.offset) {\n                newState.offset = cached.offset;\n            } else if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n\n            return newState;\n        };\n        return new Parser(\n            memoize as ParserFunction<T>,\n            createParserContext(\"memoize\", this)\n        );\n    }\n\n    mergeMemos<S>() {\n        const mergeMemo = (state: ParserState<T>) => {\n            let cached = MEMO.get(this.id);\n            if (cached) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n            if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n            return newState;\n        };\n\n        return new Parser(\n            mergeMemo as ParserFunction<[T, S]>,\n            createParserContext(\"mergeMemo\", this)\n        );\n    }\n\n    then<S>(next: Parser<S | T>) {\n        if (isStringParsers(this, next)) {\n            return concatStringParsers([this, next], \"\", (m) => [m?.[0], m?.[1]]);\n        }\n\n        const then = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = next.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok([nextState1.value, nextState2.value]);\n                }\n            }\n            mergeErrorState(state);\n            return state.err(undefined);\n        };\n\n        return new Parser(\n            then as ParserFunction<[T, S]>,\n            createParserContext(\"then\", this, this, next)\n        );\n    }\n\n    or<S>(other: Parser<S | T>) {\n        if (isStringParsers(this, other)) {\n            return concatStringParsers([this, other], \"|\");\n        }\n\n        const or = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (!newState.isError) {\n                return newState;\n            }\n            return other.parser(state);\n        };\n\n        return new Parser(\n            or as ParserFunction<T | S>,\n            createParserContext(\"or\", this, this, other)\n        );\n    }\n\n    chain<S>(fn: (value: T) => Parser<S | T>, chainError: boolean = false) {\n        const chain = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            } else if (newState.value || chainError) {\n                return fn(newState.value).parser(newState);\n            }\n            return state;\n        };\n\n        return new Parser(chain, createParserContext(\"chain\", this, fn));\n    }\n\n    map<S>(fn: (value: T) => S, mapError: boolean = false) {\n        const map = (state: ParserState<T | S>) => {\n            const newState = this.parser(state as ParserState<T>);\n\n            if (!newState.isError || mapError) {\n                return newState.ok(fn(newState.value));\n            }\n            return newState;\n        };\n\n        return new Parser(map as ParserFunction<S>, createParserContext(\"map\", this));\n    }\n\n    mapState<S extends T>(fn: (state: ParserState<T>) => ParserState<S>) {\n        const mapState = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            return fn(newState);\n        };\n\n        return new Parser(\n            mapState as ParserFunction<S>,\n            createParserContext(\"mapState\", this)\n        );\n    }\n\n    skip<S>(parser: Parser<T | S>) {\n        const skip = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n            let nextState2;\n\n            if (!nextState1.isError) {\n                nextState2 = parser.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok(nextState1.value);\n                }\n            }\n            mergeErrorState(state);\n            return state.err(undefined);\n        };\n        return new Parser(\n            skip as ParserFunction<T>,\n            createParserContext(\"skip\", this, parser)\n        );\n    }\n\n    next<S>(parser: Parser<S>) {\n        const next = this.then(parser).map(([, b]) => {\n            return b;\n        }) as Parser<S>;\n        next.context = createParserContext(\"next\", this, parser);\n        return next;\n    }\n\n    opt() {\n        const opt = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            if (newState.isError) {\n                mergeErrorState(state);\n                return state.ok(undefined);\n            }\n            return newState;\n        };\n        return new Parser(opt as ParserFunction<T>, createParserContext(\"opt\", this));\n    }\n\n    not<S>(parser?: Parser<S>) {\n        const negate = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                mergeErrorState(state);\n                return state.ok(state.value);\n            } else {\n                return state.err(undefined);\n            }\n        };\n\n        const not = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                mergeErrorState(state);\n                return newState;\n            } else {\n                const nextState = parser.parser(state);\n                if (nextState.isError) {\n                    return newState;\n                } else {\n                    mergeErrorState(state);\n                    return state.err(undefined);\n                }\n            }\n        };\n\n        return new Parser(\n            parser ? not : negate,\n            createParserContext(\"not\", this, parser)\n        );\n    }\n\n    wrap<L, R>(start: Parser<L>, end: Parser<R>, discard: boolean = true) {\n        if (!discard) {\n            return all(start, this, end);\n        }\n\n        if (isStringParsers(start, this, end)) {\n            return wrapStringParsers(start, this, end);\n        }\n        const wrap = start.next(this).skip(end) as Parser<T>;\n        wrap.context = createParserContext(\"wrap\", this, start, end);\n        return wrap;\n    }\n\n    trim(parser: Parser<T> = whitespace as Parser<T>, discard: boolean = true) {\n        if (!discard) {\n            return all(parser, this, parser);\n        }\n\n        if (parser.context?.name === \"whitespace\") {\n            if (isStringParsers(this, parser)) {\n                return concatStringParsers(\n                    [parser, this, parser],\n                    \"\",\n                    (m) => m?.[2]\n                ) as Parser<T>;\n            }\n\n            const whitespaceTrim = (state: ParserState<T>) => {\n                const newState = trimStateWhitespace(state);\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    mergeErrorState(state);\n                    return state.err(undefined);\n                } else {\n                    return trimStateWhitespace(tmpState);\n                }\n            };\n\n            return new Parser(\n                whitespaceTrim as ParserFunction<T>,\n                createParserContext(\"trimWhitespace\", this)\n            ) as Parser<T>;\n        }\n\n        return this.wrap(parser, parser) as Parser<T>;\n    }\n\n    many(min: number = 0, max: number = Infinity) {\n        const many = (state: ParserState<T>) => {\n            const matches: T[] = [];\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    break;\n                }\n                matches.push(tmpState.value);\n                newState = tmpState;\n            }\n\n            if (matches.length >= min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            mergeErrorState(state);\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            many as ParserFunction<T[]>,\n            createParserContext(\"many\", this, min, max)\n        );\n    }\n\n    sepBy<S>(sep: Parser<S | T>, min: number = 0, max: number = Infinity) {\n        const sepBy = (state: ParserState<T>) => {\n            const matches: T[] = [];\n\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n                if (tmpState.isError) {\n                    break;\n                }\n                newState = tmpState;\n                matches.push(newState.value);\n\n                const sepState = sep.parser(newState);\n                if (sepState.isError) {\n                    break;\n                }\n                newState = sepState as ParserState<T>;\n            }\n\n            if (matches.length > min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            mergeErrorState(state);\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            sepBy as ParserFunction<T[]>,\n            createParserContext(\"sepBy\", this, sep)\n        );\n    }\n\n    eof() {\n        const p = this.skip(eof()) as Parser<T>;\n        p.context = createParserContext(\"eof\", this);\n        return p;\n    }\n\n    debug(\n        name: string = \"\",\n        recursivePrint: boolean = false,\n        logger: (...s: any[]) => void = console.log\n    ) {\n        return parserDebug(this, name, recursivePrint, logger);\n    }\n\n    toString() {\n        return parserPrint(this);\n    }\n\n    static lazy<T>(fn: () => Parser<T>) {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(fn).parser(state);\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, fn));\n    }\n}\n\nfunction isStringParsers(...parsers: Parser<any>[]) {\n    return parsers.every(\n        (p) =>\n            (p.context?.name === \"string\" ||\n                p.context?.name === \"regex\" ||\n                p.context?.name === \"whitespace\") &&\n            p.context?.args\n    );\n}\n\nfunction stringParserValue(p: Parser<any>) {\n    if (p.context?.name === \"string\") {\n        return p.context?.args[0].replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    } else if (p.context?.name === \"regex\" || p.context?.name === \"whitespace\") {\n        return p.context?.args[0].source;\n    }\n}\n\nfunction concatStringParsers(\n    parsers: Parser<any>[],\n    delim: string = \"\",\n    matchFunction?: (m: RegExpMatchArray) => any\n): Parser<string> {\n    const s = parsers.map((s) => `(${stringParserValue(s)})`).join(delim);\n    const r = new RegExp(s);\n    const rP = regex(r, matchFunction);\n\n    if (delim !== \"|\") {\n        rP.context = createParserContext(\"regexConcat\", this, r);\n    }\n    return rP;\n}\n\nfunction wrapStringParsers<L, T, R>(\n    left: Parser<L>,\n    p: Parser<T>,\n    right: Parser<R>\n): Parser<string> {\n    const rP = concatStringParsers([left, p, right], \"\", (m) => {\n        return m?.[2];\n    });\n    rP.context.name = \"regexWrap\";\n    return rP;\n}\n\nexport function eof<T>() {\n    const eof = (state: ParserState<T>) => {\n        if (state.offset >= state.src.length) {\n            return state.ok(undefined);\n        } else {\n            return state.err();\n        }\n    };\n    return new Parser(eof, createParserContext(\"eof\", undefined)) as Parser<any>;\n}\n\nexport function lazy<T>(\n    target: any,\n    propertyName: string,\n    descriptor: TypedPropertyDescriptor<() => Parser<T>>\n) {\n    const method = descriptor.value.bind(target)!;\n\n    descriptor.value = function () {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(method).parser(state) as ParserState<T>;\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, method));\n    };\n}\n\nexport function any<T extends any[]>(...parsers: T) {\n    if (isStringParsers(...parsers)) {\n        return concatStringParsers(parsers, \"|\") as Parser<ExtractValue<T>[number]>;\n    }\n\n    const any = (state: ParserState<T>) => {\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n            if (!newState.isError) {\n                return newState;\n            }\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : any,\n        createParserContext(\"any\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>[number]>;\n}\n\nexport function all<T extends any[]>(...parsers: T) {\n    const all = (state: ParserState<ExtractValue<T>>): ParserState<ExtractValue<T>> => {\n        const matches = [] as any;\n\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            }\n\n            // TODO! hack or ...?\n            if (newState.value !== undefined) {\n                matches.push(newState.value);\n            }\n            state = newState;\n        }\n        mergeErrorState(state);\n        return state.ok(matches);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : all,\n        createParserContext(\"all\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>>;\n}\n\nexport function string(str: string) {\n    const string = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n        const s = state.src.slice(state.offset, state.offset + str.length);\n        if (s === str) {\n            return state.ok(s, s.length);\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        string as ParserFunction<string>,\n        createParserContext(\"string\", undefined, str)\n    );\n}\n\nexport function regex(\n    r: RegExp,\n    matchFunction: (match: RegExpMatchArray) => any = (m) => m?.[0]\n) {\n    const flags = r.flags.replace(/y/g, \"\");\n    const sticky = new RegExp(r, flags + \"y\");\n\n    const regex = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n\n        sticky.lastIndex = state.offset;\n        const match = matchFunction(state.src.match(sticky));\n\n        if (match) {\n            return state.ok(match, sticky.lastIndex - state.offset);\n        } else if (match === \"\") {\n            return state.ok(undefined);\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        regex as ParserFunction<string>,\n        createParserContext(\"regex\", undefined, r)\n    );\n}\n\nconst WHITESPACE = /\\s*/y;\nconst trimStateWhitespace = <T>(state: ParserState<T>) => {\n    if (state.offset >= state.src.length) {\n        return state;\n    }\n\n    WHITESPACE.lastIndex = state.offset;\n    const match = state.src.match(WHITESPACE)?.[0] ?? \"\";\n    return state.ok(state.value, match.length);\n};\n\nexport const whitespace = regex(/\\s*/);\nwhitespace.context.name = \"whitespace\";\n"],"names":["ParserState","src","value","offset","isError","furthest","nextState","lastNewline","columnNumber","newlineIndex","parserNames","createParserContext","name","parser","args","factory","module","__getOwnPropNames","__commonJS","cb","mod","require_doc_js_umd","exports","__create","__defProp","__getOwnPropDesc","__getOwnPropNames2","__getProtoOf","__hasOwnProp","__esm","fn","res","__commonJS2","__export","target","all","__copyProps","to","from","except","desc","key","__toESM","isNodeMode","__toCommonJS","init_define_process","require_doc_builders","exports2","module2","concat","parts","indent","contents","align","widthOrString","group","opts","dedentToRoot","markAsRoot","dedent","conditionalGroup","states","fill","ifBreak","breakContents","flatContents","indentIfBreak","lineSuffix","lineSuffixBoundary","breakParent","trim","hardlineWithoutBreakParent","literallineWithoutBreakParent","line","softline","hardline","literalline","cursor","join","sep","arr","i","addAlignmentToDoc","doc","size","tabWidth","aligned","label","label2","require_end_of_line","guessEndOfLine","text","index","convertEndOfLineToChars","countEndOfLineChars","eol","regex","endOfLines","normalizeEndOfLine","require_get_last","getLast","ansiRegex","onlyFirst","pattern","init_ansi_regex","stripAnsi","string","init_strip_ansi","isFullwidthCodePoint","codePoint","init_is_fullwidth_code_point","require_emoji_regex","string_width_exports","stringWidth","import_emoji_regex","width","init_string_width","require_get_string_width","stringWidth2","notAsciiRegex","getStringWidth","require_doc_utils","isConcat","getDocParts","traverseDocOnExitStackMarker","traverseDoc","onEnter","onExit","shouldTraverseConditionalGroups","docsStack","doc2","ic","mapDoc","mapped","rec","result","process2","expandedStates","findInDoc","defaultValue","hasStopped","findInDocOnEnterFn","maybeResult","willBreakFn","willBreak","breakParentGroup","groupStack","parentGroup","propagateBreaks","alreadyVisitedSet","propagateBreaksOnEnterFn","propagateBreaksOnExitFn","removeLinesFn","removeLines","isHardline","nextDoc","stripDocTrailingHardlineFromDoc","lastPart","stripTrailingHardline","cleanDoc","cleanDocFn","part","currentPart","restParts","currentDoc","normalizeParts","newParts","normalizeDoc","replaceEndOfLine","replaceTextEndOfLine","replacement","canBreakFn","canBreak","require_doc_printer","groupModeMap","MODE_BREAK","MODE_FLAT","rootIndent","makeIndent","ind","options","generateInd","makeAlign","indent2","widthOrDoc","newPart","queue","length","lastTabs","lastSpaces","flush","addTabs","addSpaces","flushSpaces","count","flushTabs","resetLast","out","trimCount","trimmed","fits","next","restCommands","hasLineSuffix","mustBeFlat","restIdx","cmds","mode","groupMode","printDocToString","newLine","pos","shouldRemeasure","formatted","rem","mostExpanded","state","cmd","content","whitespace","contentFlatCmd","contentBreakCmd","contentFits","whitespaceFlatCmd","whitespaceBreakCmd","remainingCmd","secondContent","cursorPlaceholderIndex","otherCursorPlaceholderIndex","beforeCursor","aroundCursor","afterCursor","require_doc_debug","flattenDoc","flattened","printDocToDebug","printedSymbols","usedKeysForSymbols","printDoc","parentParts","printed","withBreakParent","printGroupId","optionsParts","id","prefix","counter","MAX_LINES","MAX_LINE_LENGTH","defaultOptions","prettierPrint","printer","summarizeLine","maxLength","addCursor","error","color","chalk","lines","lineIdx","startIdx","endIdx","lineSummaries","cursorLine","idx","lineNum","paddedLineNum","docs","groupOptions","b","opStyle","op","PARSER_STRINGS","parserPrint","print","innerParser","innerInnerParser","parserString","s","left","right","skip","delim","x","min","max","bounds","lazy","p","getLazyParser","statePrint","stateBgColor","stateColor","finished","stateSymbol","stateString","header","body","headerBody","parserDebug","recursivePrint","logger","debug","newState","Parser","PARSER_ID","MEMO","LEFT_RECURSION_COUNTS","lastState","mergeErrorState","context","__publicField","val","memoize","cijKey","cij","cached","mergeMemo","isStringParsers","concatStringParsers","m","then","nextState1","nextState2","other","or","chainError","chain","mapError","map","mapState","opt","negate","not","start","end","discard","wrapStringParsers","wrap","_a","whitespaceTrim","trimStateWhitespace","tmpState","many","matches","sepBy","sepState","eof","parsers","_b","_c","_d","stringParserValue","_e","matchFunction","r","rP","propertyName","descriptor","method","any","str","flags","sticky","match","WHITESPACE"],"mappings":"mNAEO,MAAMA,EAAe,CACxB,YACWC,EACAC,EAAW,OACXC,EAAiB,EACjBC,EAAmB,GACnBC,EAAmB,EAC5B,CALS,KAAA,IAAAJ,EACA,KAAA,MAAAC,EACA,KAAA,OAAAC,EACA,KAAA,QAAAC,EACA,KAAA,SAAAC,CACR,CAEH,GAAMH,EAAUC,EAAiB,EAAG,CAChC,OAAAA,GAAU,KAAK,OACR,IAAIH,GAAe,KAAK,IAAKE,EAAOC,EAAQ,EAAK,CAC5D,CAEA,IAAOD,EAAWC,EAAiB,EAAG,CAClC,MAAMG,EAAY,KAAK,GAAGJ,EAAOC,CAAM,EACvC,OAAAG,EAAU,QAAU,GACbA,CACX,CAEA,KAAQJ,EAAUC,EAAiB,EAAG,CAClC,OAAAA,GAAU,KAAK,OACR,IAAIH,GAAe,KAAK,IAAKE,EAAOC,EAAQ,KAAK,OAAO,CACnE,CAEA,iBAA0B,CACtB,MAAMA,EAAS,KAAK,OACdI,EAAc,KAAK,IAAI,YAAY;AAAA,EAAMJ,CAAM,EAC/CK,EAAeD,IAAgB,GAAKJ,EAASA,GAAUI,EAAc,GACpE,OAAA,KAAK,IAAI,EAAGC,CAAY,CACnC,CAEA,eAAwB,CACpB,MAAMC,EAAe,KAAK,IAAI,YAAY;AAAA,EAAM,KAAK,MAAM,EACpD,OAAAA,GAAgB,EACjB,KAAK,IAAI,MAAM,EAAGA,CAAY,EAAE,MAAM;AAAA,CAAI,EAAE,OAC5C,CACV,CACJ,CAEO,MAAMC,GAAc,CACvB,SACA,QACA,OACA,KACA,QACA,MACA,OACA,OACA,UACA,YACA,MACA,OACA,OACA,OACA,iBACA,aACA,OACA,QACA,MACA,MACA,MACA,YACA,aACA,MACA,cACA,YACA,QACA,UACJ,EASgB,SAAAC,EACZC,EACAC,KACGC,EACL,CACS,MAAA,CACH,KAAAF,EACA,OAAAC,EACA,KAAAC,CAAA,CAER,2EC1FC,SAAUC,EAAS,CAEhBC,EAAA,QAAiBD,GAcrB,GAAG,UAAW,CAEZ,IAAIE,EAAoB,OAAO,oBAC3BC,EAAa,CAACC,EAAIC,IAAQ,UAAqB,CACjD,OAAOA,MAAWD,EAAGF,EAAkBE,CAAE,EAAE,CAAC,CAAC,IAAIC,EAAM,CAAE,QAAS,CAAA,IAAM,QAASA,CAAG,EAAGA,EAAI,OAC/F,EAGMC,EAAqBH,EAAW,CAClC,sBAAsBI,EAASN,EAAQ,CACrC,IAAIO,EAAW,OAAO,OAClBC,EAAY,OAAO,eACnBC,EAAmB,OAAO,yBAC1BC,EAAqB,OAAO,oBAC5BC,GAAe,OAAO,eACtBC,GAAe,OAAO,UAAU,eAChCC,GAAQ,CAACC,EAAIC,IAAQ,UAAkB,CACzC,OAAOD,IAAOC,KAAUD,EAAGJ,EAAmBI,CAAE,EAAE,CAAC,CAAC,GAAGA,EAAK,CAAC,GAAIC,CACzE,EACUC,EAAc,CAACb,EAAIC,IAAQ,UAAqB,CAClD,OAAOA,MAAWD,EAAGO,EAAmBP,CAAE,EAAE,CAAC,CAAC,IAAIC,EAAM,CACtD,QAAS,CAAE,CACZ,GAAE,QAASA,CAAG,EAAGA,EAAI,OAC9B,EACUa,GAAW,CAACC,EAAQC,IAAQ,CAC9B,QAASvB,KAAQuB,EACfX,EAAUU,EAAQtB,EAAM,CACtB,IAAKuB,EAAIvB,CAAI,EACb,WAAY,EACxB,CAAW,CACX,EACUwB,EAAc,CAACC,EAAIC,EAAMC,EAAQC,IAAS,CAC5C,GAAIF,GAAQ,OAAOA,GAAS,UAAY,OAAOA,GAAS,WACtD,QAASG,KAAOf,EAAmBY,CAAI,EACjC,CAACV,GAAa,KAAKS,EAAII,CAAG,GAAKA,IAAQF,GACzCf,EAAUa,EAAII,EAAK,CACjB,IAAK,IAAMH,EAAKG,CAAG,EACnB,WAAY,EAAED,EAAOf,EAAiBa,EAAMG,CAAG,IAAMD,EAAK,UAC1E,CAAe,EAEP,OAAOH,CACf,EACUK,EAAU,CAACtB,EAAKuB,EAAYT,KAAYA,EAASd,GAAO,KAAOG,EAASI,GAAaP,CAAG,CAAC,EAAI,GAAIgB,EAAYO,GAAc,CAACvB,GAAO,CAACA,EAAI,WAAaI,EAAUU,EAAQ,UAAW,CACpL,MAAOd,EACP,WAAY,EACpB,CAAO,EAAIc,EAAQd,CAAG,GACZwB,GAAgBxB,GAAQgB,EAAYZ,EAAU,CAAE,EAAE,aAAc,CAClE,MAAO,EACf,CAAO,EAAGJ,CAAG,EACHyB,EAAsBhB,GAAM,CAC9B,oBAAqB,CACpB,CACT,CAAO,EACGiB,GAAuBd,EAAY,CACrC,+BAA+Be,EAAUC,EAAS,CAEhDH,IACA,SAASI,EAAOC,EAAO,CAMrB,MAAO,CACL,KAAM,SACN,MAAAA,CACd,CACW,CACD,SAASC,EAAOC,EAAU,CAIxB,MAAO,CACL,KAAM,SACN,SAAAA,CACd,CACW,CACD,SAASC,EAAMC,EAAeF,EAAU,CAItC,MAAO,CACL,KAAM,QACN,SAAAA,EACA,EAAGE,CACjB,CACW,CACD,SAASC,EAAMH,EAAU,CACvB,IAAII,EAAO,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAS,UAAU,CAAC,EAAI,CAAA,EAI5E,MAAO,CACL,KAAM,QACN,GAAIA,EAAK,GACT,SAAAJ,EACA,MAAO,QAAQI,EAAK,WAAW,EAC/B,eAAgBA,EAAK,cACnC,CACW,CACD,SAASC,EAAaL,EAAU,CAC9B,OAAOC,EAAM,OAAO,kBAAmBD,CAAQ,CAChD,CACD,SAASM,EAAWN,EAAU,CAC5B,OAAOC,EAAM,CACX,KAAM,MACP,EAAED,CAAQ,CACZ,CACD,SAASO,EAAOP,EAAU,CACxB,OAAOC,EAAM,GAAID,CAAQ,CAC1B,CACD,SAASQ,EAAiBC,EAAQL,EAAM,CACtC,OAAOD,EAAMM,EAAO,CAAC,EAAG,OAAO,OAAO,OAAO,OAAO,CAAA,EAAIL,CAAI,EAAG,CAAA,EAAI,CACjE,eAAgBK,CACjB,CAAA,CAAC,CACH,CACD,SAASC,EAAKZ,EAAO,CAMnB,MAAO,CACL,KAAM,OACN,MAAAA,CACd,CACW,CACD,SAASa,EAAQC,EAAeC,EAAc,CAC5C,IAAIT,EAAO,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAS,UAAU,CAAC,EAAI,CAAA,EAS5E,MAAO,CACL,KAAM,WACN,cAAAQ,EACA,aAAAC,EACA,QAAST,EAAK,OAC5B,CACW,CACD,SAASU,EAAcd,EAAUI,EAAM,CACrC,MAAO,CACL,KAAM,kBACN,SAAAJ,EACA,QAASI,EAAK,QACd,OAAQA,EAAK,MAC3B,CACW,CACD,SAASW,EAAWf,EAAU,CAI5B,MAAO,CACL,KAAM,cACN,SAAAA,CACd,CACW,CACD,IAAIgB,EAAqB,CACvB,KAAM,sBAClB,EACcC,EAAc,CAChB,KAAM,cAClB,EACcC,GAAO,CACT,KAAM,MAClB,EACcC,GAA6B,CAC/B,KAAM,OACN,KAAM,EAClB,EACcC,EAAgC,CAClC,KAAM,OACN,KAAM,GACN,QAAS,EACrB,EACcC,GAAO,CACT,KAAM,MAClB,EACcC,EAAW,CACb,KAAM,OACN,KAAM,EAClB,EACcC,EAAW1B,EAAO,CAACsB,GAA4BF,CAAW,CAAC,EAC3DO,EAAc3B,EAAO,CAACuB,EAA+BH,CAAW,CAAC,EACjEQ,EAAS,CACX,KAAM,SACN,YAAa,OAAO,QAAQ,CACxC,EACU,SAASC,EAAKC,EAAKC,EAAK,CACtB,MAAMjD,EAAM,CAAA,EACZ,QAASkD,EAAI,EAAGA,EAAID,EAAI,OAAQC,IAC1BA,IAAM,GACRlD,EAAI,KAAKgD,CAAG,EAEdhD,EAAI,KAAKiD,EAAIC,CAAC,CAAC,EAEjB,OAAOhC,EAAOlB,CAAG,CAClB,CACD,SAASmD,EAAkBC,EAAKC,EAAMC,EAAU,CAC9C,IAAIC,EAAUH,EACd,GAAIC,EAAO,EAAG,CACZ,QAASH,EAAI,EAAGA,EAAI,KAAK,MAAMG,EAAOC,CAAQ,EAAG,EAAEJ,EACjDK,EAAUnC,EAAOmC,CAAO,EAE1BA,EAAUjC,EAAM+B,EAAOC,EAAUC,CAAO,EACxCA,EAAUjC,EAAM,OAAO,kBAAmBiC,CAAO,CAClD,CACD,OAAOA,CACR,CACD,SAASC,EAAMC,EAAQpC,EAAU,CAC/B,MAAO,CACL,KAAM,QACN,MAAOoC,EACP,SAAApC,CACd,CACW,CACDJ,EAAQ,QAAU,CAChB,OAAAC,EACA,KAAA6B,EACA,KAAAL,GACA,SAAAC,EACA,SAAAC,EACA,YAAAC,EACA,MAAArB,EACA,iBAAAK,EACA,KAAAE,EACA,WAAAK,EACA,mBAAAC,EACA,OAAAS,EACA,YAAAR,EACA,QAAAN,EACA,KAAAO,GACA,OAAAnB,EACA,cAAAe,EACA,MAAAb,EACA,kBAAA6B,EACA,WAAAxB,EACA,aAAAD,EACA,OAAAE,EACA,2BAAAY,GACA,8BAAAC,EACA,MAAAe,CACZ,CACS,CACT,CAAO,EACGE,GAAsBzD,EAAY,CACpC,4BAA4Be,EAAUC,EAAS,CAE7CH,IACA,SAAS6C,EAAeC,EAAM,CAC5B,MAAMC,EAAQD,EAAK,QAAQ,IAAI,EAC/B,OAAIC,GAAS,EACJD,EAAK,OAAOC,EAAQ,CAAC,IAAM;AAAA,EAAO,OAAS,KAE7C,IACR,CACD,SAASC,EAAwB3F,EAAO,CACtC,OAAQA,EAAK,CACX,IAAK,KACH,MAAO,KACT,IAAK,OACH,MAAO;AAAA,EACT,QACE,MAAO;AAAA,CACV,CACF,CACD,SAAS4F,EAAoBH,EAAMI,EAAK,CACtC,IAAIC,EACJ,OAAQD,EAAG,CACT,IAAK;AAAA,EACHC,EAAQ,MACR,MACF,IAAK,KACHA,EAAQ,MACR,MACF,IAAK;AAAA,EACHA,EAAQ,QACR,MACF,QACE,MAAM,IAAI,MAAM,oBAAoB,KAAK,UAAUD,CAAG,IAAI,CAC7D,CACD,MAAME,EAAaN,EAAK,MAAMK,CAAK,EACnC,OAAOC,EAAaA,EAAW,OAAS,CACzC,CACD,SAASC,EAAmBP,EAAM,CAChC,OAAOA,EAAK,QAAQ,SAAU;AAAA,CAAI,CACnC,CACD3C,EAAQ,QAAU,CAChB,eAAA0C,EACA,wBAAAG,EACA,oBAAAC,EACA,mBAAAI,CACZ,CACS,CACT,CAAO,EACGC,GAAmBnE,EAAY,CACjC,wBAAwBe,EAAUC,EAAS,CAEzCH,IACA,IAAIuD,EAAWpB,GAAQA,EAAIA,EAAI,OAAS,CAAC,EACzChC,EAAQ,QAAUoD,CACnB,CACT,CAAO,EACD,SAASC,IAAY,CACnB,GAAI,CACF,UAAAC,EAAY,EACb,EAAG,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAS,UAAU,CAAC,EAAI,CAAA,EACrE,MAAMC,EAAU,CAAC,+HAAgI,0DAA0D,EAAE,KAAK,GAAG,EACrN,OAAO,IAAI,OAAOA,EAASD,EAAY,OAAS,GAAG,CACpD,CACD,IAAIE,GAAkB3E,GAAM,CAC1B,4DAA6D,CAC3DgB,GACD,CACT,CAAO,EACD,SAAS4D,GAAUC,EAAQ,CACzB,GAAI,OAAOA,GAAW,SACpB,MAAM,IAAI,UAAU,gCAAgC,OAAOA,KAAU,EAEvE,OAAOA,EAAO,QAAQL,GAAW,EAAE,EAAE,CACtC,CACD,IAAIM,GAAkB9E,GAAM,CAC1B,oCAAqC,CACnCgB,IACA2D,IACD,CACT,CAAO,EACD,SAASI,GAAqBC,EAAW,CACvC,OAAK,OAAO,UAAUA,CAAS,EAGxBA,GAAa,OAASA,GAAa,MAAQA,IAAc,MAAQA,IAAc,MAAQ,OAASA,GAAaA,GAAa,OAASA,IAAc,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,OAASA,GAAaA,GAAa,OAAS,QAAUA,GAAaA,GAAa,QAAU,QAAUA,GAAaA,GAAa,QAAU,QAAUA,GAAaA,GAAa,QAFpqB,EAGV,CACD,IAAIC,GAA+BjF,GAAM,CACvC,iDAAkD,CAChDgB,GACD,CACT,CAAO,EACGkE,GAAsB/E,EAAY,CACpC,oCAAoCe,EAAUC,EAAS,CAErDH,IACAG,EAAQ,QAAU,UAAW,CAC3B,MAAO,gyeACnB,CACS,CACT,CAAO,EACGgE,GAAuB,CAAA,EAC3B/E,GAAS+E,GAAsB,CAC7B,QAAS,IAAMC,EACvB,CAAO,EACD,SAASA,GAAYP,EAAQ,CAK3B,GAJI,OAAOA,GAAW,UAAYA,EAAO,SAAW,IAGpDA,EAASD,GAAUC,CAAM,EACrBA,EAAO,SAAW,GACpB,MAAO,GAETA,EAASA,EAAO,WAAYQ,GAAmB,SAAO,EAAK,IAAI,EAC/D,IAAIC,EAAQ,EACZ,QAASvB,EAAQ,EAAGA,EAAQc,EAAO,OAAQd,IAAS,CAClD,MAAMiB,EAAYH,EAAO,YAAYd,CAAK,EACtCiB,GAAa,IAAMA,GAAa,KAAOA,GAAa,KAGpDA,GAAa,KAAOA,GAAa,MAGjCA,EAAY,OACdjB,IAEFuB,GAASP,GAAqBC,CAAS,EAAI,EAAI,EAChD,CACD,OAAOM,CACR,CACD,IAAID,GACAE,GAAoBvF,GAAM,CAC5B,sCAAuC,CACrCgB,IACA8D,KACAG,KACAI,GAAqBxE,EAAQqE,GAAmB,CAAE,CACnD,CACT,CAAO,EACGM,GAA2BrF,EAAY,CACzC,gCAAgCe,EAAUC,EAAS,CAEjDH,IACA,IAAIyE,GAAgBF,GAAiB,EAAIxE,GAAaoE,EAAoB,GAAG,QACzEO,EAAgB,eACpB,SAASC,EAAe7B,EAAM,CAC5B,OAAKA,EAGA4B,EAAc,KAAK5B,CAAI,EAGrB2B,EAAa3B,CAAI,EAFfA,EAAK,OAHL,CAMV,CACD3C,EAAQ,QAAUwE,CACnB,CACT,CAAO,EACGC,GAAoBzF,EAAY,CAClC,4BAA4Be,EAAUC,EAAS,CAE7CH,IACA,IAAIuD,EAAUD,KACV,CACF,YAAAvB,EACA,KAAAE,CACD,EAAGhC,GAAoB,EACpB4E,EAAYvC,GAAQ,MAAM,QAAQA,CAAG,GAAKA,GAAOA,EAAI,OAAS,SAC9DwC,EAAexC,GAAQ,CACzB,GAAI,MAAM,QAAQA,CAAG,EACnB,OAAOA,EAET,GAAIA,EAAI,OAAS,UAAYA,EAAI,OAAS,OACxC,MAAM,IAAI,MAAM,2CAA2C,EAE7D,OAAOA,EAAI,KACvB,EACcyC,EAA+B,CAAA,EACnC,SAASC,EAAY1C,EAAK2C,EAASC,EAAQC,EAAiC,CAC1E,MAAMC,EAAY,CAAC9C,CAAG,EACtB,KAAO8C,EAAU,OAAS,GAAG,CAC3B,MAAMC,EAAOD,EAAU,MACvB,GAAIC,IAASN,EAA8B,CACzCG,EAAOE,EAAU,IAAG,CAAE,EACtB,QACD,CAID,GAHIF,GACFE,EAAU,KAAKC,EAAMN,CAA4B,EAE/C,CAACE,GAAWA,EAAQI,CAAI,IAAM,GAChC,GAAIR,EAASQ,CAAI,GAAKA,EAAK,OAAS,OAAQ,CAC1C,MAAMhF,EAAQyE,EAAYO,CAAI,EAC9B,QAASC,EAAKjF,EAAM,OAAQ+B,GAAIkD,EAAK,EAAGlD,IAAK,EAAG,EAAEA,GAChDgD,EAAU,KAAK/E,EAAM+B,EAAC,CAAC,CAE3C,SAA2BiD,EAAK,OAAS,WACnBA,EAAK,cACPD,EAAU,KAAKC,EAAK,YAAY,EAE9BA,EAAK,eACPD,EAAU,KAAKC,EAAK,aAAa,UAE1BA,EAAK,OAAS,SAAWA,EAAK,eACvC,GAAIF,EACF,QAASG,EAAKD,EAAK,eAAe,OAAQjD,EAAIkD,EAAK,EAAGlD,GAAK,EAAG,EAAEA,EAC9DgD,EAAU,KAAKC,EAAK,eAAejD,CAAC,CAAC,OAGvCgD,EAAU,KAAKC,EAAK,QAAQ,OAErBA,EAAK,UACdD,EAAU,KAAKC,EAAK,QAAQ,CAGjC,CACF,CACD,SAASE,EAAOjD,EAAKhE,EAAI,CACvB,MAAMkH,EAAyB,IAAI,IACnC,OAAOC,EAAInD,CAAG,EACd,SAASmD,EAAIJ,EAAM,CACjB,GAAIG,EAAO,IAAIH,CAAI,EACjB,OAAOG,EAAO,IAAIH,CAAI,EAExB,MAAMK,EAASC,EAASN,CAAI,EAC5B,OAAAG,EAAO,IAAIH,EAAMK,CAAM,EAChBA,CACR,CACD,SAASC,EAASN,EAAM,CACtB,GAAI,MAAM,QAAQA,CAAI,EACpB,OAAO/G,EAAG+G,EAAK,IAAII,CAAG,CAAC,EAEzB,GAAIJ,EAAK,OAAS,UAAYA,EAAK,OAAS,OAAQ,CAClD,MAAMhF,EAAQgF,EAAK,MAAM,IAAII,CAAG,EAChC,OAAOnH,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,EAAE+G,CAAI,EAAG,GAAI,CACnD,MAAAhF,CACD,CAAA,CAAC,CACH,CACD,GAAIgF,EAAK,OAAS,WAAY,CAC5B,MAAMlE,EAAgBkE,EAAK,eAAiBI,EAAIJ,EAAK,aAAa,EAC5DjE,EAAeiE,EAAK,cAAgBI,EAAIJ,EAAK,YAAY,EAC/D,OAAO/G,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,EAAE+G,CAAI,EAAG,GAAI,CACnD,cAAAlE,EACA,aAAAC,CACD,CAAA,CAAC,CACH,CACD,GAAIiE,EAAK,OAAS,SAAWA,EAAK,eAAgB,CAChD,MAAMO,EAAiBP,EAAK,eAAe,IAAII,CAAG,EAC5ClF,EAAWqF,EAAe,CAAC,EACjC,OAAOtH,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,EAAE+G,CAAI,EAAG,GAAI,CACnD,SAAA9E,EACA,eAAAqF,CACD,CAAA,CAAC,CACH,CACD,GAAIP,EAAK,SAAU,CACjB,MAAM9E,EAAWkF,EAAIJ,EAAK,QAAQ,EAClC,OAAO/G,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,EAAE+G,CAAI,EAAG,GAAI,CACnD,SAAA9E,CACD,CAAA,CAAC,CACH,CACD,OAAOjC,EAAG+G,CAAI,CACf,CACF,CACD,SAASQ,EAAUvD,EAAKrD,EAAI6G,EAAc,CACxC,IAAIJ,EAASI,EACTC,EAAa,GACjB,SAASC,EAAmBX,EAAM,CAChC,MAAMY,EAAchH,EAAGoG,CAAI,EAK3B,GAJIY,IAAgB,SAClBF,EAAa,GACbL,EAASO,GAEPF,EACF,MAAO,EAEV,CACD,OAAAf,EAAY1C,EAAK0D,CAAkB,EAC5BN,CACR,CACD,SAASQ,EAAY5D,EAAK,CAOxB,GANIA,EAAI,OAAS,SAAWA,EAAI,OAG5BA,EAAI,OAAS,QAAUA,EAAI,MAG3BA,EAAI,OAAS,eACf,MAAO,EAEV,CACD,SAAS6D,EAAU7D,EAAK,CACtB,OAAOuD,EAAUvD,EAAK4D,EAAa,EAAK,CACzC,CACD,SAASE,EAAiBC,EAAY,CACpC,GAAIA,EAAW,OAAS,EAAG,CACzB,MAAMC,EAAc/C,EAAQ8C,CAAU,EAClC,CAACC,EAAY,gBAAkB,CAACA,EAAY,QAC9CA,EAAY,MAAQ,aAEvB,CACD,OAAO,IACR,CACD,SAASC,EAAgBjE,EAAK,CAC5B,MAAMkE,EAAoC,IAAI,IACxCH,EAAa,CAAA,EACnB,SAASI,EAAyBpB,EAAM,CAItC,GAHIA,EAAK,OAAS,gBAChBe,EAAiBC,CAAU,EAEzBhB,EAAK,OAAS,QAAS,CAEzB,GADAgB,EAAW,KAAKhB,CAAI,EAChBmB,EAAkB,IAAInB,CAAI,EAC5B,MAAO,GAETmB,EAAkB,IAAInB,CAAI,CAC3B,CACF,CACD,SAASqB,EAAwBrB,EAAM,CACjCA,EAAK,OAAS,SACFgB,EAAW,MACf,OACRD,EAAiBC,CAAU,CAGhC,CACDrB,EAAY1C,EAAKmE,EAA0BC,EAAyB,EAAI,CACzE,CACD,SAASC,EAAcrE,EAAK,CAC1B,OAAIA,EAAI,OAAS,QAAU,CAACA,EAAI,KACvBA,EAAI,KAAO,GAAK,IAErBA,EAAI,OAAS,WACRA,EAAI,cAAgB,GAEtBA,CACR,CACD,SAASsE,GAAYtE,EAAK,CACxB,OAAOiD,EAAOjD,EAAKqE,CAAa,CACjC,CACD,IAAIE,GAAa,CAACvE,EAAKwE,IAAYxE,GAAOA,EAAI,OAAS,QAAUA,EAAI,MAAQwE,GAAWA,EAAQ,OAAS,eACzG,SAASC,EAAgCzE,EAAK,CAC5C,GAAI,CAACA,EACH,OAAOA,EAET,GAAIuC,EAASvC,CAAG,GAAKA,EAAI,OAAS,OAAQ,CACxC,MAAMjC,EAAQyE,EAAYxC,CAAG,EAC7B,KAAOjC,EAAM,OAAS,GAAKwG,GAAW,GAAGxG,EAAM,MAAM,EAAE,CAAC,GACtDA,EAAM,QAAU,EAElB,GAAIA,EAAM,OAAS,EAAG,CACpB,MAAM2G,EAAWD,EAAgCxD,EAAQlD,CAAK,CAAC,EAC/DA,EAAMA,EAAM,OAAS,CAAC,EAAI2G,CAC3B,CACD,OAAO,MAAM,QAAQ1E,CAAG,EAAIjC,EAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,EAAIiC,CAAG,EAAG,CAAA,EAAI,CAC5E,MAAAjC,CAChB,CAAe,CACF,CACD,OAAQiC,EAAI,KAAI,CACd,IAAK,QACL,IAAK,SACL,IAAK,kBACL,IAAK,QACL,IAAK,cACL,IAAK,QAAS,CACZ,MAAM/B,EAAWwG,EAAgCzE,EAAI,QAAQ,EAC7D,OAAO,OAAO,OAAO,OAAO,OAAO,GAAIA,CAAG,EAAG,GAAI,CAC/C,SAAA/B,CAClB,CAAiB,CACF,CACD,IAAK,WAAY,CACf,MAAMY,EAAgB4F,EAAgCzE,EAAI,aAAa,EACjElB,EAAe2F,EAAgCzE,EAAI,YAAY,EACrE,OAAO,OAAO,OAAO,OAAO,OAAO,GAAIA,CAAG,EAAG,GAAI,CAC/C,cAAAnB,EACA,aAAAC,CAClB,CAAiB,CACF,CACF,CACD,OAAOkB,CACR,CACD,SAAS2E,GAAsB3E,EAAK,CAClC,OAAOyE,EAAgCG,EAAS5E,CAAG,CAAC,CACrD,CACD,SAAS6E,EAAW7E,EAAK,CACvB,OAAQA,EAAI,KAAI,CACd,IAAK,OACH,GAAIA,EAAI,MAAM,MAAO8E,GAASA,IAAS,EAAE,EACvC,MAAO,GAET,MACF,IAAK,QACH,GAAI,CAAC9E,EAAI,UAAY,CAACA,EAAI,IAAM,CAACA,EAAI,OAAS,CAACA,EAAI,eACjD,MAAO,GAET,GAAIA,EAAI,SAAS,OAAS,SAAWA,EAAI,SAAS,KAAOA,EAAI,IAAMA,EAAI,SAAS,QAAUA,EAAI,OAASA,EAAI,SAAS,iBAAmBA,EAAI,eACzI,OAAOA,EAAI,SAEb,MACF,IAAK,QACL,IAAK,SACL,IAAK,kBACL,IAAK,cACH,GAAI,CAACA,EAAI,SACP,MAAO,GAET,MACF,IAAK,WACH,GAAI,CAACA,EAAI,cAAgB,CAACA,EAAI,cAC5B,MAAO,GAET,KACH,CACD,GAAI,CAACuC,EAASvC,CAAG,EACf,OAAOA,EAET,MAAMjC,EAAQ,CAAA,EACd,UAAW+G,KAAQtC,EAAYxC,CAAG,EAAG,CACnC,GAAI,CAAC8E,EACH,SAEF,KAAM,CAACC,EAAa,GAAGC,CAAS,EAAIzC,EAASuC,CAAI,EAAItC,EAAYsC,CAAI,EAAI,CAACA,CAAI,EAC1E,OAAOC,GAAgB,UAAY,OAAO9D,EAAQlD,CAAK,GAAM,SAC/DA,EAAMA,EAAM,OAAS,CAAC,GAAKgH,EAE3BhH,EAAM,KAAKgH,CAAW,EAExBhH,EAAM,KAAK,GAAGiH,CAAS,CACxB,CACD,OAAIjH,EAAM,SAAW,EACZ,GAELA,EAAM,SAAW,EACZA,EAAM,CAAC,EAET,MAAM,QAAQiC,CAAG,EAAIjC,EAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,EAAIiC,CAAG,EAAG,CAAA,EAAI,CAC5E,MAAAjC,CACd,CAAa,CACF,CACD,SAAS6G,EAAS5E,EAAK,CACrB,OAAOiD,EAAOjD,EAAMiF,GAAeJ,EAAWI,CAAU,CAAC,CAC1D,CACD,SAASC,EAAenH,EAAO,CAC7B,MAAMoH,EAAW,CAAA,EACXH,EAAYjH,EAAM,OAAO,OAAO,EACtC,KAAOiH,EAAU,OAAS,GAAG,CAC3B,MAAMF,EAAOE,EAAU,QACvB,GAAKF,EAGL,IAAIvC,EAASuC,CAAI,EAAG,CAClBE,EAAU,QAAQ,GAAGxC,EAAYsC,CAAI,CAAC,EACtC,QACD,CACD,GAAIK,EAAS,OAAS,GAAK,OAAOlE,EAAQkE,CAAQ,GAAM,UAAY,OAAOL,GAAS,SAAU,CAC5FK,EAASA,EAAS,OAAS,CAAC,GAAKL,EACjC,QACD,CACDK,EAAS,KAAKL,CAAI,EACnB,CACD,OAAOK,CACR,CACD,SAASC,EAAapF,EAAK,CACzB,OAAOiD,EAAOjD,EAAMiF,GACd,MAAM,QAAQA,CAAU,EACnBC,EAAeD,CAAU,EAE7BA,EAAW,MAGT,OAAO,OAAO,OAAO,OAAO,GAAIA,CAAU,EAAG,GAAI,CACtD,MAAOC,EAAeD,EAAW,KAAK,CACtD,CAAe,EAJQA,CAKV,CACF,CACD,SAASI,EAAiBrF,EAAK,CAC7B,OAAOiD,EAAOjD,EAAMiF,GAAe,OAAOA,GAAe,UAAYA,EAAW,SAAS;AAAA,CAAI,EAAIK,EAAqBL,CAAU,EAAIA,CAAU,CAC/I,CACD,SAASK,EAAqB9E,EAAM,CAClC,IAAI+E,EAAc,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAS,UAAU,CAAC,EAAI9F,EACnF,OAAOE,EAAK4F,EAAa/E,EAAK,MAAM;AAAA,CAAI,CAAC,EAAE,KAC5C,CACD,SAASgF,EAAWxF,EAAK,CACvB,GAAIA,EAAI,OAAS,OACf,MAAO,EAEV,CACD,SAASyF,EAASzF,EAAK,CACrB,OAAOuD,EAAUvD,EAAKwF,EAAY,EAAK,CACxC,CACD3H,EAAQ,QAAU,CAChB,SAAA0E,EACA,YAAAC,EACA,UAAAqB,EACA,YAAAnB,EACA,UAAAa,EACA,OAAAN,EACA,gBAAAgB,EACA,YAAAK,GACA,sBAAAK,GACA,eAAAO,EACA,aAAAE,EACA,SAAAR,EACA,qBAAAU,EACA,iBAAAD,EACA,SAAAI,CACZ,CACS,CACT,CAAO,EACGC,GAAsB7I,EAAY,CACpC,8BAA8Be,EAAUC,EAAS,CAE/CH,IACA,GAAI,CACF,wBAAAgD,CACD,EAAGJ,GAAmB,EACnBW,EAAUD,KACVqB,EAAiBH,KACjB,CACF,KAAAvD,EACA,OAAAe,EACA,OAAA1B,CACD,EAAGL,GAAoB,EACpB,CACF,SAAA4E,EACA,YAAAC,CACD,EAAGF,GAAiB,EACjBqD,EACAC,EAAa,EACbC,EAAY,EAChB,SAASC,GAAa,CACpB,MAAO,CACL,MAAO,GACP,OAAQ,EACR,MAAO,CAAE,CACvB,CACW,CACD,SAASC,EAAWC,EAAKC,EAAS,CAChC,OAAOC,GAAYF,EAAK,CACtB,KAAM,QACP,EAAEC,CAAO,CACX,CACD,SAASE,EAAUC,EAASC,EAAYJ,EAAS,CAC/C,OAAII,IAAe,OAAO,kBACjBD,EAAQ,MAAQN,IAErBO,EAAa,EACRH,GAAYE,EAAS,CAC1B,KAAM,QACP,EAAEH,CAAO,EAEPI,EAGDA,EAAW,OAAS,OACf,OAAO,OAAO,OAAO,OAAO,GAAID,CAAO,EAAG,GAAI,CACnD,KAAMA,CACtB,CAAe,EAGIF,GAAYE,EAAS,CAC1B,KAFgB,OAAOC,GAAe,SAAW,cAAgB,cAGjE,EAAGA,CACJ,EAAEJ,CAAO,EAXDG,CAYV,CACD,SAASF,GAAYF,EAAKM,EAASL,EAAS,CAC1C,MAAMM,EAAQD,EAAQ,OAAS,SAAWN,EAAI,MAAM,MAAM,EAAG,EAAE,EAAI,CAAC,GAAGA,EAAI,MAAOM,CAAO,EACzF,IAAIvL,EAAQ,GACRyL,EAAS,EACTC,EAAW,EACXC,EAAa,EACjB,UAAW5B,KAAQyB,EACjB,OAAQzB,EAAK,KAAI,CACf,IAAK,SACH6B,IACIV,EAAQ,QACVW,EAAQ,CAAC,EAETC,EAAUZ,EAAQ,QAAQ,EAE5B,MACF,IAAK,cACHU,IACA5L,GAAS+J,EAAK,EACd0B,GAAU1B,EAAK,EAAE,OACjB,MACF,IAAK,cACH2B,GAAY,EACZC,GAAc5B,EAAK,EACnB,MACF,QACE,MAAM,IAAI,MAAM,oBAAoBA,EAAK,OAAO,CACnD,CAEH,OAAAgC,IACO,OAAO,OAAO,OAAO,OAAO,GAAId,CAAG,EAAG,GAAI,CAC/C,MAAAjL,EACA,OAAAyL,EACA,MAAAD,CACd,CAAa,EACD,SAASK,EAAQG,EAAO,CACtBhM,GAAS,IAAI,OAAOgM,CAAK,EACzBP,GAAUP,EAAQ,SAAWc,CAC9B,CACD,SAASF,EAAUE,EAAO,CACxBhM,GAAS,IAAI,OAAOgM,CAAK,EACzBP,GAAUO,CACX,CACD,SAASJ,GAAQ,CACXV,EAAQ,QACVe,IAEAF,GAEH,CACD,SAASE,GAAY,CACfP,EAAW,GACbG,EAAQH,CAAQ,EAElBQ,GACD,CACD,SAASH,GAAc,CACjBJ,EAAa,GACfG,EAAUH,CAAU,EAEtBO,GACD,CACD,SAASA,GAAY,CACnBR,EAAW,EACXC,EAAa,CACd,CACF,CACD,SAASvH,GAAK+H,EAAK,CACjB,GAAIA,EAAI,SAAW,EACjB,MAAO,GAET,IAAIC,EAAY,EAChB,KAAOD,EAAI,OAAS,GAAK,OAAOjG,EAAQiG,CAAG,GAAM,UAAY,WAAW,KAAKjG,EAAQiG,CAAG,CAAC,GACvFC,GAAaD,EAAI,IAAK,EAAC,OAEzB,GAAIA,EAAI,OAAS,GAAK,OAAOjG,EAAQiG,CAAG,GAAM,SAAU,CACtD,MAAME,EAAUnG,EAAQiG,CAAG,EAAE,QAAQ,UAAW,EAAE,EAClDC,GAAalG,EAAQiG,CAAG,EAAE,OAASE,EAAQ,OAC3CF,EAAIA,EAAI,OAAS,CAAC,EAAIE,CACvB,CACD,OAAOD,CACR,CACD,SAASE,EAAKC,EAAMC,EAAcvF,EAAOwF,EAAeC,EAAY,CAClE,IAAIC,EAAUH,EAAa,OAC3B,MAAMI,EAAO,CAACL,CAAI,EACZJ,EAAM,CAAA,EACZ,KAAOlF,GAAS,GAAG,CACjB,GAAI2F,EAAK,SAAW,EAAG,CACrB,GAAID,IAAY,EACd,MAAO,GAETC,EAAK,KAAKJ,EAAa,EAAEG,CAAO,CAAC,EACjC,QACD,CACD,KAAM,CACJ,KAAAE,EACA,IAAA5H,CAChB,EAAkB2H,EAAK,MACT,GAAI,OAAO3H,GAAQ,SACjBkH,EAAI,KAAKlH,CAAG,EACZgC,GAASK,EAAerC,CAAG,UAClBuC,EAASvC,CAAG,GAAKA,EAAI,OAAS,OAAQ,CAC/C,MAAMjC,EAAQyE,EAAYxC,CAAG,EAC7B,QAASF,EAAI/B,EAAM,OAAS,EAAG+B,GAAK,EAAGA,IACrC6H,EAAK,KAAK,CACR,KAAAC,EACA,IAAK7J,EAAM+B,CAAC,CAChC,CAAmB,CAEnB,KACgB,QAAQE,EAAI,KAAI,CACd,IAAK,SACL,IAAK,QACL,IAAK,kBACL,IAAK,QACH2H,EAAK,KAAK,CACR,KAAAC,EACA,IAAK5H,EAAI,QAC/B,CAAqB,EACD,MACF,IAAK,OACHgC,GAAS7C,GAAK+H,CAAG,EACjB,MACF,IAAK,QAAS,CACZ,GAAIO,GAAczH,EAAI,MACpB,MAAO,GAET,MAAM6H,EAAY7H,EAAI,MAAQ4F,EAAagC,EACrC3J,EAAW+B,EAAI,gBAAkB6H,IAAcjC,EAAa3E,EAAQjB,EAAI,cAAc,EAAIA,EAAI,SACpG2H,EAAK,KAAK,CACR,KAAME,EACN,IAAK5J,CAC3B,CAAqB,EACD,KACD,CACD,IAAK,WAAY,CAEf,MAAMA,GADY+B,EAAI,QAAU2F,EAAa3F,EAAI,OAAO,GAAK6F,EAAY+B,KAC1ChC,EAAa5F,EAAI,cAAgBA,EAAI,aAChE/B,GACF0J,EAAK,KAAK,CACR,KAAAC,EACA,IAAK3J,CAC7B,CAAuB,EAEH,KACD,CACD,IAAK,OACH,GAAI2J,IAAShC,GAAc5F,EAAI,KAC7B,MAAO,GAEJA,EAAI,OACPkH,EAAI,KAAK,GAAG,EACZlF,KAEF,MACF,IAAK,cACHwF,EAAgB,GAChB,MACF,IAAK,uBACH,GAAIA,EACF,MAAO,GAET,KACH,CAEJ,CACD,MAAO,EACR,CACD,SAASM,GAAiB9H,EAAKiG,EAAS,CACtCN,EAAe,CAAA,EACf,MAAM3D,EAAQiE,EAAQ,WAChB8B,EAAUrH,EAAwBuF,EAAQ,SAAS,EACzD,IAAI+B,EAAM,EACV,MAAML,EAAO,CAAC,CACZ,IAAK7B,EAAY,EACjB,KAAMF,EACN,IAAA5F,CACd,CAAa,EACKkH,EAAM,CAAA,EACZ,IAAIe,EAAkB,GACtB,MAAMjJ,EAAa,CAAA,EACnB,KAAO2I,EAAK,OAAS,GAAG,CACtB,KAAM,CACJ,IAAA3B,EACA,KAAA4B,EACA,IAAK7E,CACrB,EAAkB4E,EAAK,MACT,GAAI,OAAO5E,GAAS,SAAU,CAC5B,MAAMmF,EAAYH,IAAY;AAAA,EAAOhF,EAAK,QAAQ,MAAOgF,CAAO,EAAIhF,EACpEmE,EAAI,KAAKgB,CAAS,EAClBF,GAAO3F,EAAe6F,CAAS,CAC/C,SAAyB3F,EAASQ,CAAI,EAAG,CACzB,MAAMhF,EAAQyE,EAAYO,CAAI,EAC9B,QAASjD,EAAI/B,EAAM,OAAS,EAAG+B,GAAK,EAAGA,IACrC6H,EAAK,KAAK,CACR,IAAA3B,EACA,KAAA4B,EACA,IAAK7J,EAAM+B,CAAC,CAChC,CAAmB,CAEnB,KACgB,QAAQiD,EAAK,KAAI,CACf,IAAK,SACHmE,EAAI,KAAKxH,EAAO,WAAW,EAC3B,MACF,IAAK,SACHiI,EAAK,KAAK,CACR,IAAK5B,EAAWC,EAAKC,CAAO,EAC5B,KAAA2B,EACA,IAAK7E,EAAK,QAChC,CAAqB,EACD,MACF,IAAK,QACH4E,EAAK,KAAK,CACR,IAAKxB,EAAUH,EAAKjD,EAAK,EAAGkD,CAAO,EACnC,KAAA2B,EACA,IAAK7E,EAAK,QAChC,CAAqB,EACD,MACF,IAAK,OACHiF,GAAO7I,GAAK+H,CAAG,EACf,MACF,IAAK,QACH,OAAQU,EAAI,CACV,KAAK/B,EACH,GAAI,CAACoC,EAAiB,CACpBN,EAAK,KAAK,CACR,IAAA3B,EACA,KAAMjD,EAAK,MAAQ6C,EAAaC,EAChC,IAAK9C,EAAK,QACtC,CAA2B,EACD,KACD,CACH,KAAK6C,EAAY,CACfqC,EAAkB,GAClB,MAAMX,EAAO,CACX,IAAAtB,EACA,KAAMH,EACN,IAAK9C,EAAK,QACpC,EAC8BoF,EAAMnG,EAAQgG,EACdR,EAAgBxI,EAAW,OAAS,EAC1C,GAAI,CAAC+D,EAAK,OAASsE,EAAKC,EAAMK,EAAMQ,EAAKX,CAAa,EACpDG,EAAK,KAAKL,CAAI,UAEVvE,EAAK,eAAgB,CACvB,MAAMqF,GAAenH,EAAQ8B,EAAK,cAAc,EAChD,GAAIA,EAAK,MAAO,CACd4E,EAAK,KAAK,CACR,IAAA3B,EACA,KAAMJ,EACN,IAAKwC,EACrC,CAA+B,EACD,KAC9B,KAC8B,SAAStI,GAAI,EAAGA,GAAIiD,EAAK,eAAe,OAAS,EAAGjD,KAClD,GAAIA,IAAKiD,EAAK,eAAe,OAAQ,CACnC4E,EAAK,KAAK,CACR,IAAA3B,EACA,KAAMJ,EACN,IAAKwC,EACzC,CAAmC,EACD,KAClC,KAAuC,CACL,MAAMC,GAAQtF,EAAK,eAAejD,EAAC,EAC7BwI,GAAM,CACV,IAAAtC,EACA,KAAMH,EACN,IAAKwC,EACzC,EACkC,GAAIhB,EAAKiB,GAAKX,EAAMQ,EAAKX,CAAa,EAAG,CACvCG,EAAK,KAAKW,EAAG,EACb,KACD,CACF,CAGjC,MAC4BX,EAAK,KAAK,CACR,IAAA3B,EACA,KAAMJ,EACN,IAAK7C,EAAK,QACxC,CAA6B,EAGL,KACD,CACF,CACGA,EAAK,KACP4C,EAAa5C,EAAK,EAAE,EAAI9B,EAAQ0G,CAAI,EAAE,MAExC,MACF,IAAK,OAAQ,CACX,MAAMQ,EAAMnG,EAAQgG,EACd,CACJ,MAAAjK,CACD,EAAGgF,EACJ,GAAIhF,EAAM,SAAW,EACnB,MAEF,KAAM,CAACwK,EAASC,EAAU,EAAIzK,EACxB0K,GAAiB,CACrB,IAAAzC,EACA,KAAMH,EACN,IAAK0C,CAC3B,EAC0BG,GAAkB,CACtB,IAAA1C,EACA,KAAMJ,EACN,IAAK2C,CAC3B,EAC0BI,GAActB,EAAKoB,GAAgB,CAAE,EAAEN,EAAKnJ,EAAW,OAAS,EAAG,EAAI,EAC7E,GAAIjB,EAAM,SAAW,EAAG,CAClB4K,GACFhB,EAAK,KAAKc,EAAc,EAExBd,EAAK,KAAKe,EAAe,EAE3B,KACD,CACD,MAAME,GAAoB,CACxB,IAAA5C,EACA,KAAMH,EACN,IAAK2C,EAC3B,EAC0BK,GAAqB,CACzB,IAAA7C,EACA,KAAMJ,EACN,IAAK4C,EAC3B,EACoB,GAAIzK,EAAM,SAAW,EAAG,CAClB4K,GACFhB,EAAK,KAAKiB,GAAmBH,EAAc,EAE3Cd,EAAK,KAAKkB,GAAoBH,EAAe,EAE/C,KACD,CACD3K,EAAM,OAAO,EAAG,CAAC,EACjB,MAAM+K,GAAe,CACnB,IAAA9C,EACA,KAAA4B,EACA,IAAKjJ,EAAKZ,CAAK,CACrC,EAC0BgL,GAAgBhL,EAAM,CAAC,EAMKsJ,EALG,CACnC,IAAArB,EACA,KAAMH,EACN,IAAK,CAAC0C,EAASC,GAAYO,EAAa,CAC9D,EACyF,CAAE,EAAEZ,EAAKnJ,EAAW,OAAS,EAAG,EAAI,EAEvG2I,EAAK,KAAKmB,GAAcF,GAAmBH,EAAc,EAChDE,GACThB,EAAK,KAAKmB,GAAcD,GAAoBJ,EAAc,EAE1Dd,EAAK,KAAKmB,GAAcD,GAAoBH,EAAe,EAE7D,KACD,CACD,IAAK,WACL,IAAK,kBAAmB,CACtB,MAAMb,EAAY9E,EAAK,QAAU4C,EAAa5C,EAAK,OAAO,EAAI6E,EAC9D,GAAIC,IAAcjC,EAAY,CAC5B,MAAM/G,EAAgBkE,EAAK,OAAS,WAAaA,EAAK,cAAgBA,EAAK,OAASA,EAAK,SAAW/E,EAAO+E,EAAK,QAAQ,EACpHlE,GACF8I,EAAK,KAAK,CACR,IAAA3B,EACA,KAAA4B,EACA,IAAK/I,CAC/B,CAAyB,CAEJ,CACD,GAAIgJ,IAAchC,EAAW,CAC3B,MAAM/G,EAAeiE,EAAK,OAAS,WAAaA,EAAK,aAAeA,EAAK,OAAS/E,EAAO+E,EAAK,QAAQ,EAAIA,EAAK,SAC3GjE,GACF6I,EAAK,KAAK,CACR,IAAA3B,EACA,KAAA4B,EACA,IAAK9I,CAC/B,CAAyB,CAEJ,CACD,KACD,CACD,IAAK,cACHE,EAAW,KAAK,CACd,IAAAgH,EACA,KAAA4B,EACA,IAAK7E,EAAK,QAChC,CAAqB,EACD,MACF,IAAK,uBACC/D,EAAW,OAAS,GACtB2I,EAAK,KAAK,CACR,IAAA3B,EACA,KAAA4B,EACA,IAAK,CACH,KAAM,OACN,KAAM,EACP,CACzB,CAAuB,EAEH,MACF,IAAK,OACH,OAAQA,EAAI,CACV,KAAK/B,EACH,GAAK9C,EAAK,KAORkF,EAAkB,OAPJ,CACTlF,EAAK,OACRmE,EAAI,KAAK,GAAG,EACZc,GAAO,GAET,KAC1B,CAGsB,KAAKpC,EACH,GAAI5G,EAAW,OAAS,EAAG,CACzB2I,EAAK,KAAK,CACR,IAAA3B,EACA,KAAA4B,EACA,IAAK7E,CACjC,EAA6B,GAAG/D,EAAW,QAAO,CAAE,EAC1BA,EAAW,OAAS,EACpB,KACD,CACG+D,EAAK,QACHiD,EAAI,MACNkB,EAAI,KAAKa,EAAS/B,EAAI,KAAK,KAAK,EAChCgC,EAAMhC,EAAI,KAAK,SAEfkB,EAAI,KAAKa,CAAO,EAChBC,EAAM,IAGRA,GAAO7I,GAAK+H,CAAG,EACfA,EAAI,KAAKa,EAAU/B,EAAI,KAAK,EAC5BgC,EAAMhC,EAAI,QAEZ,KACH,CACD,MACF,IAAK,QACH2B,EAAK,KAAK,CACR,IAAA3B,EACA,KAAA4B,EACA,IAAK7E,EAAK,QAChC,CAAqB,EACD,KAEH,CAEC4E,EAAK,SAAW,GAAK3I,EAAW,OAAS,IAC3C2I,EAAK,KAAK,GAAG3I,EAAW,QAAS,CAAA,EACjCA,EAAW,OAAS,EAEvB,CACD,MAAMgK,EAAyB9B,EAAI,QAAQxH,EAAO,WAAW,EAC7D,GAAIsJ,IAA2B,GAAI,CACjC,MAAMC,EAA8B/B,EAAI,QAAQxH,EAAO,YAAasJ,EAAyB,CAAC,EACxFE,EAAehC,EAAI,MAAM,EAAG8B,CAAsB,EAAE,KAAK,EAAE,EAC3DG,EAAejC,EAAI,MAAM8B,EAAyB,EAAGC,CAA2B,EAAE,KAAK,EAAE,EACzFG,EAAclC,EAAI,MAAM+B,EAA8B,CAAC,EAAE,KAAK,EAAE,EACtE,MAAO,CACL,UAAWC,EAAeC,EAAeC,EACzC,gBAAiBF,EAAa,OAC9B,eAAgBC,CAChC,CACa,CACD,MAAO,CACL,UAAWjC,EAAI,KAAK,EAAE,CACpC,CACW,CACDrJ,EAAQ,QAAU,CAChB,iBAAAiK,EACZ,CACS,CACT,CAAO,EACGuB,GAAoBxM,EAAY,CAClC,4BAA4Be,EAAUC,EAAS,CAE7CH,IACA,GAAI,CACF,SAAA6E,EACA,YAAAC,CACD,EAAGF,GAAiB,EACrB,SAASgH,EAAWtJ,EAAK,CACvB,GAAI,CAACA,EACH,MAAO,GAET,GAAIuC,EAASvC,CAAG,EAAG,CACjB,MAAMpD,EAAM,CAAA,EACZ,UAAWkI,KAAQtC,EAAYxC,CAAG,EAChC,GAAIuC,EAASuC,CAAI,EACflI,EAAI,KAAK,GAAG0M,EAAWxE,CAAI,EAAE,KAAK,MAC7B,CACL,MAAMyE,EAAYD,EAAWxE,CAAI,EAC7ByE,IAAc,IAChB3M,EAAI,KAAK2M,CAAS,CAErB,CAEH,MAAO,CACL,KAAM,SACN,MAAO3M,CACvB,CACa,CACD,OAAIoD,EAAI,OAAS,WACR,OAAO,OAAO,OAAO,OAAO,GAAIA,CAAG,EAAG,GAAI,CAC/C,cAAesJ,EAAWtJ,EAAI,aAAa,EAC3C,aAAcsJ,EAAWtJ,EAAI,YAAY,CACzD,CAAe,EAECA,EAAI,OAAS,QACR,OAAO,OAAO,OAAO,OAAO,GAAIA,CAAG,EAAG,GAAI,CAC/C,SAAUsJ,EAAWtJ,EAAI,QAAQ,EACjC,eAAgBA,EAAI,gBAAkBA,EAAI,eAAe,IAAIsJ,CAAU,CACvF,CAAe,EAECtJ,EAAI,OAAS,OACR,CACL,KAAM,OACN,MAAOA,EAAI,MAAM,IAAIsJ,CAAU,CAC/C,EAEgBtJ,EAAI,SACC,OAAO,OAAO,OAAO,OAAO,GAAIA,CAAG,EAAG,GAAI,CAC/C,SAAUsJ,EAAWtJ,EAAI,QAAQ,CACjD,CAAe,EAEIA,CACR,CACD,SAASwJ,EAAgBxJ,EAAK,CAC5B,MAAMyJ,EAAiC,OAAO,OAAO,IAAI,EACnDC,EAAqC,IAAI,IAC/C,OAAOC,EAASL,EAAWtJ,CAAG,CAAC,EAC/B,SAAS2J,EAAS5G,EAAMtC,EAAOmJ,EAAa,CAC1C,GAAI,OAAO7G,GAAS,SAClB,OAAO,KAAK,UAAUA,CAAI,EAE5B,GAAIR,EAASQ,CAAI,EAAG,CAClB,MAAM8G,EAAUrH,EAAYO,CAAI,EAAE,IAAI4G,CAAQ,EAAE,OAAO,OAAO,EAC9D,OAAOE,EAAQ,SAAW,EAAIA,EAAQ,CAAC,EAAI,IAAIA,EAAQ,KAAK,IAAI,IACjE,CACD,GAAI9G,EAAK,OAAS,OAAQ,CACxB,MAAM+G,EAAkB,MAAM,QAAQF,CAAW,GAAKA,EAAYnJ,EAAQ,CAAC,GAAKmJ,EAAYnJ,EAAQ,CAAC,EAAE,OAAS,eAChH,OAAIsC,EAAK,QACA+G,EAAkB,cAAgB,gCAEvC/G,EAAK,KACA+G,EAAkB,WAAa,6BAEpC/G,EAAK,KACA,WAEF,MACR,CACD,GAAIA,EAAK,OAAS,eAEhB,OADsB,MAAM,QAAQ6G,CAAW,GAAKA,EAAYnJ,EAAQ,CAAC,GAAKmJ,EAAYnJ,EAAQ,CAAC,EAAE,OAAS,QAAUmJ,EAAYnJ,EAAQ,CAAC,EAAE,KACxH,OAAS,cAElC,GAAIsC,EAAK,OAAS,OAChB,MAAO,OAET,GAAIA,EAAK,OAAS,SAChB,MAAO,UAAY4G,EAAS5G,EAAK,QAAQ,EAAI,IAE/C,GAAIA,EAAK,OAAS,QAChB,OAAOA,EAAK,IAAM,OAAO,kBAAoB,gBAAkB4G,EAAS5G,EAAK,QAAQ,EAAI,IAAMA,EAAK,EAAI,EAAI,UAAY4G,EAAS5G,EAAK,QAAQ,EAAI,IAAMA,EAAK,EAAE,OAAS,OAAS,cAAgB4G,EAAS5G,EAAK,QAAQ,EAAI,IAAM,SAAW,KAAK,UAAUA,EAAK,CAAC,EAAI,KAAO4G,EAAS5G,EAAK,QAAQ,EAAI,IAExS,GAAIA,EAAK,OAAS,WAChB,MAAO,WAAa4G,EAAS5G,EAAK,aAAa,GAAKA,EAAK,aAAe,KAAO4G,EAAS5G,EAAK,YAAY,EAAI,KAAOA,EAAK,SAAYA,EAAK,aAAwB,GAAT,QAAe,gBAAgBgH,EAAahH,EAAK,OAAO,MAAQ,IAAM,IAEjO,GAAIA,EAAK,OAAS,kBAAmB,CACnC,MAAMiH,EAAe,CAAA,EACjBjH,EAAK,QACPiH,EAAa,KAAK,cAAc,EAE9BjH,EAAK,SACPiH,EAAa,KAAK,YAAYD,EAAahH,EAAK,OAAO,GAAG,EAE5D,MAAMkD,EAAU+D,EAAa,OAAS,EAAI,OAAOA,EAAa,KAAK,IAAI,MAAQ,GAC/E,MAAO,iBAAiBL,EAAS5G,EAAK,QAAQ,IAAIkD,IACnD,CACD,GAAIlD,EAAK,OAAS,QAAS,CACzB,MAAMiH,EAAe,CAAA,EACjBjH,EAAK,OAASA,EAAK,QAAU,cAC/BiH,EAAa,KAAK,mBAAmB,EAEnCjH,EAAK,IACPiH,EAAa,KAAK,OAAOD,EAAahH,EAAK,EAAE,GAAG,EAElD,MAAMkD,EAAU+D,EAAa,OAAS,EAAI,OAAOA,EAAa,KAAK,IAAI,MAAQ,GAC/E,OAAIjH,EAAK,eACA,qBAAqBA,EAAK,eAAe,IAAK+B,IAAS6E,EAAS7E,EAAI,CAAC,EAAE,KAAK,GAAG,KAAKmB,KAEtF,SAAS0D,EAAS5G,EAAK,QAAQ,IAAIkD,IAC3C,CACD,GAAIlD,EAAK,OAAS,OAChB,MAAO,SAASA,EAAK,MAAM,IAAK+B,GAAS6E,EAAS7E,CAAI,CAAC,EAAE,KAAK,IAAI,MAEpE,GAAI/B,EAAK,OAAS,cAChB,MAAO,cAAgB4G,EAAS5G,EAAK,QAAQ,EAAI,IAEnD,GAAIA,EAAK,OAAS,uBAChB,MAAO,qBAET,GAAIA,EAAK,OAAS,QAChB,MAAO,SAAS,KAAK,UAAUA,EAAK,KAAK,MAAM4G,EAAS5G,EAAK,QAAQ,KAEvE,MAAM,IAAI,MAAM,oBAAsBA,EAAK,IAAI,CAChD,CACD,SAASgH,EAAaE,EAAI,CACxB,GAAI,OAAOA,GAAO,SAChB,OAAO,KAAK,UAAU,OAAOA,CAAE,CAAC,EAElC,GAAIA,KAAMR,EACR,OAAOA,EAAeQ,CAAE,EAE1B,MAAMC,EAAS,OAAOD,CAAE,EAAE,MAAM,EAAG,EAAE,GAAK,SAC1C,QAASE,EAAU,GAAKA,IAAW,CACjC,MAAM7M,EAAM4M,GAAUC,EAAU,EAAI,KAAKA,IAAY,IACrD,GAAI,CAACT,EAAmB,IAAIpM,CAAG,EAC7B,OAAAoM,EAAmB,IAAIpM,CAAG,EACnBmM,EAAeQ,CAAE,EAAI,cAAc,KAAK,UAAU3M,CAAG,IAE/D,CACF,CACF,CACDO,EAAQ,QAAU,CAChB,gBAAA2L,CACZ,CACS,CACT,CAAO,EACD9L,IACA7B,EAAO,QAAU,CACf,SAAU8B,GAAsB,EAChC,QAAS+H,GAAqB,EAC9B,MAAOpD,GAAmB,EAC1B,MAAO+G,GAAmB,CAClC,CACK,CACL,CAAG,EACD,OAAOnN,EAAkB,CAC3B,CAAC,QCx7CD,MAAMkO,GAAY,EACZC,GAAkB,GAIlBC,GAAiB,CACnB,WAAY,GACZ,SAAU,EACV,QAAS,EACb,EAEO,SAASC,GAAcvK,EAAU,CACpC,OAAOwK,EAAQ,QAAA,iBAAiBxK,EAAKsK,EAAc,EAAE,SACzD,CAEO,MAAMG,GAAgB,CAACnL,EAAcoL,EAAoBL,KAAoB,CAC1E,MAAAtC,EAAUzI,EAAK,QAAQ;AAAA,CAAI,EAGjC,OAFe,KAAK,IAAIA,EAAK,OAAQyI,IAAY,GAAKzI,EAAK,OAASyI,CAAO,GAE7DsC,GACH/K,EAEAA,EAAK,MAAM,EAAGoL,CAAS,EAAI,KAE1C,EAEO,SAASC,GACZtC,EACA3I,EAAiB,IACjBkL,EAAiB,GACX,CACN,MAAMC,GAASD,EAAQE,EAAM,IAAMA,EAAM,OAAO,KAE1CC,EAAQ1C,EAAM,IAAI,MAAM;AAAA,CAAI,EAC5B2C,EAAU,KAAK,IAAID,EAAM,OAAS,EAAG1C,EAAM,eAAe,EAC1D4C,EAAW,KAAK,IAAID,EAAUZ,GAAW,CAAC,EAC1Cc,EAAS,KAAK,IAAIF,EAAUZ,GAAY,EAAGW,EAAM,MAAM,EAEvDI,EAAgBJ,EAAM,MAAME,EAAUC,CAAM,EAElD,GAAIxL,EAAQ,CACF,MAAA0L,EAAa,IAAI,OAAO/C,EAAM,iBAAiB,EAAIwC,EAAMnL,CAAM,EACrEyL,EAAc,OAAOH,EAAUC,EAAW,EAAG,EAAGG,CAAU,CAC9D,CAYO,OAVaD,EAAc,IAAI,CAAC7L,EAAM+L,KAAQ,CAC3C,MAAAC,GAAUL,EAAWI,GAAM,EACjC,IAAIE,GAAgBV,EAAM,MAAM,MAAM,OAAOS,EAAO,CAAC,EAErD,OAAAhM,EAAOgM,KAAYN,EAAU,EAAIH,EAAMvL,CAAI,EAAIA,EAC5B,SAASiM,OAAkBjM,GAEvC,CACV,EAEkB,KAAK;AAAA,CAAI,CAChC,CAEA,MAAMlB,EAAQ,CAACoN,EAAWC,EAAwB,KACvCC,EAAAA,SAAE,MAAMF,EAAM,CAAE,GAAGlB,GAAgB,GAAGmB,EAAqB,EAGhEE,GAAWC,GAAed,EAAM,KAAKc,CAAE,EACvCC,OAAqB,IAEpB,SAASC,GAAYpQ,EAAqB,CAC7C,GAAImQ,GAAe,IAAInQ,EAAO,EAAE,EACrB,OAAAmQ,GAAe,IAAInQ,EAAO,EAAE,EAGjC,MAAAqQ,EAAQ,CAACC,EAA0B/B,IAAgB,CACrD,GAAI4B,GAAe,IAAIG,EAAY,EAAE,EAC1B,OAAAH,GAAe,IAAIG,EAAY,EAAE,EAG5C,KAAM,CAAE,KAAAvQ,EAAM,KAAAE,EAAM,OAAQsQ,GAAqBD,EAAY,QACvDE,EACFD,GAAoB,KACdF,EAAME,EAAkBhC,CAAE,EAC1Ba,EAAM,IAAI,KAAK,SAAS,EAElC,IAAIqB,GAAK,IAAM,CACX,OAAQ1Q,EAAM,CACV,IAAK,SACD,OAAOqP,EAAM,OAAO,IAAInP,EAAK,CAAC,IAAI,EACtC,IAAK,QACL,IAAK,cACL,IAAK,YACD,OAAOmP,EAAM,UAAU,GAAGnP,EAAK,CAAC,GAAG,EACvC,IAAK,OACL,IAAK,OAAQ,CACH,KAAA,CAACyQ,EAAMC,CAAK,EAAI1Q,EACtB,OAAOyC,EAAM,CACT2N,EAAMK,EAAMnC,CAAE,EACdyB,EAAAA,SAAE,OAAO,CAACA,EAAE,SAAA,SAAUQ,CAAY,CAAC,EACnCR,EAAAA,SAAE,SACFK,EAAMM,EAAOpC,CAAE,CAAA,CAClB,CACL,CACA,IAAK,iBACD,OAAO7L,EAAM,CAAC8N,EAAcP,GAAQ,IAAI,CAAC,CAAC,EAC9C,IAAK,MACD,OAAOvN,EAAM,CAAC,IAAK8N,CAAY,CAAC,EACpC,IAAK,MACD,OAAO9N,EAAM,CAAC8N,EAAcP,GAAQ,GAAG,CAAC,CAAC,EAC7C,IAAK,OACK,KAAA,CAACrE,EAAI,EAAI3L,EACR,OAAAyC,EAAM,CAAC8N,EAAcP,GAAQ,MAAM,EAAGI,EAAMzE,GAAM2C,CAAE,CAAC,CAAC,EACjE,IAAK,OACK,KAAA,CAACqC,EAAI,EAAI3Q,EACR,OAAAyC,EAAM,CAAC8N,EAAcP,GAAQ,MAAM,EAAGI,EAAMO,GAAMrC,CAAE,CAAC,CAAC,EAEjE,IAAK,MACM,OAAAiC,EACX,IAAK,MACL,IAAK,OAAQ,CACH,MAAAK,EAAQZ,GAAQ,IAAI,EAC1B,OAAOvN,EAAM,CACT,IACAsN,EAAAA,SAAE,OAAO,CACLA,EAAAA,SAAE,SACFA,EAAAA,SAAE,KACE,CAACa,EAAOb,EAAA,SAAE,QAAQ,EAClB/P,EAAK,IAAK6Q,GAAMT,EAAMS,EAAGvC,CAAE,CAAC,CAChC,CAAA,CACH,EACDyB,EAAAA,SAAE,SACF,GAAA,CACH,CACL,CACA,IAAK,MACL,IAAK,KAAM,CACD,MAAAa,EAAQZ,GAAQ,IAAI,EAC1B,OAAOvN,EAAM,CACT,CACIsN,EAAAA,SAAE,KACE,CAACA,EAAAA,SAAE,SAAUA,EAAA,SAAE,QAAQa,EAAO,IAAMA,CAAK,CAAC,EAC1C5Q,EAAK,IAAK6Q,GAAMT,EAAMS,EAAGvC,CAAE,CAAC,CAChC,CACJ,CAAA,CACH,CACL,CACA,IAAK,OACK,KAAA,CAACwC,GAAKC,CAAG,EAAI/Q,EACnB,IAAIgR,GAASD,IAAQ,IAAW,GAAGD,MAAS,GAAGA,MAAOC,IACtD,OAAAC,GAAS7B,EAAM,KAAK,KAAK,KAAK6B,KAAS,EAChCvO,EAAM,CAAC8N,EAAcS,EAAM,CAAC,EACvC,IAAK,QACD,OAAOvO,EAAM,CACT8N,EACAR,WAAE,OAAO,CAAC,UAAWK,EAAMpQ,EAAK,CAAC,EAAGsO,CAAE,CAAC,CAAC,CAAA,CAC3C,EACL,IAAK,OAAQ,CACH,KAAA,CAAC2C,CAAI,EAAIjR,EACTkR,EAAIC,GAAcF,CAAI,EAE5B,GAAK3C,EAKM,OAAAa,EAAM,KAAK,KAAKrP,CAAI,EALtB,CACL,MAAM0Q,GAAIJ,EAAMc,EAAGA,EAAE,EAAE,EACR,OAAAhB,GAAA,IAAIgB,EAAE,GAAIV,EAAC,EACnBA,EAAA,CAIf,CACA,IAAK,QACM,OAAAD,CACf,CAAA,KAEJC,OAAAA,MAAMrB,EAAM,IAAI,KAAKrP,CAAI,GACrBwO,GACe4B,GAAA,IAAIG,EAAY,GAAIG,CAAC,EAEjCA,CAAA,EAGLnM,EAAM+L,EAAMrQ,CAAM,EAClB,EAAI6O,GAAcvK,CAAG,EACZ,OAAA6L,GAAA,IAAInQ,EAAO,GAAI,CAAC,EAExB,CACX,CAEO,SAASqR,GACZ1E,EACA5M,EAAe,GACfyQ,EAAuB,GACzB,CACE,MAAMc,EAAgB3E,EAAM,QAA0ByC,EAAM,MAAtBA,EAAM,QACtCmC,EAAc5E,EAAM,QAAwByC,EAAM,IAApBA,EAAM,MAEpCoC,EAAW7E,EAAM,QAAUA,EAAM,IAAI,OAErC8E,EAAe9E,EAAM,QAAoC,IAAzB6E,EAAW,KAAO,IAElDE,EAAc,KADD/E,EAAM,QAAuC,MAA5B6E,EAAW,OAAS,MAClB,IAAMC,EAAc,IAEpDE,EAASjP,EAAM,CACjB4O,EAAa,KAAKI,CAAW,EAC7BH,EAAW,IAAKxR,KAAS4M,EAAM,QAAQ,EACvCqD,EAAAA,SAAE,SACF,IAAOZ,EAAM,OAAOoB,CAAY,CAAA,CACnC,EAEKoB,GAAQ,IACNjF,EAAM,QAAUA,EAAM,IAAI,OACnByC,EAAM,KAAK,YAAYH,GAAUtC,EAAO,GAAIA,EAAM,OAAO,CAAC,EAE9DsC,GAAUtC,EAAO,IAAKA,EAAM,OAAO,KAGxCkF,GAAanP,EAAM,CAACiP,EAAQ3B,EAAAA,SAAE,SAAUA,EAAE,SAAA,OAAO,CAAC4B,CAAI,CAAC,CAAC,CAAC,EAE/D,OAAO/C,GAAcgD,EAAU,CACnC,CAEgB,SAAAC,GACZ9R,EACAD,EAAe,GACfgS,EAA0B,GAC1BC,EAAgC,QAAQ,IAC1C,CACQ,MAAAC,EAAStF,GAA0B,CAC/B,MAAAuF,EAAWlS,EAAO,OAAO2M,CAAK,EAE9B6D,EAAeuB,EAAiB3B,GAAYpQ,CAAM,EAAIA,EAAO,QAAQ,KACrEyQ,EAAIY,GAAWa,EAAUnS,EAAMyQ,CAAY,EAEjD,OAAAwB,EAAOvB,CAAC,EAEDyB,CAAA,EAEX,OAAO,IAAIC,EAAOF,EAAOnS,EAAoB,QAASE,EAAQgS,CAAM,CAAC,CACzE,CCvOA,IAAII,GAAY,EAEhB,MAAMC,OAAW,IACXC,OAA4B,IAElC,IAAIC,GAEG,SAASC,EAAgB7F,EAAyB,CACrD,OAAI,CAAC4F,IAAcA,IAAa5F,EAAM,OAAS4F,GAAU,UACzCA,GAAA5F,GAET4F,EACX,CAEO,SAASnB,GAAiBnQ,EAAqB,CAClD,OAAIA,EAAG,OACIA,EAAG,OAENA,EAAG,OAASA,GACxB,CAEO,MAAMkR,CAAmB,CAI5B,YAAmBnS,EAAkCyS,EAAyB,GAAI,CAHlFC,GAAA,UAAaN,MACbM,GAAA,cAEmB,KAAA,OAAA1S,EAAkC,KAAA,QAAAyS,CAA8B,CAEnF,OAAQ,CACQF,GAAA,OACZF,GAAK,MAAM,EACXC,GAAsB,MAAM,CAChC,CAEA,MAAMK,EAAa,CACf,KAAK,MAAM,EAEX,MAAMT,EAAW,KAAK,OAAO,IAAI/S,GAAYwT,CAAG,CAAC,EAE5C,YAAA,MAAQH,EAAgBN,CAAQ,EAChC,KAAA,MAAM,QAAUA,EAAS,QAEvBA,EAAS,KACpB,CAEA,UAAUvF,EAAuB,CACtB,MAAA,GAAG,KAAK,KAAKA,EAAM,QAC9B,CAEA,qBAAqBA,EAAuB,CAExC,OADY2F,GAAsB,IAAI,KAAK,UAAU3F,CAAK,CAAC,GAAK,GACnDA,EAAM,IAAI,OAASA,EAAM,MAC1C,CAEA,SAAU,CACA,MAAAiG,EAAWjG,GAA0B,CACjC,MAAAkG,EAAS,KAAK,UAAUlG,CAAK,EAC7BmG,EAAMR,GAAsB,IAAIO,CAAM,GAAK,EAEjD,IAAIE,EAASV,GAAK,IAAI,KAAK,EAAE,EAE7B,GAAIU,GAAUA,EAAO,QAAUpG,EAAM,OAC1B,OAAAoG,EACA,GAAA,KAAK,qBAAqBpG,CAAK,EAC/B,OAAAA,EAAM,IAAI,MAAS,EAGR2F,GAAA,IAAIO,EAAQC,EAAM,CAAC,EACnC,MAAAZ,EAAW,KAAK,OAAOvF,CAAK,EAEzB,OAAAoG,EAAAV,GAAK,IAAI,KAAK,EAAE,EAErBU,GAAUA,EAAO,OAASb,EAAS,OACnCA,EAAS,OAASa,EAAO,OACjBA,GACHV,GAAA,IAAI,KAAK,GAAIH,CAAQ,EAGvBA,CAAA,EAEX,OAAO,IAAIC,EACPS,EACA9S,EAAoB,UAAW,IAAI,CAAA,CAE3C,CAEA,YAAgB,CACN,MAAAkT,EAAarG,GAA0B,CACzC,IAAIoG,EAASV,GAAK,IAAI,KAAK,EAAE,EAC7B,GAAIU,EACO,OAAAA,EACA,GAAA,KAAK,qBAAqBpG,CAAK,EAC/B,OAAAA,EAAM,IAAI,MAAS,EAGxB,MAAAuF,EAAW,KAAK,OAAOvF,CAAK,EAEzB,OAAAoG,EAAAV,GAAK,IAAI,KAAK,EAAE,EACpBU,GACIV,GAAA,IAAI,KAAK,GAAIH,CAAQ,EAEvBA,CAAA,EAGX,OAAO,IAAIC,EACPa,EACAlT,EAAoB,YAAa,IAAI,CAAA,CAE7C,CAEA,KAAQ8L,EAAqB,CACrB,GAAAqH,GAAgB,KAAMrH,CAAI,EAC1B,OAAOsH,GAAoB,CAAC,KAAMtH,CAAI,EAAG,GAAKuH,GAAM,CAACA,GAAA,YAAAA,EAAI,GAAIA,GAAA,YAAAA,EAAI,EAAE,CAAC,EAGlE,MAAAC,EAAQzG,GAA0B,CAC9B,MAAA0G,EAAa,KAAK,OAAO1G,CAAK,EAEhC,GAAA,CAAC0G,EAAW,QAAS,CACf,MAAAC,EAAa1H,EAAK,OAAOyH,CAAU,EACrC,GAAA,CAACC,EAAW,QACZ,OAAOA,EAAW,GAAG,CAACD,EAAW,MAAOC,EAAW,KAAK,CAAC,CAEjE,CACA,OAAAd,EAAgB7F,CAAK,EACdA,EAAM,IAAI,MAAS,CAAA,EAG9B,OAAO,IAAIwF,EACPiB,EACAtT,EAAoB,OAAQ,KAAM,KAAM8L,CAAI,CAAA,CAEpD,CAEA,GAAM2H,EAAsB,CACpB,GAAAN,GAAgB,KAAMM,CAAK,EAC3B,OAAOL,GAAoB,CAAC,KAAMK,CAAK,EAAG,GAAG,EAG3C,MAAAC,EAAM7G,GAA0B,CAC5B,MAAAuF,EAAW,KAAK,OAAOvF,CAAK,EAE9B,OAACuF,EAAS,QAGPqB,EAAM,OAAO5G,CAAK,EAFduF,CAEc,EAG7B,OAAO,IAAIC,EACPqB,EACA1T,EAAoB,KAAM,KAAM,KAAMyT,CAAK,CAAA,CAEnD,CAEA,MAAStS,EAAiCwS,EAAsB,GAAO,CAC7D,MAAAC,EAAS/G,GAA0B,CAC/B,MAAAuF,EAAW,KAAK,OAAOvF,CAAK,EAElC,OAAIuF,EAAS,QACFA,EACAA,EAAS,OAASuB,EAClBxS,EAAGiR,EAAS,KAAK,EAAE,OAAOA,CAAQ,EAEtCvF,CAAA,EAGX,OAAO,IAAIwF,EAAOuB,EAAO5T,EAAoB,QAAS,KAAMmB,CAAE,CAAC,CACnE,CAEA,IAAOA,EAAqB0S,EAAoB,GAAO,CAC7C,MAAAC,EAAOjH,GAA8B,CACjC,MAAAuF,EAAW,KAAK,OAAOvF,CAAuB,EAEhD,MAAA,CAACuF,EAAS,SAAWyB,EACdzB,EAAS,GAAGjR,EAAGiR,EAAS,KAAK,CAAC,EAElCA,CAAA,EAGX,OAAO,IAAIC,EAAOyB,EAA0B9T,EAAoB,MAAO,IAAI,CAAC,CAChF,CAEA,SAAsBmB,EAA+C,CAC3D,MAAA4S,EAAYlH,GAA0B,CAClC,MAAAuF,EAAW,KAAK,OAAOvF,CAAK,EAClC,OAAO1L,EAAGiR,CAAQ,CAAA,EAGtB,OAAO,IAAIC,EACP0B,EACA/T,EAAoB,WAAY,IAAI,CAAA,CAE5C,CAEA,KAAQE,EAAuB,CACrB,MAAA4Q,EAAQjE,GAA0B,CAC9B,MAAA0G,EAAa,KAAK,OAAO1G,CAAK,EAChC,IAAA2G,EAEA,MAAA,CAACD,EAAW,UACCC,EAAAtT,EAAO,OAAOqT,CAAU,EACjC,CAACC,EAAW,SACLA,EAAW,GAAGD,EAAW,KAAK,GAG7Cb,EAAgB7F,CAAK,EACdA,EAAM,IAAI,MAAS,EAAA,EAE9B,OAAO,IAAIwF,EACPvB,EACA9Q,EAAoB,OAAQ,KAAME,CAAM,CAAA,CAEhD,CAEA,KAAQA,EAAmB,CACjB,MAAA4L,EAAO,KAAK,KAAK5L,CAAM,EAAE,IAAI,CAAC,CAAG,CAAAgQ,CAAC,IAC7BA,CACV,EACD,OAAApE,EAAK,QAAU9L,EAAoB,OAAQ,KAAME,CAAM,EAChD4L,CACX,CAEA,KAAM,CACI,MAAAkI,EAAOnH,GAA0B,CAC7B,MAAAuF,EAAW,KAAK,OAAOvF,CAAK,EAClC,OAAIuF,EAAS,SACTM,EAAgB7F,CAAK,EACdA,EAAM,GAAG,MAAS,GAEtBuF,CAAA,EAEX,OAAO,IAAIC,EAAO2B,EAA0BhU,EAAoB,MAAO,IAAI,CAAC,CAChF,CAEA,IAAOE,EAAoB,CACjB,MAAA+T,EAAUpH,GACK,KAAK,OAAOA,CAAK,EAErB,SACT6F,EAAgB7F,CAAK,EACdA,EAAM,GAAGA,EAAM,KAAK,GAEpBA,EAAM,IAAI,MAAS,EAI5BqH,EAAOrH,GAA0B,CAC7B,MAAAuF,EAAW,KAAK,OAAOvF,CAAK,EAElC,OAAIuF,EAAS,SACTM,EAAgB7F,CAAK,EACduF,GAEWlS,EAAO,OAAO2M,CAAK,EACvB,QACHuF,GAEPM,EAAgB7F,CAAK,EACdA,EAAM,IAAI,MAAS,EAElC,EAGJ,OAAO,IAAIwF,EACPnS,EAASgU,EAAMD,EACfjU,EAAoB,MAAO,KAAME,CAAM,CAAA,CAE/C,CAEA,KAAWiU,EAAkBC,EAAgBC,EAAmB,GAAM,CAClE,GAAI,CAACA,EACM,OAAA7S,GAAI2S,EAAO,KAAMC,CAAG,EAG/B,GAAIjB,GAAgBgB,EAAO,KAAMC,CAAG,EACzB,OAAAE,GAAkBH,EAAO,KAAMC,CAAG,EAE7C,MAAMG,EAAOJ,EAAM,KAAK,IAAI,EAAE,KAAKC,CAAG,EACtC,OAAAG,EAAK,QAAUvU,EAAoB,OAAQ,KAAMmU,EAAOC,CAAG,EACpDG,CACX,CAEA,KAAKrU,EAAoB8M,GAAyBqH,EAAmB,GAAM,OACvE,GAAI,CAACA,EACM,OAAA7S,GAAItB,EAAQ,KAAMA,CAAM,EAG/B,KAAAsU,EAAAtU,EAAO,UAAP,YAAAsU,EAAgB,QAAS,aAAc,CACnC,GAAArB,GAAgB,KAAMjT,CAAM,EACrB,OAAAkT,GACH,CAAClT,EAAQ,KAAMA,CAAM,EACrB,GACCmT,GAAMA,GAAA,YAAAA,EAAI,EAAC,EAId,MAAAoB,EAAkB5H,GAA0B,CACxC,MAAAuF,EAAWsC,GAAoB7H,CAAK,EACpC8H,EAAW,KAAK,OAAOvC,CAAQ,EAErC,OAAIuC,EAAS,SACTjC,EAAgB7F,CAAK,EACdA,EAAM,IAAI,MAAS,GAEnB6H,GAAoBC,CAAQ,CACvC,EAGJ,OAAO,IAAItC,EACPoC,EACAzU,EAAoB,iBAAkB,IAAI,CAAA,CAElD,CAEO,OAAA,KAAK,KAAKE,EAAQA,CAAM,CACnC,CAEA,KAAK+Q,EAAc,EAAGC,EAAc,IAAU,CACpC,MAAA0D,EAAQ/H,GAA0B,CACpC,MAAMgI,EAAe,CAAA,EACrB,IAAIzC,EAAWvF,EAEf,QAASvI,EAAI,EAAGA,EAAI4M,EAAK5M,GAAK,EAAG,CACvB,MAAAqQ,EAAW,KAAK,OAAOvC,CAAQ,EAErC,GAAIuC,EAAS,QACT,MAEIE,EAAA,KAAKF,EAAS,KAAK,EAChBvC,EAAAuC,CACf,CAEI,OAAAE,EAAQ,QAAU5D,EACXmB,EAAS,GAAGyC,CAAO,GAE9BnC,EAAgB7F,CAAK,EACdA,EAAM,IAAI,CAAA,CAAE,EAAA,EAGvB,OAAO,IAAIwF,EACPuC,EACA5U,EAAoB,OAAQ,KAAMiR,EAAKC,CAAG,CAAA,CAElD,CAEA,MAAS9M,EAAoB6M,EAAc,EAAGC,EAAc,IAAU,CAC5D,MAAA4D,EAASjI,GAA0B,CACrC,MAAMgI,EAAe,CAAA,EAErB,IAAIzC,EAAWvF,EAEf,QAASvI,EAAI,EAAGA,EAAI4M,EAAK5M,GAAK,EAAG,CACvB,MAAAqQ,EAAW,KAAK,OAAOvC,CAAQ,EACrC,GAAIuC,EAAS,QACT,MAEOvC,EAAAuC,EACHE,EAAA,KAAKzC,EAAS,KAAK,EAErB,MAAA2C,EAAW3Q,EAAI,OAAOgO,CAAQ,EACpC,GAAI2C,EAAS,QACT,MAEO3C,EAAA2C,CACf,CAEI,OAAAF,EAAQ,OAAS5D,EACVmB,EAAS,GAAGyC,CAAO,GAE9BnC,EAAgB7F,CAAK,EACdA,EAAM,IAAI,CAAA,CAAE,EAAA,EAGvB,OAAO,IAAIwF,EACPyC,EACA9U,EAAoB,QAAS,KAAMoE,CAAG,CAAA,CAE9C,CAEA,KAAM,CACF,MAAMiN,EAAI,KAAK,KAAK2D,GAAK,CAAA,EACvB,OAAA3D,EAAA,QAAUrR,EAAoB,MAAO,IAAI,EACpCqR,CACX,CAEA,MACIpR,EAAe,GACfgS,EAA0B,GAC1BC,EAAgC,QAAQ,IAC1C,CACE,OAAOF,GAAY,KAAM/R,EAAMgS,EAAgBC,CAAM,CACzD,CAEA,UAAW,CACP,OAAO5B,GAAY,IAAI,CAC3B,CAEA,OAAO,KAAQnP,EAAqB,CAC1BiQ,MAAAA,EAAQvE,GACHyE,GAAcnQ,CAAE,EAAE,OAAO0L,CAAK,EAEzC,OAAO,IAAIwF,EAAUjB,EAAMpR,EAAoB,OAAQ,OAAWmB,CAAE,CAAC,CACzE,CACJ,CAEA,SAASgS,MAAmB8B,EAAwB,CAChD,OAAOA,EAAQ,MACV5D,GAAA,aACI,SAAAmD,EAAAnD,EAAE,UAAF,YAAAmD,EAAW,QAAS,YACjBU,EAAA7D,EAAE,UAAF,YAAA6D,EAAW,QAAS,WACpBC,EAAA9D,EAAE,UAAF,YAAA8D,EAAW,QAAS,iBACxBC,EAAA/D,EAAE,UAAF,YAAA+D,EAAW,MAAA,CAEvB,CAEA,SAASC,GAAkBhE,EAAgB,eACnC,KAAAmD,EAAAnD,EAAE,UAAF,YAAAmD,EAAW,QAAS,SACpB,OAAOU,EAAA7D,EAAE,UAAF,YAAA6D,EAAW,KAAK,GAAG,QAAQ,yBAA0B,QAChE,KAAWC,EAAA9D,EAAE,UAAF,YAAA8D,EAAW,QAAS,WAAWC,EAAA/D,EAAE,UAAF,YAAA+D,EAAW,QAAS,aAC1D,OAAOE,EAAAjE,EAAE,UAAF,YAAAiE,EAAW,KAAK,GAAG,MAElC,CAEA,SAASlC,GACL6B,EACAlE,EAAgB,GAChBwE,EACc,CACR,MAAA,EAAIN,EAAQ,IAAKtE,GAAM,IAAI0E,GAAkB1E,CAAC,IAAI,EAAE,KAAKI,CAAK,EAC9DyE,EAAI,IAAI,OAAO,CAAC,EAChBC,EAAKpQ,GAAMmQ,EAAGD,CAAa,EAEjC,OAAIxE,IAAU,MACV0E,EAAG,QAAUzV,EAAoB,cAAe,KAAMwV,CAAC,GAEpDC,CACX,CAEA,SAASnB,GACL1D,EACAS,EACAR,EACc,CACR,MAAA4E,EAAKrC,GAAoB,CAACxC,EAAMS,EAAGR,CAAK,EAAG,GAAKwC,GAC3CA,GAAA,YAAAA,EAAI,EACd,EACD,OAAAoC,EAAG,QAAQ,KAAO,YACXA,CACX,CAEO,SAAST,IAAS,CACfA,MAAAA,EAAOnI,GACLA,EAAM,QAAUA,EAAM,IAAI,OACnBA,EAAM,GAAG,MAAS,EAElBA,EAAM,MAGrB,OAAO,IAAIwF,EAAO2C,EAAKhV,EAAoB,MAAO,MAAS,CAAC,CAChE,CAEgB,SAAAoR,GACZ7P,EACAmU,EACAC,EACF,CACE,MAAMC,EAASD,EAAW,MAAM,KAAKpU,CAAM,EAE3CoU,EAAW,MAAQ,UAAY,CACrBvE,MAAAA,EAAQvE,GACHyE,GAAcsE,CAAM,EAAE,OAAO/I,CAAK,EAE7C,OAAO,IAAIwF,EAAUjB,EAAMpR,EAAoB,OAAQ,OAAW4V,CAAM,CAAC,CAAA,CAEjF,CAEO,SAASC,MAAwBZ,EAAY,CAC5C,GAAA9B,GAAgB,GAAG8B,CAAO,EACnB,OAAA7B,GAAoB6B,EAAS,GAAG,EAGrCY,MAAAA,EAAOhJ,GAA0B,CACnC,UAAW3M,KAAU+U,EAAS,CACpB,MAAA7C,EAAWlS,EAAO,OAAO2M,CAAK,EAChC,GAAA,CAACuF,EAAS,QACH,OAAAA,CAEf,CACA,OAAAM,EAAgB7F,CAAK,EACdA,EAAM,IAAI,MAAS,CAAA,EAG9B,OAAO,IAAIwF,EACP4C,EAAQ,SAAW,EAAIA,EAAQ,CAAC,EAAE,OAASY,EAC3C7V,EAAoB,MAAO,OAAW,GAAGiV,CAAO,CAAA,CAExD,CAEO,SAASzT,MAAwByT,EAAY,CAC1CzT,MAAAA,EAAOqL,GAAsE,CAC/E,MAAMgI,EAAU,CAAA,EAEhB,UAAW3U,KAAU+U,EAAS,CACpB,MAAA7C,EAAWlS,EAAO,OAAO2M,CAAK,EAEpC,GAAIuF,EAAS,QACF,OAAAA,EAIPA,EAAS,QAAU,QACXyC,EAAA,KAAKzC,EAAS,KAAK,EAEvBvF,EAAAuF,CACZ,CACA,OAAAM,EAAgB7F,CAAK,EACdA,EAAM,GAAGgI,CAAO,CAAA,EAG3B,OAAO,IAAIxC,EACP4C,EAAQ,SAAW,EAAIA,EAAQ,CAAC,EAAE,OAASzT,EAC3CxB,EAAoB,MAAO,OAAW,GAAGiV,CAAO,CAAA,CAExD,CAEO,SAASlP,GAAO+P,EAAa,CAC1B/P,MAAAA,EAAU8G,GAA+B,CAC3C,GAAIA,EAAM,QAAUA,EAAM,IAAI,OACnB,OAAAA,EAAM,IAAI,MAAS,EAExB,MAAA,EAAIA,EAAM,IAAI,MAAMA,EAAM,OAAQA,EAAM,OAASiJ,EAAI,MAAM,EACjE,OAAI,IAAMA,EACCjJ,EAAM,GAAG,EAAG,EAAE,MAAM,GAE/B6F,EAAgB7F,CAAK,EACdA,EAAM,IAAI,MAAS,EAAA,EAG9B,OAAO,IAAIwF,EACPtM,EACA/F,EAAoB,SAAU,OAAW8V,CAAG,CAAA,CAEpD,CAEO,SAASzQ,GACZmQ,EACAD,EAAmDlC,GAAMA,GAAA,YAAAA,EAAI,GAC/D,CACE,MAAM0C,EAAQP,EAAE,MAAM,QAAQ,KAAM,EAAE,EAChCQ,EAAS,IAAI,OAAOR,EAAGO,EAAQ,GAAG,EAElC1Q,EAASwH,GAA+B,CAC1C,GAAIA,EAAM,QAAUA,EAAM,IAAI,OACnB,OAAAA,EAAM,IAAI,MAAS,EAG9BmJ,EAAO,UAAYnJ,EAAM,OACzB,MAAMoJ,EAAQV,EAAc1I,EAAM,IAAI,MAAMmJ,CAAM,CAAC,EAEnD,OAAIC,EACOpJ,EAAM,GAAGoJ,EAAOD,EAAO,UAAYnJ,EAAM,MAAM,EAC/CoJ,IAAU,GACVpJ,EAAM,GAAG,MAAS,GAE7B6F,EAAgB7F,CAAK,EACdA,EAAM,IAAI,MAAS,EAAA,EAG9B,OAAO,IAAIwF,EACPhN,EACArF,EAAoB,QAAS,OAAWwV,CAAC,CAAA,CAEjD,CAEA,MAAMU,GAAa,OACbxB,GAA0B7H,GAA0B,OACtD,GAAIA,EAAM,QAAUA,EAAM,IAAI,OACnB,OAAAA,EAGXqJ,GAAW,UAAYrJ,EAAM,OAC7B,MAAMoJ,IAAQzB,EAAA3H,EAAM,IAAI,MAAMqJ,EAAU,IAA1B,YAAA1B,EAA8B,KAAM,GAClD,OAAO3H,EAAM,GAAGA,EAAM,MAAOoJ,EAAM,MAAM,CAC7C,EAEajJ,GAAa3H,GAAM,KAAK,EACrC2H,GAAW,QAAQ,KAAO"}