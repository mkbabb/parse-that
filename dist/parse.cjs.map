{"version":3,"file":"parse.cjs","sources":["../src/parse/state.ts","../src/parse/index.ts"],"sourcesContent":["import { Parser } from \".\";\n\nexport class ParserState<T> {\n    constructor(\n        public src: string,\n        public value: T = undefined,\n        public offset: number = 0,\n        public isError: boolean = false\n    ) {}\n\n    ok<S>(value: S, offset: number = 0) {\n        return new ParserState<S>(this.src, value, this.offset + offset);\n    }\n\n    err<S>(value?: S, offset: number = 0) {\n        const nextState = this.ok(value, offset);\n        nextState.isError = true;\n        return nextState;\n    }\n\n    from<S>(value: S, offset: number = 0) {\n        return new ParserState<S>(this.src, value, this.offset + offset, this.isError);\n    }\n\n    getColumnNumber(): number {\n        const offset = this.offset;\n        const lastNewline = this.src.lastIndexOf(\"\\n\", offset);\n        const columnNumber = lastNewline === -1 ? offset : offset - (lastNewline + 1);\n\n        return Math.max(0, columnNumber);\n    }\n\n    getLineNumber(): number {\n        const lines = this.src.slice(0, this.offset).split(\"\\n\");\n        const lineNumber = lines.length - 1;\n        return Math.max(0, lineNumber);\n    }\n}\n\nexport const parserNames = [\n    \"string\",\n    \"regex\",\n    \"then\",\n    \"or\",\n    \"chain\",\n    \"map\",\n    \"many\",\n    \"lazy\",\n    \"memoize\",\n    \"mergeMemo\",\n    \"not\",\n    \"skip\",\n    \"next\",\n    \"trim\",\n    \"trimWhitespace\",\n    \"whitespace\",\n    \"wrap\",\n    \"sepBy\",\n    \"any\",\n    \"all\",\n    \"opt\",\n    \"lookAhead\",\n    \"lookBehind\",\n    \"eof\",\n    \"regexConcat\",\n    \"regexWrap\",\n    \"debug\",\n] as const;\n\nexport type ParserContext<T = any> = {\n    name?: (typeof parserNames)[number];\n    parser?: Parser<T>;\n    args?: any[];\n};\n\n// TODO: maybe reintroduce debug check.\nexport function createParserContext<T = any>(\n    name: (typeof parserNames)[number],\n    parser: Parser<T>,\n    ...args: any[]\n) {\n    return {\n        name,\n        parser,\n        args,\n    };\n}\n","import { createParserContext, ParserContext, ParserState } from \"./state\";\n\ntype ExtractValue<T extends ReadonlyArray<Parser<any>>> = {\n    [K in keyof T]: T[K] extends Parser<infer V> ? V : never;\n};\n\ntype ParserFunction<T = string> = (val: ParserState<T>) => ParserState<T>;\n\nlet PARSER_ID = 0;\n\nconst MEMO = new Map<number, ParserState<any>>();\nconst LEFT_RECURSION_COUNTS = new Map<string, number>();\n\nexport function getLazyParser<T>(fn: () => Parser<T>) {\n    if (fn.parser) {\n        return fn.parser;\n    }\n    return (fn.parser = fn());\n}\n\nexport class Parser<T = string> {\n    id: number = PARSER_ID++;\n    constructor(public parser: ParserFunction<T>, public context: ParserContext = {}) {}\n\n    parse(val: string) {\n        MEMO.clear();\n        LEFT_RECURSION_COUNTS.clear();\n        return this.parser(new ParserState(val)).value as T;\n    }\n\n    getCijKey(state: ParserState<T>) {\n        return `${this.id}${state.offset}`;\n    }\n\n    atLeftRecursionLimit(state: ParserState<T>) {\n        const cij = LEFT_RECURSION_COUNTS.get(this.getCijKey(state)) ?? 0;\n        return cij > state.src.length - state.offset;\n    }\n\n    memoize() {\n        const memoize = (state: ParserState<T>) => {\n            const cijKey = this.getCijKey(state);\n            const cij = LEFT_RECURSION_COUNTS.get(cijKey) ?? 0;\n\n            let cached = MEMO.get(this.id);\n\n            if (cached && cached.offset >= state.offset) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            LEFT_RECURSION_COUNTS.set(cijKey, cij + 1);\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n\n            if (cached && cached.offset > newState.offset) {\n                newState.offset = cached.offset;\n            } else if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n\n            return newState;\n        };\n        return new Parser(\n            memoize as ParserFunction<T>,\n            createParserContext(\"memoize\", this)\n        );\n    }\n\n    mergeMemos<S>() {\n        const mergeMemo = (state: ParserState<T>) => {\n            let cached = MEMO.get(this.id);\n            if (cached) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n            if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n            return newState;\n        };\n\n        return new Parser(\n            mergeMemo as ParserFunction<[T, S]>,\n            createParserContext(\"mergeMemo\", this)\n        );\n    }\n\n    then<S>(next: Parser<S | T>) {\n        if (isStringParsers(this, next)) {\n            return concatStringParsers([this, next], \"\", (m) => [m?.[0], m?.[1]]);\n        }\n\n        const then = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = next.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok([nextState1.value, nextState2.value]);\n                }\n            }\n            return state.err(undefined);\n        };\n\n        return new Parser(\n            then as ParserFunction<[T, S]>,\n            createParserContext(\"then\", this, this, next)\n        );\n    }\n\n    or<S>(other: Parser<S | T>) {\n        if (isStringParsers(this, other)) {\n            return concatStringParsers([this, other], \"|\");\n        }\n\n        const or = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (!newState.isError) {\n                return newState;\n            }\n            return other.parser(state);\n        };\n\n        return new Parser(\n            or as ParserFunction<T | S>,\n            createParserContext(\"or\", this, this, other)\n        );\n    }\n\n    chain<S>(fn: (value: T) => Parser<S | T>, chainError: boolean = false) {\n        const chain = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            } else if (newState.value || chainError) {\n                return fn(newState.value).parser(newState);\n            }\n            return state;\n        };\n\n        return new Parser(chain, createParserContext(\"chain\", this, fn));\n    }\n\n    map<S>(fn: (value: T) => S, mapError: boolean = false) {\n        const map = (state: ParserState<T | S>) => {\n            const newState = this.parser(state as ParserState<T>);\n\n            if (!newState.isError || mapError) {\n                return newState.ok(fn(newState.value));\n            }\n            return newState;\n        };\n\n        return new Parser(map as ParserFunction<S>, createParserContext(\"map\", this));\n    }\n\n    mapState<S>(fn: (state: ParserState<T>) => ParserState<S>) {\n        const mapState = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            return fn(newState);\n        };\n\n        return new Parser(\n            mapState as ParserFunction<S>,\n            createParserContext(\"mapState\", this)\n        );\n    }\n\n    skip<S>(parser: Parser<T | S>) {\n        const skip = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = parser.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok(nextState1.value);\n                }\n            }\n            return state.err(undefined);\n        };\n        return new Parser(\n            skip as ParserFunction<T>,\n            createParserContext(\"skip\", this, parser)\n        );\n    }\n\n    next<S>(parser: Parser<S>) {\n        const next = this.then(parser).map(([, b]) => {\n            return b;\n        }) as Parser<S>;\n        next.context = createParserContext(\"next\", this, parser);\n        return next;\n    }\n\n    opt() {\n        const opt = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            if (newState.isError) {\n                return state.ok(undefined);\n            }\n            return newState;\n        };\n        return new Parser(opt as ParserFunction<T>, createParserContext(\"opt\", this));\n    }\n\n    not<S>(parser?: Parser<S>) {\n        const negate = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return state.ok(state.value);\n            } else {\n                return state.err(undefined);\n            }\n        };\n\n        const not = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            } else {\n                const nextState = parser.parser(state);\n                if (nextState.isError) {\n                    return newState;\n                } else {\n                    return state.err(undefined);\n                }\n            }\n        };\n\n        return new Parser(\n            parser ? not : negate,\n            createParserContext(\"not\", this, parser)\n        );\n    }\n\n    wrap<L, R>(start: Parser<L>, end: Parser<R>) {\n        if (isStringParsers(start, this, end)) {\n            return wrapStringParsers(start, this, end);\n        }\n        const wrap = start.next(this).skip(end) as Parser<T>;\n        wrap.context = createParserContext(\"wrap\", this, start, end);\n        return wrap;\n    }\n\n    trim(parser: Parser<T> = whitespace as Parser<T>): Parser<T> {\n        if (parser.context?.name === \"whitespace\") {\n            if (isStringParsers(this, parser)) {\n                return concatStringParsers(\n                    [parser, this, parser],\n                    \"\",\n                    (m) => m?.[2]\n                ) as Parser<T>;\n            }\n\n            const whitespaceTrim = (state: ParserState<T>) => {\n                const newState = trimStateWhitespace(state);\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    return state.err(undefined);\n                } else {\n                    return trimStateWhitespace(tmpState);\n                }\n            };\n\n            return new Parser(\n                whitespaceTrim as ParserFunction<T>,\n                createParserContext(\"trimWhitespace\", this)\n            );\n        }\n\n        return this.wrap(parser, parser) as Parser<T>;\n    }\n\n    many(min: number = 0, max: number = Infinity) {\n        const many = (state: ParserState<T>) => {\n            const matches: T[] = [];\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    break;\n                }\n                matches.push(tmpState.value);\n                newState = tmpState;\n            }\n\n            if (matches.length >= min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            } else {\n                return state.err([]) as ParserState<T[]>;\n            }\n        };\n\n        return new Parser(\n            many as ParserFunction<T[]>,\n            createParserContext(\"many\", this, min, max)\n        );\n    }\n\n    sepBy<S>(sep: Parser<S | T>, min: number = 0, max: number = Infinity) {\n        const sepBy = (state: ParserState<T>) => {\n            const matches: T[] = [];\n\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n                if (tmpState.isError) {\n                    break;\n                }\n                newState = tmpState;\n                matches.push(newState.value);\n\n                const sepState = sep.parser(newState);\n                if (sepState.isError) {\n                    break;\n                }\n                newState = sepState as ParserState<T>;\n            }\n\n            if (matches.length > min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            sepBy as ParserFunction<T[]>,\n            createParserContext(\"sepBy\", this, sep)\n        );\n    }\n\n    eof() {\n        const p = this.skip(eof()) as Parser<T>;\n        p.context = createParserContext(\"eof\", this);\n        return p;\n    }\n\n    toString() {\n        return this.context?.name;\n    }\n\n    static lazy<T>(fn: () => Parser<T>) {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(fn).parser(state);\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, fn));\n    }\n}\n\nfunction isStringParsers(...parsers: Parser<any>[]) {\n    return parsers.every(\n        (p) =>\n            (p.context?.name === \"string\" ||\n                p.context?.name === \"regex\" ||\n                p.context?.name === \"whitespace\") &&\n            p.context?.args\n    );\n}\n\nfunction stringParserValue(p: Parser<any>) {\n    if (p.context?.name === \"string\") {\n        return p.context?.args[0].replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    } else if (p.context?.name === \"regex\" || p.context?.name === \"whitespace\") {\n        return p.context?.args[0].source;\n    }\n}\n\nfunction concatStringParsers(\n    parsers: Parser<any>[],\n    delim: string = \"\",\n    matchFunction?: (m: RegExpMatchArray) => any\n): Parser<string> {\n    const s = parsers.map((s) => `(${stringParserValue(s)})`).join(delim);\n    const r = new RegExp(s);\n    const rP = regex(r, matchFunction);\n\n    if (delim !== \"|\") {\n        rP.context = createParserContext(\"regexConcat\", this, r);\n    }\n    return rP;\n}\n\nfunction wrapStringParsers<L, T, R>(\n    left: Parser<L>,\n    p: Parser<T>,\n    right: Parser<R>\n): Parser<string> {\n    const rP = concatStringParsers([left, p, right], \"\", (m) => {\n        return m?.[2];\n    });\n    rP.context.name = \"regexWrap\";\n    return rP;\n}\n\nexport function eof<T>() {\n    const eof = (state: ParserState<T>) => {\n        if (state.offset >= state.src.length) {\n            return state.ok(undefined);\n        } else {\n            return state.err();\n        }\n    };\n    return new Parser(eof, createParserContext(\"eof\")) as Parser<any>;\n}\n\nexport function lazy<T>(\n    target: any,\n    propertyName: string,\n    descriptor: TypedPropertyDescriptor<() => Parser<T>>\n) {\n    const method = descriptor.value.bind(target)!;\n\n    descriptor.value = function () {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(method).parser(state) as ParserState<T>;\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, method));\n    };\n}\n\nexport function any<T extends any[]>(...parsers: T) {\n    if (isStringParsers(...parsers)) {\n        return concatStringParsers(parsers, \"|\") as Parser<ExtractValue<T>[number]>;\n    }\n\n    const any = (state: ParserState<T>) => {\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n            if (!newState.isError) {\n                return newState;\n            }\n        }\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : any,\n        createParserContext(\"any\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>[number]>;\n}\n\nexport function all<T extends any[]>(...parsers: T) {\n    const all = (state: ParserState<ExtractValue<T>>): ParserState<ExtractValue<T>> => {\n        const matches = [] as any;\n\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            }\n            if (newState.value !== undefined) {\n                matches.push(newState.value);\n            }\n\n            state = newState;\n        }\n        return state.ok(matches);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : all,\n        createParserContext(\"all\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>>;\n}\n\nexport function string(str: string) {\n    const string = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n        const s = state.src.slice(state.offset, state.offset + str.length);\n        if (s === str) {\n            return state.ok(s, s.length);\n        }\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        string as ParserFunction<string>,\n        createParserContext(\"string\", undefined, str)\n    );\n}\n\nexport function regex(\n    r: RegExp,\n    matchFunction: (match: RegExpMatchArray) => any = (m) => m?.[0]\n) {\n    const flags = r.flags.replace(/y/g, \"\");\n    const sticky = new RegExp(r, flags + \"y\");\n\n    const regex = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n\n        sticky.lastIndex = state.offset;\n        const match = matchFunction(state.src.match(sticky));\n\n        if (match) {\n            return state.ok(match, sticky.lastIndex - state.offset);\n        } else if (match === \"\") {\n            return state.ok(undefined);\n        }\n\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        regex as ParserFunction<string>,\n        createParserContext(\"regex\", undefined, r)\n    );\n}\n\nconst WHITESPACE = /\\s*/y;\nconst trimStateWhitespace = <T>(state: ParserState<T>) => {\n    if (state.offset >= state.src.length) {\n        return state;\n    }\n\n    WHITESPACE.lastIndex = state.offset;\n    const match = state.src.match(WHITESPACE)?.[0] ?? \"\";\n    return state.ok(state.value, match.length);\n};\n\nexport const whitespace = regex(/\\s*/);\nwhitespace.context.name = \"whitespace\";\n"],"names":["ParserState","src","value","offset","isError","nextState","lastNewline","columnNumber","lineNumber","createParserContext","name","parser","args","PARSER_ID","MEMO","LEFT_RECURSION_COUNTS","getLazyParser","fn","Parser","context","__publicField","val","state","memoize","cijKey","cij","cached","newState","mergeMemo","next","isStringParsers","concatStringParsers","m","then","nextState1","nextState2","other","or","chainError","chain","mapError","map","mapState","skip","b","opt","negate","not","start","end","wrapStringParsers","wrap","whitespace","_a","whitespaceTrim","trimStateWhitespace","tmpState","min","max","many","matches","i","sep","sepBy","sepState","p","eof","lazy","parsers","_b","_c","_d","stringParserValue","_e","delim","matchFunction","s","r","rP","regex","left","right","target","propertyName","descriptor","method","any","all","string","str","flags","sticky","match","WHITESPACE"],"mappings":"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"}