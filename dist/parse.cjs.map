{"version":3,"file":"parse.cjs","sources":["../node_modules/prettier/doc.js","../src/parse/debug.ts","../src/parse/state.ts","../src/parse/index.ts"],"sourcesContent":["(function (factory) {\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    module.exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else {\n    var root =\n      typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof self !== \"undefined\"\n        ? self\n        : this || {};\n    root.doc = factory();\n  }\n})(function() {\n  \"use strict\";\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\n  // dist/_doc.js.umd.js\n  var require_doc_js_umd = __commonJS({\n    \"dist/_doc.js.umd.js\"(exports, module) {\n      var __create = Object.create;\n      var __defProp = Object.defineProperty;\n      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n      var __getOwnPropNames2 = Object.getOwnPropertyNames;\n      var __getProtoOf = Object.getPrototypeOf;\n      var __hasOwnProp = Object.prototype.hasOwnProperty;\n      var __esm = (fn, res) => function __init() {\n        return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;\n      };\n      var __commonJS2 = (cb, mod) => function __require() {\n        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {\n          exports: {}\n        }).exports, mod), mod.exports;\n      };\n      var __export = (target, all) => {\n        for (var name in all)\n          __defProp(target, name, {\n            get: all[name],\n            enumerable: true\n          });\n      };\n      var __copyProps = (to, from, except, desc) => {\n        if (from && typeof from === \"object\" || typeof from === \"function\") {\n          for (let key of __getOwnPropNames2(from))\n            if (!__hasOwnProp.call(to, key) && key !== except)\n              __defProp(to, key, {\n                get: () => from[key],\n                enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n              });\n        }\n        return to;\n      };\n      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n      }) : target, mod));\n      var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", {\n        value: true\n      }), mod);\n      var init_define_process = __esm({\n        \"<define:process>\"() {\n        }\n      });\n      var require_doc_builders = __commonJS2({\n        \"src/document/doc-builders.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function concat(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"concat\",\n              parts\n            };\n          }\n          function indent(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"indent\",\n              contents\n            };\n          }\n          function align(widthOrString, contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"align\",\n              contents,\n              n: widthOrString\n            };\n          }\n          function group(contents) {\n            let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"group\",\n              id: opts.id,\n              contents,\n              break: Boolean(opts.shouldBreak),\n              expandedStates: opts.expandedStates\n            };\n          }\n          function dedentToRoot(contents) {\n            return align(Number.NEGATIVE_INFINITY, contents);\n          }\n          function markAsRoot(contents) {\n            return align({\n              type: \"root\"\n            }, contents);\n          }\n          function dedent(contents) {\n            return align(-1, contents);\n          }\n          function conditionalGroup(states, opts) {\n            return group(states[0], Object.assign(Object.assign({}, opts), {}, {\n              expandedStates: states\n            }));\n          }\n          function fill(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"fill\",\n              parts\n            };\n          }\n          function ifBreak(breakContents, flatContents) {\n            let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (false) {\n              if (breakContents) {\n                assertDoc(breakContents);\n              }\n              if (flatContents) {\n                assertDoc(flatContents);\n              }\n            }\n            return {\n              type: \"if-break\",\n              breakContents,\n              flatContents,\n              groupId: opts.groupId\n            };\n          }\n          function indentIfBreak(contents, opts) {\n            return {\n              type: \"indent-if-break\",\n              contents,\n              groupId: opts.groupId,\n              negate: opts.negate\n            };\n          }\n          function lineSuffix(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"line-suffix\",\n              contents\n            };\n          }\n          var lineSuffixBoundary = {\n            type: \"line-suffix-boundary\"\n          };\n          var breakParent = {\n            type: \"break-parent\"\n          };\n          var trim = {\n            type: \"trim\"\n          };\n          var hardlineWithoutBreakParent = {\n            type: \"line\",\n            hard: true\n          };\n          var literallineWithoutBreakParent = {\n            type: \"line\",\n            hard: true,\n            literal: true\n          };\n          var line = {\n            type: \"line\"\n          };\n          var softline = {\n            type: \"line\",\n            soft: true\n          };\n          var hardline = concat([hardlineWithoutBreakParent, breakParent]);\n          var literalline = concat([literallineWithoutBreakParent, breakParent]);\n          var cursor = {\n            type: \"cursor\",\n            placeholder: Symbol(\"cursor\")\n          };\n          function join(sep, arr) {\n            const res = [];\n            for (let i = 0; i < arr.length; i++) {\n              if (i !== 0) {\n                res.push(sep);\n              }\n              res.push(arr[i]);\n            }\n            return concat(res);\n          }\n          function addAlignmentToDoc(doc, size, tabWidth) {\n            let aligned = doc;\n            if (size > 0) {\n              for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n                aligned = indent(aligned);\n              }\n              aligned = align(size % tabWidth, aligned);\n              aligned = align(Number.NEGATIVE_INFINITY, aligned);\n            }\n            return aligned;\n          }\n          function label(label2, contents) {\n            return {\n              type: \"label\",\n              label: label2,\n              contents\n            };\n          }\n          module2.exports = {\n            concat,\n            join,\n            line,\n            softline,\n            hardline,\n            literalline,\n            group,\n            conditionalGroup,\n            fill,\n            lineSuffix,\n            lineSuffixBoundary,\n            cursor,\n            breakParent,\n            ifBreak,\n            trim,\n            indent,\n            indentIfBreak,\n            align,\n            addAlignmentToDoc,\n            markAsRoot,\n            dedentToRoot,\n            dedent,\n            hardlineWithoutBreakParent,\n            literallineWithoutBreakParent,\n            label\n          };\n        }\n      });\n      var require_end_of_line = __commonJS2({\n        \"src/common/end-of-line.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function guessEndOfLine(text) {\n            const index = text.indexOf(\"\\r\");\n            if (index >= 0) {\n              return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n            }\n            return \"lf\";\n          }\n          function convertEndOfLineToChars(value) {\n            switch (value) {\n              case \"cr\":\n                return \"\\r\";\n              case \"crlf\":\n                return \"\\r\\n\";\n              default:\n                return \"\\n\";\n            }\n          }\n          function countEndOfLineChars(text, eol) {\n            let regex;\n            switch (eol) {\n              case \"\\n\":\n                regex = /\\n/g;\n                break;\n              case \"\\r\":\n                regex = /\\r/g;\n                break;\n              case \"\\r\\n\":\n                regex = /\\r\\n/g;\n                break;\n              default:\n                throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);\n            }\n            const endOfLines = text.match(regex);\n            return endOfLines ? endOfLines.length : 0;\n          }\n          function normalizeEndOfLine(text) {\n            return text.replace(/\\r\\n?/g, \"\\n\");\n          }\n          module2.exports = {\n            guessEndOfLine,\n            convertEndOfLineToChars,\n            countEndOfLineChars,\n            normalizeEndOfLine\n          };\n        }\n      });\n      var require_get_last = __commonJS2({\n        \"src/utils/get-last.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = (arr) => arr[arr.length - 1];\n          module2.exports = getLast;\n        }\n      });\n      function ansiRegex() {\n        let {\n          onlyFirst = false\n        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const pattern = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n        return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n      }\n      var init_ansi_regex = __esm({\n        \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n          init_define_process();\n        }\n      });\n      function stripAnsi(string) {\n        if (typeof string !== \"string\") {\n          throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string}\\``);\n        }\n        return string.replace(ansiRegex(), \"\");\n      }\n      var init_strip_ansi = __esm({\n        \"node_modules/strip-ansi/index.js\"() {\n          init_define_process();\n          init_ansi_regex();\n        }\n      });\n      function isFullwidthCodePoint(codePoint) {\n        if (!Number.isInteger(codePoint)) {\n          return false;\n        }\n        return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);\n      }\n      var init_is_fullwidth_code_point = __esm({\n        \"node_modules/is-fullwidth-code-point/index.js\"() {\n          init_define_process();\n        }\n      });\n      var require_emoji_regex = __commonJS2({\n        \"node_modules/emoji-regex/index.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          module2.exports = function() {\n            return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n          };\n        }\n      });\n      var string_width_exports = {};\n      __export(string_width_exports, {\n        default: () => stringWidth\n      });\n      function stringWidth(string) {\n        if (typeof string !== \"string\" || string.length === 0) {\n          return 0;\n        }\n        string = stripAnsi(string);\n        if (string.length === 0) {\n          return 0;\n        }\n        string = string.replace((0, import_emoji_regex.default)(), \"  \");\n        let width = 0;\n        for (let index = 0; index < string.length; index++) {\n          const codePoint = string.codePointAt(index);\n          if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n            continue;\n          }\n          if (codePoint >= 768 && codePoint <= 879) {\n            continue;\n          }\n          if (codePoint > 65535) {\n            index++;\n          }\n          width += isFullwidthCodePoint(codePoint) ? 2 : 1;\n        }\n        return width;\n      }\n      var import_emoji_regex;\n      var init_string_width = __esm({\n        \"node_modules/string-width/index.js\"() {\n          init_define_process();\n          init_strip_ansi();\n          init_is_fullwidth_code_point();\n          import_emoji_regex = __toESM(require_emoji_regex());\n        }\n      });\n      var require_get_string_width = __commonJS2({\n        \"src/utils/get-string-width.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var stringWidth2 = (init_string_width(), __toCommonJS(string_width_exports)).default;\n          var notAsciiRegex = /[^\\x20-\\x7F]/;\n          function getStringWidth(text) {\n            if (!text) {\n              return 0;\n            }\n            if (!notAsciiRegex.test(text)) {\n              return text.length;\n            }\n            return stringWidth2(text);\n          }\n          module2.exports = getStringWidth;\n        }\n      });\n      var require_doc_utils = __commonJS2({\n        \"src/document/doc-utils.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = require_get_last();\n          var {\n            literalline,\n            join\n          } = require_doc_builders();\n          var isConcat = (doc) => Array.isArray(doc) || doc && doc.type === \"concat\";\n          var getDocParts = (doc) => {\n            if (Array.isArray(doc)) {\n              return doc;\n            }\n            if (doc.type !== \"concat\" && doc.type !== \"fill\") {\n              throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n            }\n            return doc.parts;\n          };\n          var traverseDocOnExitStackMarker = {};\n          function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n            const docsStack = [doc];\n            while (docsStack.length > 0) {\n              const doc2 = docsStack.pop();\n              if (doc2 === traverseDocOnExitStackMarker) {\n                onExit(docsStack.pop());\n                continue;\n              }\n              if (onExit) {\n                docsStack.push(doc2, traverseDocOnExitStackMarker);\n              }\n              if (!onEnter || onEnter(doc2) !== false) {\n                if (isConcat(doc2) || doc2.type === \"fill\") {\n                  const parts = getDocParts(doc2);\n                  for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n                    docsStack.push(parts[i]);\n                  }\n                } else if (doc2.type === \"if-break\") {\n                  if (doc2.flatContents) {\n                    docsStack.push(doc2.flatContents);\n                  }\n                  if (doc2.breakContents) {\n                    docsStack.push(doc2.breakContents);\n                  }\n                } else if (doc2.type === \"group\" && doc2.expandedStates) {\n                  if (shouldTraverseConditionalGroups) {\n                    for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n                      docsStack.push(doc2.expandedStates[i]);\n                    }\n                  } else {\n                    docsStack.push(doc2.contents);\n                  }\n                } else if (doc2.contents) {\n                  docsStack.push(doc2.contents);\n                }\n              }\n            }\n          }\n          function mapDoc(doc, cb) {\n            const mapped = /* @__PURE__ */ new Map();\n            return rec(doc);\n            function rec(doc2) {\n              if (mapped.has(doc2)) {\n                return mapped.get(doc2);\n              }\n              const result = process2(doc2);\n              mapped.set(doc2, result);\n              return result;\n            }\n            function process2(doc2) {\n              if (Array.isArray(doc2)) {\n                return cb(doc2.map(rec));\n              }\n              if (doc2.type === \"concat\" || doc2.type === \"fill\") {\n                const parts = doc2.parts.map(rec);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  parts\n                }));\n              }\n              if (doc2.type === \"if-break\") {\n                const breakContents = doc2.breakContents && rec(doc2.breakContents);\n                const flatContents = doc2.flatContents && rec(doc2.flatContents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  breakContents,\n                  flatContents\n                }));\n              }\n              if (doc2.type === \"group\" && doc2.expandedStates) {\n                const expandedStates = doc2.expandedStates.map(rec);\n                const contents = expandedStates[0];\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents,\n                  expandedStates\n                }));\n              }\n              if (doc2.contents) {\n                const contents = rec(doc2.contents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents\n                }));\n              }\n              return cb(doc2);\n            }\n          }\n          function findInDoc(doc, fn, defaultValue) {\n            let result = defaultValue;\n            let hasStopped = false;\n            function findInDocOnEnterFn(doc2) {\n              const maybeResult = fn(doc2);\n              if (maybeResult !== void 0) {\n                hasStopped = true;\n                result = maybeResult;\n              }\n              if (hasStopped) {\n                return false;\n              }\n            }\n            traverseDoc(doc, findInDocOnEnterFn);\n            return result;\n          }\n          function willBreakFn(doc) {\n            if (doc.type === \"group\" && doc.break) {\n              return true;\n            }\n            if (doc.type === \"line\" && doc.hard) {\n              return true;\n            }\n            if (doc.type === \"break-parent\") {\n              return true;\n            }\n          }\n          function willBreak(doc) {\n            return findInDoc(doc, willBreakFn, false);\n          }\n          function breakParentGroup(groupStack) {\n            if (groupStack.length > 0) {\n              const parentGroup = getLast(groupStack);\n              if (!parentGroup.expandedStates && !parentGroup.break) {\n                parentGroup.break = \"propagated\";\n              }\n            }\n            return null;\n          }\n          function propagateBreaks(doc) {\n            const alreadyVisitedSet = /* @__PURE__ */ new Set();\n            const groupStack = [];\n            function propagateBreaksOnEnterFn(doc2) {\n              if (doc2.type === \"break-parent\") {\n                breakParentGroup(groupStack);\n              }\n              if (doc2.type === \"group\") {\n                groupStack.push(doc2);\n                if (alreadyVisitedSet.has(doc2)) {\n                  return false;\n                }\n                alreadyVisitedSet.add(doc2);\n              }\n            }\n            function propagateBreaksOnExitFn(doc2) {\n              if (doc2.type === \"group\") {\n                const group = groupStack.pop();\n                if (group.break) {\n                  breakParentGroup(groupStack);\n                }\n              }\n            }\n            traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);\n          }\n          function removeLinesFn(doc) {\n            if (doc.type === \"line\" && !doc.hard) {\n              return doc.soft ? \"\" : \" \";\n            }\n            if (doc.type === \"if-break\") {\n              return doc.flatContents || \"\";\n            }\n            return doc;\n          }\n          function removeLines(doc) {\n            return mapDoc(doc, removeLinesFn);\n          }\n          var isHardline = (doc, nextDoc) => doc && doc.type === \"line\" && doc.hard && nextDoc && nextDoc.type === \"break-parent\";\n          function stripDocTrailingHardlineFromDoc(doc) {\n            if (!doc) {\n              return doc;\n            }\n            if (isConcat(doc) || doc.type === \"fill\") {\n              const parts = getDocParts(doc);\n              while (parts.length > 1 && isHardline(...parts.slice(-2))) {\n                parts.length -= 2;\n              }\n              if (parts.length > 0) {\n                const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));\n                parts[parts.length - 1] = lastPart;\n              }\n              return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n                parts\n              });\n            }\n            switch (doc.type) {\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"group\":\n              case \"line-suffix\":\n              case \"label\": {\n                const contents = stripDocTrailingHardlineFromDoc(doc.contents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  contents\n                });\n              }\n              case \"if-break\": {\n                const breakContents = stripDocTrailingHardlineFromDoc(doc.breakContents);\n                const flatContents = stripDocTrailingHardlineFromDoc(doc.flatContents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  breakContents,\n                  flatContents\n                });\n              }\n            }\n            return doc;\n          }\n          function stripTrailingHardline(doc) {\n            return stripDocTrailingHardlineFromDoc(cleanDoc(doc));\n          }\n          function cleanDocFn(doc) {\n            switch (doc.type) {\n              case \"fill\":\n                if (doc.parts.every((part) => part === \"\")) {\n                  return \"\";\n                }\n                break;\n              case \"group\":\n                if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n                  return \"\";\n                }\n                if (doc.contents.type === \"group\" && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n                  return doc.contents;\n                }\n                break;\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"line-suffix\":\n                if (!doc.contents) {\n                  return \"\";\n                }\n                break;\n              case \"if-break\":\n                if (!doc.flatContents && !doc.breakContents) {\n                  return \"\";\n                }\n                break;\n            }\n            if (!isConcat(doc)) {\n              return doc;\n            }\n            const parts = [];\n            for (const part of getDocParts(doc)) {\n              if (!part) {\n                continue;\n              }\n              const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];\n              if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {\n                parts[parts.length - 1] += currentPart;\n              } else {\n                parts.push(currentPart);\n              }\n              parts.push(...restParts);\n            }\n            if (parts.length === 0) {\n              return \"\";\n            }\n            if (parts.length === 1) {\n              return parts[0];\n            }\n            return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n              parts\n            });\n          }\n          function cleanDoc(doc) {\n            return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n          }\n          function normalizeParts(parts) {\n            const newParts = [];\n            const restParts = parts.filter(Boolean);\n            while (restParts.length > 0) {\n              const part = restParts.shift();\n              if (!part) {\n                continue;\n              }\n              if (isConcat(part)) {\n                restParts.unshift(...getDocParts(part));\n                continue;\n              }\n              if (newParts.length > 0 && typeof getLast(newParts) === \"string\" && typeof part === \"string\") {\n                newParts[newParts.length - 1] += part;\n                continue;\n              }\n              newParts.push(part);\n            }\n            return newParts;\n          }\n          function normalizeDoc(doc) {\n            return mapDoc(doc, (currentDoc) => {\n              if (Array.isArray(currentDoc)) {\n                return normalizeParts(currentDoc);\n              }\n              if (!currentDoc.parts) {\n                return currentDoc;\n              }\n              return Object.assign(Object.assign({}, currentDoc), {}, {\n                parts: normalizeParts(currentDoc.parts)\n              });\n            });\n          }\n          function replaceEndOfLine(doc) {\n            return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? replaceTextEndOfLine(currentDoc) : currentDoc);\n          }\n          function replaceTextEndOfLine(text) {\n            let replacement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : literalline;\n            return join(replacement, text.split(\"\\n\")).parts;\n          }\n          function canBreakFn(doc) {\n            if (doc.type === \"line\") {\n              return true;\n            }\n          }\n          function canBreak(doc) {\n            return findInDoc(doc, canBreakFn, false);\n          }\n          module2.exports = {\n            isConcat,\n            getDocParts,\n            willBreak,\n            traverseDoc,\n            findInDoc,\n            mapDoc,\n            propagateBreaks,\n            removeLines,\n            stripTrailingHardline,\n            normalizeParts,\n            normalizeDoc,\n            cleanDoc,\n            replaceTextEndOfLine,\n            replaceEndOfLine,\n            canBreak\n          };\n        }\n      });\n      var require_doc_printer = __commonJS2({\n        \"src/document/doc-printer.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            convertEndOfLineToChars\n          } = require_end_of_line();\n          var getLast = require_get_last();\n          var getStringWidth = require_get_string_width();\n          var {\n            fill,\n            cursor,\n            indent\n          } = require_doc_builders();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          var groupModeMap;\n          var MODE_BREAK = 1;\n          var MODE_FLAT = 2;\n          function rootIndent() {\n            return {\n              value: \"\",\n              length: 0,\n              queue: []\n            };\n          }\n          function makeIndent(ind, options) {\n            return generateInd(ind, {\n              type: \"indent\"\n            }, options);\n          }\n          function makeAlign(indent2, widthOrDoc, options) {\n            if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n              return indent2.root || rootIndent();\n            }\n            if (widthOrDoc < 0) {\n              return generateInd(indent2, {\n                type: \"dedent\"\n              }, options);\n            }\n            if (!widthOrDoc) {\n              return indent2;\n            }\n            if (widthOrDoc.type === \"root\") {\n              return Object.assign(Object.assign({}, indent2), {}, {\n                root: indent2\n              });\n            }\n            const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n            return generateInd(indent2, {\n              type: alignType,\n              n: widthOrDoc\n            }, options);\n          }\n          function generateInd(ind, newPart, options) {\n            const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n            let value = \"\";\n            let length = 0;\n            let lastTabs = 0;\n            let lastSpaces = 0;\n            for (const part of queue) {\n              switch (part.type) {\n                case \"indent\":\n                  flush();\n                  if (options.useTabs) {\n                    addTabs(1);\n                  } else {\n                    addSpaces(options.tabWidth);\n                  }\n                  break;\n                case \"stringAlign\":\n                  flush();\n                  value += part.n;\n                  length += part.n.length;\n                  break;\n                case \"numberAlign\":\n                  lastTabs += 1;\n                  lastSpaces += part.n;\n                  break;\n                default:\n                  throw new Error(`Unexpected type '${part.type}'`);\n              }\n            }\n            flushSpaces();\n            return Object.assign(Object.assign({}, ind), {}, {\n              value,\n              length,\n              queue\n            });\n            function addTabs(count) {\n              value += \"\t\".repeat(count);\n              length += options.tabWidth * count;\n            }\n            function addSpaces(count) {\n              value += \" \".repeat(count);\n              length += count;\n            }\n            function flush() {\n              if (options.useTabs) {\n                flushTabs();\n              } else {\n                flushSpaces();\n              }\n            }\n            function flushTabs() {\n              if (lastTabs > 0) {\n                addTabs(lastTabs);\n              }\n              resetLast();\n            }\n            function flushSpaces() {\n              if (lastSpaces > 0) {\n                addSpaces(lastSpaces);\n              }\n              resetLast();\n            }\n            function resetLast() {\n              lastTabs = 0;\n              lastSpaces = 0;\n            }\n          }\n          function trim(out) {\n            if (out.length === 0) {\n              return 0;\n            }\n            let trimCount = 0;\n            while (out.length > 0 && typeof getLast(out) === \"string\" && /^[\\t ]*$/.test(getLast(out))) {\n              trimCount += out.pop().length;\n            }\n            if (out.length > 0 && typeof getLast(out) === \"string\") {\n              const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");\n              trimCount += getLast(out).length - trimmed.length;\n              out[out.length - 1] = trimmed;\n            }\n            return trimCount;\n          }\n          function fits(next, restCommands, width, hasLineSuffix, mustBeFlat) {\n            let restIdx = restCommands.length;\n            const cmds = [next];\n            const out = [];\n            while (width >= 0) {\n              if (cmds.length === 0) {\n                if (restIdx === 0) {\n                  return true;\n                }\n                cmds.push(restCommands[--restIdx]);\n                continue;\n              }\n              const {\n                mode,\n                doc\n              } = cmds.pop();\n              if (typeof doc === \"string\") {\n                out.push(doc);\n                width -= getStringWidth(doc);\n              } else if (isConcat(doc) || doc.type === \"fill\") {\n                const parts = getDocParts(doc);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc.type) {\n                  case \"indent\":\n                  case \"align\":\n                  case \"indent-if-break\":\n                  case \"label\":\n                    cmds.push({\n                      mode,\n                      doc: doc.contents\n                    });\n                    break;\n                  case \"trim\":\n                    width += trim(out);\n                    break;\n                  case \"group\": {\n                    if (mustBeFlat && doc.break) {\n                      return false;\n                    }\n                    const groupMode = doc.break ? MODE_BREAK : mode;\n                    const contents = doc.expandedStates && groupMode === MODE_BREAK ? getLast(doc.expandedStates) : doc.contents;\n                    cmds.push({\n                      mode: groupMode,\n                      doc: contents\n                    });\n                    break;\n                  }\n                  case \"if-break\": {\n                    const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n                    const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n                    if (contents) {\n                      cmds.push({\n                        mode,\n                        doc: contents\n                      });\n                    }\n                    break;\n                  }\n                  case \"line\":\n                    if (mode === MODE_BREAK || doc.hard) {\n                      return true;\n                    }\n                    if (!doc.soft) {\n                      out.push(\" \");\n                      width--;\n                    }\n                    break;\n                  case \"line-suffix\":\n                    hasLineSuffix = true;\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (hasLineSuffix) {\n                      return false;\n                    }\n                    break;\n                }\n              }\n            }\n            return false;\n          }\n          function printDocToString(doc, options) {\n            groupModeMap = {};\n            const width = options.printWidth;\n            const newLine = convertEndOfLineToChars(options.endOfLine);\n            let pos = 0;\n            const cmds = [{\n              ind: rootIndent(),\n              mode: MODE_BREAK,\n              doc\n            }];\n            const out = [];\n            let shouldRemeasure = false;\n            const lineSuffix = [];\n            while (cmds.length > 0) {\n              const {\n                ind,\n                mode,\n                doc: doc2\n              } = cmds.pop();\n              if (typeof doc2 === \"string\") {\n                const formatted = newLine !== \"\\n\" ? doc2.replace(/\\n/g, newLine) : doc2;\n                out.push(formatted);\n                pos += getStringWidth(formatted);\n              } else if (isConcat(doc2)) {\n                const parts = getDocParts(doc2);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    ind,\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc2.type) {\n                  case \"cursor\":\n                    out.push(cursor.placeholder);\n                    break;\n                  case \"indent\":\n                    cmds.push({\n                      ind: makeIndent(ind, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"align\":\n                    cmds.push({\n                      ind: makeAlign(ind, doc2.n, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"trim\":\n                    pos -= trim(out);\n                    break;\n                  case \"group\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!shouldRemeasure) {\n                          cmds.push({\n                            ind,\n                            mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                            doc: doc2.contents\n                          });\n                          break;\n                        }\n                      case MODE_BREAK: {\n                        shouldRemeasure = false;\n                        const next = {\n                          ind,\n                          mode: MODE_FLAT,\n                          doc: doc2.contents\n                        };\n                        const rem = width - pos;\n                        const hasLineSuffix = lineSuffix.length > 0;\n                        if (!doc2.break && fits(next, cmds, rem, hasLineSuffix)) {\n                          cmds.push(next);\n                        } else {\n                          if (doc2.expandedStates) {\n                            const mostExpanded = getLast(doc2.expandedStates);\n                            if (doc2.break) {\n                              cmds.push({\n                                ind,\n                                mode: MODE_BREAK,\n                                doc: mostExpanded\n                              });\n                              break;\n                            } else {\n                              for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                                if (i >= doc2.expandedStates.length) {\n                                  cmds.push({\n                                    ind,\n                                    mode: MODE_BREAK,\n                                    doc: mostExpanded\n                                  });\n                                  break;\n                                } else {\n                                  const state = doc2.expandedStates[i];\n                                  const cmd = {\n                                    ind,\n                                    mode: MODE_FLAT,\n                                    doc: state\n                                  };\n                                  if (fits(cmd, cmds, rem, hasLineSuffix)) {\n                                    cmds.push(cmd);\n                                    break;\n                                  }\n                                }\n                              }\n                            }\n                          } else {\n                            cmds.push({\n                              ind,\n                              mode: MODE_BREAK,\n                              doc: doc2.contents\n                            });\n                          }\n                        }\n                        break;\n                      }\n                    }\n                    if (doc2.id) {\n                      groupModeMap[doc2.id] = getLast(cmds).mode;\n                    }\n                    break;\n                  case \"fill\": {\n                    const rem = width - pos;\n                    const {\n                      parts\n                    } = doc2;\n                    if (parts.length === 0) {\n                      break;\n                    }\n                    const [content, whitespace] = parts;\n                    const contentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: content\n                    };\n                    const contentBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: content\n                    };\n                    const contentFits = fits(contentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (parts.length === 1) {\n                      if (contentFits) {\n                        cmds.push(contentFlatCmd);\n                      } else {\n                        cmds.push(contentBreakCmd);\n                      }\n                      break;\n                    }\n                    const whitespaceFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: whitespace\n                    };\n                    const whitespaceBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: whitespace\n                    };\n                    if (parts.length === 2) {\n                      if (contentFits) {\n                        cmds.push(whitespaceFlatCmd, contentFlatCmd);\n                      } else {\n                        cmds.push(whitespaceBreakCmd, contentBreakCmd);\n                      }\n                      break;\n                    }\n                    parts.splice(0, 2);\n                    const remainingCmd = {\n                      ind,\n                      mode,\n                      doc: fill(parts)\n                    };\n                    const secondContent = parts[0];\n                    const firstAndSecondContentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: [content, whitespace, secondContent]\n                    };\n                    const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (firstAndSecondContentFits) {\n                      cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n                    } else if (contentFits) {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n                    } else {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n                    }\n                    break;\n                  }\n                  case \"if-break\":\n                  case \"indent-if-break\": {\n                    const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n                    if (groupMode === MODE_BREAK) {\n                      const breakContents = doc2.type === \"if-break\" ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n                      if (breakContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: breakContents\n                        });\n                      }\n                    }\n                    if (groupMode === MODE_FLAT) {\n                      const flatContents = doc2.type === \"if-break\" ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n                      if (flatContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: flatContents\n                        });\n                      }\n                    }\n                    break;\n                  }\n                  case \"line-suffix\":\n                    lineSuffix.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (lineSuffix.length > 0) {\n                      cmds.push({\n                        ind,\n                        mode,\n                        doc: {\n                          type: \"line\",\n                          hard: true\n                        }\n                      });\n                    }\n                    break;\n                  case \"line\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!doc2.hard) {\n                          if (!doc2.soft) {\n                            out.push(\" \");\n                            pos += 1;\n                          }\n                          break;\n                        } else {\n                          shouldRemeasure = true;\n                        }\n                      case MODE_BREAK:\n                        if (lineSuffix.length > 0) {\n                          cmds.push({\n                            ind,\n                            mode,\n                            doc: doc2\n                          }, ...lineSuffix.reverse());\n                          lineSuffix.length = 0;\n                          break;\n                        }\n                        if (doc2.literal) {\n                          if (ind.root) {\n                            out.push(newLine, ind.root.value);\n                            pos = ind.root.length;\n                          } else {\n                            out.push(newLine);\n                            pos = 0;\n                          }\n                        } else {\n                          pos -= trim(out);\n                          out.push(newLine + ind.value);\n                          pos = ind.length;\n                        }\n                        break;\n                    }\n                    break;\n                  case \"label\":\n                    cmds.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  default:\n                }\n              }\n              if (cmds.length === 0 && lineSuffix.length > 0) {\n                cmds.push(...lineSuffix.reverse());\n                lineSuffix.length = 0;\n              }\n            }\n            const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n            if (cursorPlaceholderIndex !== -1) {\n              const otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n              const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n              const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n              const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n              return {\n                formatted: beforeCursor + aroundCursor + afterCursor,\n                cursorNodeStart: beforeCursor.length,\n                cursorNodeText: aroundCursor\n              };\n            }\n            return {\n              formatted: out.join(\"\")\n            };\n          }\n          module2.exports = {\n            printDocToString\n          };\n        }\n      });\n      var require_doc_debug = __commonJS2({\n        \"src/document/doc-debug.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          function flattenDoc(doc) {\n            if (!doc) {\n              return \"\";\n            }\n            if (isConcat(doc)) {\n              const res = [];\n              for (const part of getDocParts(doc)) {\n                if (isConcat(part)) {\n                  res.push(...flattenDoc(part).parts);\n                } else {\n                  const flattened = flattenDoc(part);\n                  if (flattened !== \"\") {\n                    res.push(flattened);\n                  }\n                }\n              }\n              return {\n                type: \"concat\",\n                parts: res\n              };\n            }\n            if (doc.type === \"if-break\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                breakContents: flattenDoc(doc.breakContents),\n                flatContents: flattenDoc(doc.flatContents)\n              });\n            }\n            if (doc.type === \"group\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents),\n                expandedStates: doc.expandedStates && doc.expandedStates.map(flattenDoc)\n              });\n            }\n            if (doc.type === \"fill\") {\n              return {\n                type: \"fill\",\n                parts: doc.parts.map(flattenDoc)\n              };\n            }\n            if (doc.contents) {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents)\n              });\n            }\n            return doc;\n          }\n          function printDocToDebug(doc) {\n            const printedSymbols = /* @__PURE__ */ Object.create(null);\n            const usedKeysForSymbols = /* @__PURE__ */ new Set();\n            return printDoc(flattenDoc(doc));\n            function printDoc(doc2, index, parentParts) {\n              if (typeof doc2 === \"string\") {\n                return JSON.stringify(doc2);\n              }\n              if (isConcat(doc2)) {\n                const printed = getDocParts(doc2).map(printDoc).filter(Boolean);\n                return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;\n              }\n              if (doc2.type === \"line\") {\n                const withBreakParent = Array.isArray(parentParts) && parentParts[index + 1] && parentParts[index + 1].type === \"break-parent\";\n                if (doc2.literal) {\n                  return withBreakParent ? \"literalline\" : \"literallineWithoutBreakParent\";\n                }\n                if (doc2.hard) {\n                  return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";\n                }\n                if (doc2.soft) {\n                  return \"softline\";\n                }\n                return \"line\";\n              }\n              if (doc2.type === \"break-parent\") {\n                const afterHardline = Array.isArray(parentParts) && parentParts[index - 1] && parentParts[index - 1].type === \"line\" && parentParts[index - 1].hard;\n                return afterHardline ? void 0 : \"breakParent\";\n              }\n              if (doc2.type === \"trim\") {\n                return \"trim\";\n              }\n              if (doc2.type === \"indent\") {\n                return \"indent(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"align\") {\n                return doc2.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + printDoc(doc2.contents) + \")\" : doc2.n < 0 ? \"dedent(\" + printDoc(doc2.contents) + \")\" : doc2.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc2.contents) + \")\" : \"align(\" + JSON.stringify(doc2.n) + \", \" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"if-break\") {\n                return \"ifBreak(\" + printDoc(doc2.breakContents) + (doc2.flatContents ? \", \" + printDoc(doc2.flatContents) : \"\") + (doc2.groupId ? (!doc2.flatContents ? ', \"\"' : \"\") + `, { groupId: ${printGroupId(doc2.groupId)} }` : \"\") + \")\";\n              }\n              if (doc2.type === \"indent-if-break\") {\n                const optionsParts = [];\n                if (doc2.negate) {\n                  optionsParts.push(\"negate: true\");\n                }\n                if (doc2.groupId) {\n                  optionsParts.push(`groupId: ${printGroupId(doc2.groupId)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                return `indentIfBreak(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"group\") {\n                const optionsParts = [];\n                if (doc2.break && doc2.break !== \"propagated\") {\n                  optionsParts.push(\"shouldBreak: true\");\n                }\n                if (doc2.id) {\n                  optionsParts.push(`id: ${printGroupId(doc2.id)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                if (doc2.expandedStates) {\n                  return `conditionalGroup([${doc2.expandedStates.map((part) => printDoc(part)).join(\",\")}]${options})`;\n                }\n                return `group(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"fill\") {\n                return `fill([${doc2.parts.map((part) => printDoc(part)).join(\", \")}])`;\n              }\n              if (doc2.type === \"line-suffix\") {\n                return \"lineSuffix(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"line-suffix-boundary\") {\n                return \"lineSuffixBoundary\";\n              }\n              if (doc2.type === \"label\") {\n                return `label(${JSON.stringify(doc2.label)}, ${printDoc(doc2.contents)})`;\n              }\n              throw new Error(\"Unknown doc type \" + doc2.type);\n            }\n            function printGroupId(id) {\n              if (typeof id !== \"symbol\") {\n                return JSON.stringify(String(id));\n              }\n              if (id in printedSymbols) {\n                return printedSymbols[id];\n              }\n              const prefix = String(id).slice(7, -1) || \"symbol\";\n              for (let counter = 0; ; counter++) {\n                const key = prefix + (counter > 0 ? ` #${counter}` : \"\");\n                if (!usedKeysForSymbols.has(key)) {\n                  usedKeysForSymbols.add(key);\n                  return printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`;\n                }\n              }\n            }\n          }\n          module2.exports = {\n            printDocToDebug\n          };\n        }\n      });\n      init_define_process();\n      module.exports = {\n        builders: require_doc_builders(),\n        printer: require_doc_printer(),\n        utils: require_doc_utils(),\n        debug: require_doc_debug()\n      };\n    }\n  });\n  return require_doc_js_umd();\n});","import { createParserContext, ParserState } from \"./state\";\nimport { getLazyParser, Parser } from \".\";\n\nimport { Options, RequiredOptions } from \"prettier\";\nimport { Doc } from \"prettier\";\nimport { builders as b, printer } from \"prettier/doc\";\nimport chalk from \"chalk\";\n\nconst MAX_LINES = 4;\nconst MAX_LINE_LENGTH = 80;\n\nconst defaultGroupOptions = {};\n\nconst defaultOptions = {\n    printWidth: 30,\n    tabWidth: 4,\n    useTabs: false,\n} as RequiredOptions;\n\nexport function prettierPrint(doc: Doc) {\n    return printer.printDocToString(doc, defaultOptions).formatted;\n}\n\nexport const summarizeLine = (line: string, maxLength: number = MAX_LINE_LENGTH) => {\n    const newLine = line.indexOf(\"\\n\");\n    const length = Math.min(line.length, newLine === -1 ? line.length : newLine);\n\n    if (length <= MAX_LINE_LENGTH) {\n        return line;\n    } else {\n        return line.slice(0, maxLength) + \"...\";\n    }\n};\n\nexport function addCursor(\n    state: ParserState<any>,\n    cursor: string = \"^\",\n    error: boolean = false\n): string {\n    const color = (error ? chalk.red : chalk.green).bold;\n\n    const lines = state.src.split(\"\\n\");\n    const lineIdx = Math.min(lines.length - 1, state.getLineNumber());\n    const startIdx = Math.max(lineIdx - MAX_LINES, 0);\n    const endIdx = Math.min(lineIdx + MAX_LINES + 1, lines.length);\n\n    const lineSummaries = lines.slice(startIdx, endIdx);\n\n    if (cursor) {\n        const cursorLine = \" \".repeat(state.getColumnNumber()) + color(cursor);\n        lineSummaries.splice(lineIdx - startIdx + 1, 0, cursorLine);\n    }\n\n    const resultLines = lineSummaries.map((line, idx) => {\n        const lineNum = startIdx + idx + 1;\n        let paddedLineNum = color.reset.black(String(lineNum));\n\n        line = lineNum === lineIdx + 1 ? color(line) : line;\n        const paddedLine = `      ${paddedLineNum}| ${line}`;\n\n        return paddedLine;\n    });\n\n    return resultLines.join(\"\\n\");\n}\n\nconst group = (docs: Doc, groupOptions: Options = {}) => {\n    return b.group(docs, { ...defaultOptions, ...groupOptions } as any);\n};\n\nconst opStyle = (op: string) => chalk.gray(op);\nconst PARSER_STRINGS = new Map<number, any>();\n\nexport function parserPrint(parser: Parser<any>) {\n    if (PARSER_STRINGS.has(parser.id)) {\n        return PARSER_STRINGS.get(parser.id);\n    }\n\n    const print = (innerParser: Parser<any>, id?: number) => {\n        if (PARSER_STRINGS.has(innerParser.id)) {\n            return PARSER_STRINGS.get(innerParser.id);\n        }\n\n        const { name, args, parser: innerInnerParser } = innerParser.context;\n        const parserString =\n            innerInnerParser != null\n                ? print(innerInnerParser, id)\n                : chalk.red.bold(\"unknown\");\n\n        let s = (() => {\n            switch (name) {\n                case \"string\":\n                    return chalk.yellow(`\"${args[0]}\"`);\n                case \"regex\":\n                case \"regexConcat\":\n                case \"regexWrap\":\n                    return chalk.redBright(`${args[0]}`);\n                case \"wrap\":\n                case \"trim\": {\n                    const [left, right] = args;\n                    return group([\n                        print(left, id),\n                        b.indent([b.softline, parserString]),\n                        b.softline,\n                        print(right, id),\n                    ]);\n                }\n                case \"trimWhitespace\":\n                    return group([parserString, opStyle(\"?w\")]);\n                case \"not\":\n                    return group([\"!\", parserString]);\n                case \"opt\":\n                    return group([parserString, opStyle(\"?\")]);\n                case \"next\":\n                    const [next] = args;\n                    return group([parserString, opStyle(\" >> \"), print(next, id)]);\n                case \"skip\":\n                    const [skip] = args;\n                    return group([parserString, opStyle(\" << \"), print(skip, id)]);\n\n                case \"map\":\n                    return parserString;\n                case \"all\":\n                case \"then\": {\n                    const delim = opStyle(\", \");\n                    return group([\n                        \"[\",\n                        b.indent([\n                            b.softline,\n                            b.join(\n                                [delim, b.softline],\n                                args.map((x) => print(x, id))\n                            ),\n                        ]),\n                        b.softline,\n                        \"]\",\n                    ]);\n                }\n                case \"any\":\n                case \"or\": {\n                    const delim = opStyle(\"| \");\n                    return group([\n                        [\n                            b.join(\n                                [b.softline, b.ifBreak(delim, \" \" + delim)],\n                                args.map((x) => print(x, id))\n                            ),\n                        ],\n                    ]);\n                }\n                case \"many\":\n                    const [min, max] = args;\n                    let bounds = max === Infinity ? `${min},` : `${min},${max}`;\n                    bounds = chalk.bold.gray(` {${bounds}}`);\n                    return group([parserString, bounds]);\n                case \"sepBy\":\n                    return group([\n                        parserString,\n                        b.indent([\" sepBy \", print(args[0], id)]),\n                    ]);\n                case \"lazy\": {\n                    const [lazy] = args;\n                    const p = getLazyParser(lazy);\n\n                    if (!id) {\n                        const s = print(p, p.id);\n                        PARSER_STRINGS.set(p.id, s);\n                        return s;\n                    } else {\n                        return chalk.bold.blue(name);\n                    }\n                }\n                case \"debug\":\n                    return parserString;\n            }\n        })();\n        s ??= chalk.red.bold(name);\n        if (id) {\n            PARSER_STRINGS.set(innerParser.id, s);\n        }\n        return s;\n    };\n\n    const doc = print(parser);\n    const s = prettierPrint(doc);\n    PARSER_STRINGS.set(parser.id, s);\n\n    return s;\n}\n\nexport function statePrint(\n    state: ParserState<any>,\n    name: string = \"\",\n    parserString: string = \"\"\n) {\n    const stateBgColor = !state.isError ? chalk.bgGreen : chalk.bgRed;\n    const stateColor = !state.isError ? chalk.green : chalk.red;\n\n    const finished = state.offset >= state.src.length;\n\n    const stateSymbol = !state.isError ? (finished ? \"\" : \"\") : \"\";\n    const stateName = !state.isError ? (finished ? \"Done\" : \"Ok\") : \"Err\";\n    const stateString = \" \" + stateName + \" \" + stateSymbol + \" \";\n\n    const header = group([\n        stateBgColor.bold(stateString),\n        stateColor(`\\t${name}\\t${state.offset}`),\n        b.softline,\n        \"\\t\" + chalk.yellow(parserString),\n    ]);\n\n    const body = (() => {\n        if (state.offset >= state.src.length) {\n            return chalk.bold.greenBright(addCursor(state, \"\", state.isError));\n        }\n        return addCursor(state, \"^\", state.isError);\n    })();\n\n    const headerBody = group([header, b.hardline, b.indent([body])]);\n\n    return prettierPrint(headerBody);\n}\n\nexport function parserDebug<T>(\n    parser: Parser<T>,\n    name: string = \"\",\n    recursivePrint: boolean = false,\n    logger: (...s: any[]) => void = console.log\n) {\n    const debug = (state: ParserState<T>) => {\n        const newState = parser.parser(state);\n\n        const parserString = recursivePrint ? parserPrint(parser) : parser.context.name;\n        const s = statePrint(newState, name, parserString);\n\n        logger(s);\n\n        return newState;\n    };\n    return new Parser(debug, createParserContext(\"debug\", parser, logger));\n}\n","import { Parser } from \".\";\nimport { statePrint } from \"./debug\";\n\nexport class ParserState<T> {\n    constructor(\n        public src: string,\n        public value: T = undefined,\n        public offset: number = 0,\n        public isError: boolean = false,\n        public furthest: number = 0\n    ) {}\n\n    ok<S>(value: S, offset: number = 0) {\n        offset += this.offset;\n        return new ParserState<S>(this.src, value, offset, false);\n    }\n\n    err<S>(value?: S, offset: number = 0) {\n        const nextState = this.ok(value, offset);\n        nextState.isError = true;\n        return nextState;\n    }\n\n    from<S>(value: S, offset: number = 0) {\n        offset += this.offset;\n        return new ParserState<S>(this.src, value, offset, this.isError);\n    }\n\n    getColumnNumber(): number {\n        const offset = this.offset;\n        const lastNewline = this.src.lastIndexOf(\"\\n\", offset);\n        const columnNumber = lastNewline === -1 ? offset : offset - (lastNewline + 1);\n        return Math.max(0, columnNumber);\n    }\n\n    getLineNumber(): number {\n        const newlineIndex = this.src.lastIndexOf(\"\\n\", this.offset);\n        return newlineIndex >= 0\n            ? this.src.slice(0, newlineIndex).split(\"\\n\").length\n            : 0;\n    }\n\n    toString() {\n        return statePrint(this);\n    }\n}\n\nexport const parserNames = [\n    \"string\",\n    \"regex\",\n    \"then\",\n    \"or\",\n    \"chain\",\n    \"map\",\n    \"many\",\n    \"lazy\",\n    \"memoize\",\n    \"mergeMemo\",\n    \"not\",\n    \"skip\",\n    \"next\",\n    \"trim\",\n    \"trimWhitespace\",\n    \"whitespace\",\n    \"wrap\",\n    \"sepBy\",\n    \"any\",\n    \"all\",\n    \"opt\",\n    \"lookAhead\",\n    \"lookBehind\",\n    \"eof\",\n    \"regexConcat\",\n    \"regexWrap\",\n    \"debug\",\n    \"mapState\",\n] as const;\n\nexport type ParserContext<T = any> = {\n    name?: (typeof parserNames)[number];\n    parser?: Parser<T>;\n    args?: any[];\n};\n\n// TODO: maybe reintroduce debug check.\nexport function createParserContext<T = any>(\n    name: (typeof parserNames)[number],\n    parser: Parser<T>,\n    ...args: any[]\n) {\n    return {\n        name,\n        parser,\n        args,\n    };\n}\n","import { createParserContext, ParserContext, ParserState } from \"./state\";\nimport { parserDebug, parserPrint } from \"./debug\";\n\ntype ExtractValue<T extends ReadonlyArray<Parser<any>>> = {\n    [K in keyof T]: T[K] extends Parser<infer V> ? V : never;\n};\n\ntype ParserFunction<T = string> = (val: ParserState<T>) => ParserState<T>;\n\nlet PARSER_ID = 0;\n\nconst MEMO = new Map<number, ParserState<any>>();\nconst LEFT_RECURSION_COUNTS = new Map<string, number>();\n\nlet lastState: ParserState<any> | undefined;\n\nexport function mergeErrorState(state: ParserState<any>) {\n    if (!lastState || (lastState && state.offset > lastState.offset)) {\n        lastState = state;\n    }\n    return lastState;\n}\n\nexport function getLazyParser<T>(fn: (() => Parser<T>) & any): Parser<T> {\n    if (fn.parser) {\n        return fn.parser;\n    }\n    return (fn.parser = fn());\n}\n\nexport class Parser<T = string> {\n    id: number = PARSER_ID++;\n    state: ParserState<T> | undefined;\n\n    constructor(public parser: ParserFunction<T>, public context: ParserContext = {}) {}\n\n    reset() {\n        lastState = undefined;\n        MEMO.clear();\n        LEFT_RECURSION_COUNTS.clear();\n    }\n\n    parse(val: string) {\n        this.reset();\n\n        const newState = this.parser(new ParserState(val));\n\n        this.state = mergeErrorState(newState);\n        this.state.isError = newState.isError;\n\n        return newState.value;\n    }\n\n    getCijKey(state: ParserState<T>) {\n        return `${this.id}${state.offset}`;\n    }\n\n    atLeftRecursionLimit(state: ParserState<T>) {\n        const cij = LEFT_RECURSION_COUNTS.get(this.getCijKey(state)) ?? 0;\n        return cij > state.src.length - state.offset;\n    }\n\n    memoize() {\n        const memoize = (state: ParserState<T>) => {\n            const cijKey = this.getCijKey(state);\n            const cij = LEFT_RECURSION_COUNTS.get(cijKey) ?? 0;\n\n            let cached = MEMO.get(this.id);\n\n            if (cached && cached.offset >= state.offset) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            LEFT_RECURSION_COUNTS.set(cijKey, cij + 1);\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n\n            if (cached && cached.offset > newState.offset) {\n                newState.offset = cached.offset;\n            } else if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n\n            return newState;\n        };\n        return new Parser(\n            memoize as ParserFunction<T>,\n            createParserContext(\"memoize\", this)\n        );\n    }\n\n    mergeMemos<S>() {\n        const mergeMemo = (state: ParserState<T>) => {\n            let cached = MEMO.get(this.id);\n            if (cached) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n            if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n            return newState;\n        };\n\n        return new Parser(\n            mergeMemo as ParserFunction<[T, S]>,\n            createParserContext(\"mergeMemo\", this)\n        );\n    }\n\n    then<S>(next: Parser<S | T>) {\n        if (isStringParsers(this, next)) {\n            return concatStringParsers([this, next], \"\", (m) => [m?.[0], m?.[1]]);\n        }\n\n        const then = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = next.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok([nextState1.value, nextState2.value]);\n                }\n            }\n            mergeErrorState(state);\n            return state.err(undefined);\n        };\n\n        return new Parser(\n            then as ParserFunction<[T, S]>,\n            createParserContext(\"then\", this, this, next)\n        );\n    }\n\n    or<S>(other: Parser<S | T>) {\n        if (isStringParsers(this, other)) {\n            return concatStringParsers([this, other], \"|\");\n        }\n\n        const or = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (!newState.isError) {\n                return newState;\n            }\n            return other.parser(state);\n        };\n\n        return new Parser(\n            or as ParserFunction<T | S>,\n            createParserContext(\"or\", this, this, other)\n        );\n    }\n\n    chain<S>(fn: (value: T) => Parser<S | T>, chainError: boolean = false) {\n        const chain = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            } else if (newState.value || chainError) {\n                return fn(newState.value).parser(newState);\n            }\n            return state;\n        };\n\n        return new Parser(chain, createParserContext(\"chain\", this, fn));\n    }\n\n    map<S>(fn: (value: T) => S, mapError: boolean = false) {\n        const map = (state: ParserState<T | S>) => {\n            const newState = this.parser(state as ParserState<T>);\n\n            if (!newState.isError || mapError) {\n                return newState.ok(fn(newState.value));\n            }\n            return newState;\n        };\n\n        return new Parser(map as ParserFunction<S>, createParserContext(\"map\", this));\n    }\n\n    mapState<S extends T>(fn: (state: ParserState<T>) => ParserState<S>) {\n        const mapState = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            return fn(newState);\n        };\n\n        return new Parser(\n            mapState as ParserFunction<S>,\n            createParserContext(\"mapState\", this)\n        );\n    }\n\n    skip<S>(parser: Parser<T | S>) {\n        const skip = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = parser.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok(nextState1.value);\n                }\n            }\n            mergeErrorState(state);\n            return state.err(undefined);\n        };\n        return new Parser(\n            skip as ParserFunction<T>,\n            createParserContext(\"skip\", this, parser)\n        );\n    }\n\n    next<S>(parser: Parser<S>) {\n        const next = this.then(parser).map(([, b]) => {\n            return b;\n        }) as Parser<S>;\n        next.context = createParserContext(\"next\", this, parser);\n        return next;\n    }\n\n    opt() {\n        const opt = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            if (newState.isError) {\n                mergeErrorState(state);\n                return state.ok(undefined);\n            }\n            return newState;\n        };\n        return new Parser(opt as ParserFunction<T>, createParserContext(\"opt\", this));\n    }\n\n    not<S extends T>(parser?: Parser<S | T>) {\n        const negate = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                mergeErrorState(state);\n                return state.ok(state.value);\n            } else {\n                return state.err(undefined);\n            }\n        };\n\n        const not = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                mergeErrorState(state);\n                return newState;\n            } else {\n                const nextState = parser.parser(state);\n                if (nextState.isError) {\n                    return newState;\n                } else {\n                    mergeErrorState(state);\n                    return state.err(undefined);\n                }\n            }\n        };\n\n        return new Parser(\n            parser ? not : negate,\n            createParserContext(\"not\", this, parser)\n        );\n    }\n\n    wrap<L, R>(start: Parser<L>, end: Parser<R>, discard: boolean = true) {\n        if (!discard) {\n            return all(start, this, end);\n        }\n\n        if (isStringParsers(start, this, end)) {\n            return wrapStringParsers(start, this, end);\n        }\n        const wrap = start.next(this).skip(end) as Parser<T>;\n        wrap.context = createParserContext(\"wrap\", this, start, end);\n        return wrap;\n    }\n\n    trim<S>(parser: Parser<S> = whitespace as any, discard: boolean = true) {\n        if (!discard) {\n            return all(parser, this, parser) as Parser<T[]>;\n        }\n\n        if (parser.context?.name === \"whitespace\") {\n            if (isStringParsers(this, parser)) {\n                return concatStringParsers(\n                    [parser, this, parser],\n                    \"\",\n                    (m) => m?.[2]\n                ) as Parser<T>;\n            }\n\n            const whitespaceTrim = (state: ParserState<T>) => {\n                const newState = trimStateWhitespace(state);\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    mergeErrorState(state);\n                    return state.err(undefined);\n                } else {\n                    return trimStateWhitespace(tmpState);\n                }\n            };\n\n            return new Parser(\n                whitespaceTrim as ParserFunction<T>,\n                createParserContext(\"trimWhitespace\", this)\n            ) as Parser<T>;\n        }\n\n        return this.wrap(parser, parser) as Parser<T>;\n    }\n\n    many(min: number = 0, max: number = Infinity) {\n        const many = (state: ParserState<T>) => {\n            const matches: T[] = [];\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    break;\n                }\n                matches.push(tmpState.value);\n                newState = tmpState;\n            }\n\n            if (matches.length >= min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            mergeErrorState(state);\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            many as ParserFunction<T[]>,\n            createParserContext(\"many\", this, min, max)\n        );\n    }\n\n    sepBy<S>(sep: Parser<S | T>, min: number = 0, max: number = Infinity) {\n        const sepBy = (state: ParserState<T>) => {\n            const matches: T[] = [];\n\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n                if (tmpState.isError) {\n                    break;\n                }\n                newState = tmpState;\n                matches.push(newState.value);\n\n                const sepState = sep.parser(newState);\n                if (sepState.isError) {\n                    break;\n                }\n                newState = sepState as ParserState<T>;\n            }\n\n            if (matches.length > min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            mergeErrorState(state);\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            sepBy as ParserFunction<T[]>,\n            createParserContext(\"sepBy\", this, sep)\n        );\n    }\n\n    eof() {\n        const p = this.skip(eof()) as Parser<T>;\n        p.context = createParserContext(\"eof\", this);\n        return p;\n    }\n\n    debug(\n        name: string = \"\",\n        recursivePrint: boolean = false,\n        logger: (...s: any[]) => void = console.log\n    ) {\n        return parserDebug(this, name, recursivePrint, logger);\n    }\n\n    toString() {\n        return parserPrint(this);\n    }\n\n    static lazy<T>(fn: () => Parser<T>) {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(fn).parser(state) as ParserState<T>;\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, fn));\n    }\n}\n\nfunction isStringParsers(...parsers: Parser<any>[]) {\n    return parsers.every(\n        (p) =>\n            (p.context?.name === \"string\" ||\n                p.context?.name === \"regex\" ||\n                p.context?.name === \"whitespace\") &&\n            p.context?.args\n    );\n}\n\nfunction stringParserValue(p: Parser<any>) {\n    if (p.context?.name === \"string\") {\n        return p.context?.args[0].replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    } else if (p.context?.name === \"regex\" || p.context?.name === \"whitespace\") {\n        return p.context?.args[0].source;\n    }\n}\n\nfunction concatStringParsers(\n    parsers: Parser<any>[],\n    delim: string = \"\",\n    matchFunction?: (m: RegExpMatchArray) => any\n): Parser<string> {\n    const s = parsers.map((s) => `(${stringParserValue(s)})`).join(delim);\n    const r = new RegExp(s);\n    const rP = regex(r, matchFunction);\n\n    if (delim !== \"|\") {\n        rP.context = createParserContext(\"regexConcat\", this, r);\n    }\n    return rP;\n}\n\nfunction wrapStringParsers<L, T, R>(\n    left: Parser<L>,\n    p: Parser<T>,\n    right: Parser<R>\n): Parser<string> {\n    const rP = concatStringParsers([left, p, right], \"\", (m) => {\n        return m?.[2];\n    });\n    rP.context.name = \"regexWrap\";\n    return rP;\n}\n\nexport function eof<T>() {\n    const eof = (state: ParserState<T>) => {\n        if (state.offset >= state.src.length) {\n            return state.ok(undefined);\n        } else {\n            mergeErrorState(state);\n            return state.err();\n        }\n    };\n    return new Parser(eof, createParserContext(\"eof\", undefined)) as Parser<any>;\n}\n\nexport function lazy<T>(\n    target: any,\n    propertyName: string,\n    descriptor: TypedPropertyDescriptor<() => Parser<T>>\n) {\n    const method = descriptor.value.bind(target)!;\n\n    descriptor.value = function () {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(method).parser(state) as ParserState<T>;\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, method));\n    };\n}\n\nexport function any<T extends any[]>(...parsers: T) {\n    if (isStringParsers(...parsers)) {\n        return concatStringParsers(parsers, \"|\") as Parser<ExtractValue<T>[number]>;\n    }\n\n    const any = (state: ParserState<T>) => {\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n            if (!newState.isError) {\n                return newState;\n            }\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : any,\n        createParserContext(\"any\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>[number]>;\n}\n\nexport function all<T extends any[]>(...parsers: T) {\n    const all = (state: ParserState<ExtractValue<T>>): ParserState<ExtractValue<T>> => {\n        const matches = [] as any;\n\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            }\n\n            // TODO! hack or ...?\n            if (newState.value !== undefined) {\n                matches.push(newState.value);\n            }\n            state = newState;\n        }\n        mergeErrorState(state);\n        return state.ok(matches);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : all,\n        createParserContext(\"all\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>>;\n}\n\nexport function string(str: string) {\n    const string = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n        const s = state.src.slice(state.offset, state.offset + str.length);\n        if (s === str) {\n            return state.ok(s, s.length);\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        string as ParserFunction<string>,\n        createParserContext(\"string\", undefined, str)\n    );\n}\n\nexport function regex(\n    r: RegExp,\n    matchFunction: (match: RegExpMatchArray) => any = (m) => m?.[0]\n) {\n    const flags = r.flags.replace(/y/g, \"\");\n    const sticky = new RegExp(r, flags + \"y\");\n\n    const regex = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n\n        sticky.lastIndex = state.offset;\n        const match = matchFunction(state.src.match(sticky));\n\n        if (match) {\n            return state.ok(match, sticky.lastIndex - state.offset);\n        } else if (match === \"\") {\n            return state.ok(undefined);\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        regex as ParserFunction<string>,\n        createParserContext(\"regex\", undefined, r)\n    );\n}\n\nconst WHITESPACE = /\\s*/y;\nconst trimStateWhitespace = <T>(state: ParserState<T>) => {\n    if (state.offset >= state.src.length) {\n        return state;\n    }\n\n    WHITESPACE.lastIndex = state.offset;\n    const match = state.src.match(WHITESPACE)?.[0] ?? \"\";\n    return state.ok(state.value, match.length);\n};\n\nexport const whitespace = regex(/\\s*/);\nwhitespace.context.name = \"whitespace\";\n"],"names":["module","exports","__defProp","all","exports2","module2","group","doc","regex","string","doc2","whitespace","printer","b","s","lazy","eof","any"],"mappings":"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"}