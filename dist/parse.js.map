{"version":3,"file":"parse.js","sources":["../src/parse/state.ts","../src/parse/index.ts"],"sourcesContent":["import { Parser } from \".\";\n\nexport class ParserState<T> {\n    constructor(\n        public src: string,\n        public value: T = undefined,\n        public offset: number = 0,\n        public isError: boolean = false\n    ) {}\n\n    ok<S>(value: S, offset: number = 0) {\n        return new ParserState<S>(this.src, value, this.offset + offset);\n    }\n\n    err<S>(value?: S, offset: number = 0) {\n        const nextState = this.ok(value, offset);\n        nextState.isError = true;\n        return nextState;\n    }\n\n    from<S>(value: S, offset: number = 0) {\n        return new ParserState<S>(this.src, value, this.offset + offset, this.isError);\n    }\n\n    getColumnNumber(): number {\n        const offset = this.offset;\n        const lastNewline = this.src.lastIndexOf(\"\\n\", offset);\n        const columnNumber = lastNewline === -1 ? offset : offset - (lastNewline + 1);\n\n        return Math.max(0, columnNumber);\n    }\n\n    getLineNumber(): number {\n        const lines = this.src.slice(0, this.offset).split(\"\\n\");\n        const lineNumber = lines.length - 1;\n        return Math.max(0, lineNumber);\n    }\n}\n\nexport const parserNames = [\n    \"string\",\n    \"regex\",\n    \"then\",\n    \"or\",\n    \"chain\",\n    \"map\",\n    \"many\",\n    \"lazy\",\n    \"memoize\",\n    \"mergeMemo\",\n    \"not\",\n    \"skip\",\n    \"next\",\n    \"trim\",\n    \"trimWhitespace\",\n    \"whitespace\",\n    \"wrap\",\n    \"sepBy\",\n    \"any\",\n    \"all\",\n    \"opt\",\n    \"lookAhead\",\n    \"lookBehind\",\n    \"eof\",\n    \"regexConcat\",\n    \"regexWrap\",\n    \"debug\",\n] as const;\n\nexport type ParserContext<T = any> = {\n    name?: (typeof parserNames)[number];\n    parser?: Parser<T>;\n    args?: any[];\n};\n\n// TODO: maybe reintroduce debug check.\nexport function createParserContext<T = any>(\n    name: (typeof parserNames)[number],\n    parser: Parser<T>,\n    ...args: any[]\n) {\n    return {\n        name,\n        parser,\n        args,\n    };\n}\n","import { createParserContext, ParserContext, ParserState } from \"./state\";\n\ntype ExtractValue<T extends ReadonlyArray<Parser<any>>> = {\n    [K in keyof T]: T[K] extends Parser<infer V> ? V : never;\n};\n\ntype ParserFunction<T = string> = (val: ParserState<T>) => ParserState<T>;\n\nlet PARSER_ID = 0;\n\nconst MEMO = new Map<number, ParserState<any>>();\nconst LEFT_RECURSION_COUNTS = new Map<string, number>();\n\nexport function getLazyParser<T>(fn: () => Parser<T>) {\n    if (fn.parser) {\n        return fn.parser;\n    }\n    return (fn.parser = fn());\n}\n\nexport class Parser<T = string> {\n    id: number = PARSER_ID++;\n    constructor(public parser: ParserFunction<T>, public context: ParserContext = {}) {}\n\n    parse(val: string) {\n        MEMO.clear();\n        LEFT_RECURSION_COUNTS.clear();\n        return this.parser(new ParserState(val)).value as T;\n    }\n\n    getCijKey(state: ParserState<T>) {\n        return `${this.id}${state.offset}`;\n    }\n\n    atLeftRecursionLimit(state: ParserState<T>) {\n        const cij = LEFT_RECURSION_COUNTS.get(this.getCijKey(state)) ?? 0;\n        return cij > state.src.length - state.offset;\n    }\n\n    memoize() {\n        const memoize = (state: ParserState<T>) => {\n            const cijKey = this.getCijKey(state);\n            const cij = LEFT_RECURSION_COUNTS.get(cijKey) ?? 0;\n\n            let cached = MEMO.get(this.id);\n\n            if (cached && cached.offset >= state.offset) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            LEFT_RECURSION_COUNTS.set(cijKey, cij + 1);\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n\n            if (cached && cached.offset > newState.offset) {\n                newState.offset = cached.offset;\n            } else if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n\n            return newState;\n        };\n        return new Parser(\n            memoize as ParserFunction<T>,\n            createParserContext(\"memoize\", this)\n        );\n    }\n\n    mergeMemos<S>() {\n        const mergeMemo = (state: ParserState<T>) => {\n            let cached = MEMO.get(this.id);\n            if (cached) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n            if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n            return newState;\n        };\n\n        return new Parser(\n            mergeMemo as ParserFunction<[T, S]>,\n            createParserContext(\"mergeMemo\", this)\n        );\n    }\n\n    then<S>(next: Parser<S | T>) {\n        if (isStringParsers(this, next)) {\n            return concatStringParsers([this, next], \"\", (m) => [m?.[0], m?.[1]]);\n        }\n\n        const then = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = next.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok([nextState1.value, nextState2.value]);\n                }\n            }\n            return state.err(undefined);\n        };\n\n        return new Parser(\n            then as ParserFunction<[T, S]>,\n            createParserContext(\"then\", this, this, next)\n        );\n    }\n\n    or<S>(other: Parser<S | T>) {\n        if (isStringParsers(this, other)) {\n            return concatStringParsers([this, other], \"|\");\n        }\n\n        const or = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (!newState.isError) {\n                return newState;\n            }\n            return other.parser(state);\n        };\n\n        return new Parser(\n            or as ParserFunction<T | S>,\n            createParserContext(\"or\", this, this, other)\n        );\n    }\n\n    chain<S>(fn: (value: T) => Parser<S | T>, chainError: boolean = false) {\n        const chain = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            } else if (newState.value || chainError) {\n                return fn(newState.value).parser(newState);\n            }\n            return state;\n        };\n\n        return new Parser(chain, createParserContext(\"chain\", this, fn));\n    }\n\n    map<S>(fn: (value: T) => S, mapError: boolean = false) {\n        const map = (state: ParserState<T | S>) => {\n            const newState = this.parser(state as ParserState<T>);\n\n            if (!newState.isError || mapError) {\n                return newState.ok(fn(newState.value));\n            }\n            return newState;\n        };\n\n        return new Parser(map as ParserFunction<S>, createParserContext(\"map\", this));\n    }\n\n    mapState<S>(fn: (state: ParserState<T>) => ParserState<S>) {\n        const mapState = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            return fn(newState);\n        };\n\n        return new Parser(\n            mapState as ParserFunction<S>,\n            createParserContext(\"mapState\", this)\n        );\n    }\n\n    skip<S>(parser: Parser<T | S>) {\n        const skip = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = parser.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok(nextState1.value);\n                }\n            }\n            return state.err(undefined);\n        };\n        return new Parser(\n            skip as ParserFunction<T>,\n            createParserContext(\"skip\", this, parser)\n        );\n    }\n\n    next<S>(parser: Parser<S>) {\n        const next = this.then(parser).map(([, b]) => {\n            return b;\n        }) as Parser<S>;\n        next.context = createParserContext(\"next\", this, parser);\n        return next;\n    }\n\n    opt() {\n        const opt = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            if (newState.isError) {\n                return state.ok(undefined);\n            }\n            return newState;\n        };\n        return new Parser(opt as ParserFunction<T>, createParserContext(\"opt\", this));\n    }\n\n    not<S>(parser?: Parser<S>) {\n        const negate = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return state.ok(state.value);\n            } else {\n                return state.err(undefined);\n            }\n        };\n\n        const not = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            } else {\n                const nextState = parser.parser(state);\n                if (nextState.isError) {\n                    return newState;\n                } else {\n                    return state.err(undefined);\n                }\n            }\n        };\n\n        return new Parser(\n            parser ? not : negate,\n            createParserContext(\"not\", this, parser)\n        );\n    }\n\n    wrap<L, R>(start: Parser<L>, end: Parser<R>) {\n        if (isStringParsers(start, this, end)) {\n            return wrapStringParsers(start, this, end);\n        }\n        const wrap = start.next(this).skip(end) as Parser<T>;\n        wrap.context = createParserContext(\"wrap\", this, start, end);\n        return wrap;\n    }\n\n    trim(parser: Parser<T> = whitespace as Parser<T>): Parser<T> {\n        if (parser.context?.name === \"whitespace\") {\n            if (isStringParsers(this, parser)) {\n                return concatStringParsers(\n                    [parser, this, parser],\n                    \"\",\n                    (m) => m?.[2]\n                ) as Parser<T>;\n            }\n\n            const whitespaceTrim = (state: ParserState<T>) => {\n                const newState = trimStateWhitespace(state);\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    return state.err(undefined);\n                } else {\n                    return trimStateWhitespace(tmpState);\n                }\n            };\n\n            return new Parser(\n                whitespaceTrim as ParserFunction<T>,\n                createParserContext(\"trimWhitespace\", this)\n            );\n        }\n\n        return this.wrap(parser, parser) as Parser<T>;\n    }\n\n    many(min: number = 0, max: number = Infinity) {\n        const many = (state: ParserState<T>) => {\n            const matches: T[] = [];\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    break;\n                }\n                matches.push(tmpState.value);\n                newState = tmpState;\n            }\n\n            if (matches.length >= min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            } else {\n                return state.err([]) as ParserState<T[]>;\n            }\n        };\n\n        return new Parser(\n            many as ParserFunction<T[]>,\n            createParserContext(\"many\", this, min, max)\n        );\n    }\n\n    sepBy<S>(sep: Parser<S | T>, min: number = 0, max: number = Infinity) {\n        const sepBy = (state: ParserState<T>) => {\n            const matches: T[] = [];\n\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n                if (tmpState.isError) {\n                    break;\n                }\n                newState = tmpState;\n                matches.push(newState.value);\n\n                const sepState = sep.parser(newState);\n                if (sepState.isError) {\n                    break;\n                }\n                newState = sepState as ParserState<T>;\n            }\n\n            if (matches.length > min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            sepBy as ParserFunction<T[]>,\n            createParserContext(\"sepBy\", this, sep)\n        );\n    }\n\n    eof() {\n        const p = this.skip(eof()) as Parser<T>;\n        p.context = createParserContext(\"eof\", this);\n        return p;\n    }\n\n    toString() {\n        return this.context?.name;\n    }\n\n    static lazy<T>(fn: () => Parser<T>) {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(fn).parser(state);\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, fn));\n    }\n}\n\nfunction isStringParsers(...parsers: Parser<any>[]) {\n    return parsers.every(\n        (p) =>\n            (p.context?.name === \"string\" ||\n                p.context?.name === \"regex\" ||\n                p.context?.name === \"whitespace\") &&\n            p.context?.args\n    );\n}\n\nfunction stringParserValue(p: Parser<any>) {\n    if (p.context?.name === \"string\") {\n        return p.context?.args[0].replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    } else if (p.context?.name === \"regex\" || p.context?.name === \"whitespace\") {\n        return p.context?.args[0].source;\n    }\n}\n\nfunction concatStringParsers(\n    parsers: Parser<any>[],\n    delim: string = \"\",\n    matchFunction?: (m: RegExpMatchArray) => any\n): Parser<string> {\n    const s = parsers.map((s) => `(${stringParserValue(s)})`).join(delim);\n    const r = new RegExp(s);\n    const rP = regex(r, matchFunction);\n\n    if (delim !== \"|\") {\n        rP.context = createParserContext(\"regexConcat\", this, r);\n    }\n    return rP;\n}\n\nfunction wrapStringParsers<L, T, R>(\n    left: Parser<L>,\n    p: Parser<T>,\n    right: Parser<R>\n): Parser<string> {\n    const rP = concatStringParsers([left, p, right], \"\", (m) => {\n        return m?.[2];\n    });\n    rP.context.name = \"regexWrap\";\n    return rP;\n}\n\nexport function eof<T>() {\n    const eof = (state: ParserState<T>) => {\n        if (state.offset >= state.src.length) {\n            return state.ok(undefined);\n        } else {\n            return state.err();\n        }\n    };\n    return new Parser(eof, createParserContext(\"eof\")) as Parser<any>;\n}\n\nexport function lazy<T>(\n    target: any,\n    propertyName: string,\n    descriptor: TypedPropertyDescriptor<() => Parser<T>>\n) {\n    const method = descriptor.value.bind(target)!;\n\n    descriptor.value = function () {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(method).parser(state) as ParserState<T>;\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, method));\n    };\n}\n\nexport function any<T extends any[]>(...parsers: T) {\n    if (isStringParsers(...parsers)) {\n        return concatStringParsers(parsers, \"|\") as Parser<ExtractValue<T>[number]>;\n    }\n\n    const any = (state: ParserState<T>) => {\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n            if (!newState.isError) {\n                return newState;\n            }\n        }\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : any,\n        createParserContext(\"any\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>[number]>;\n}\n\nexport function all<T extends any[]>(...parsers: T) {\n    const all = (state: ParserState<ExtractValue<T>>): ParserState<ExtractValue<T>> => {\n        const matches = [] as any;\n\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            }\n            if (newState.value !== undefined) {\n                matches.push(newState.value);\n            }\n\n            state = newState;\n        }\n        return state.ok(matches);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : all,\n        createParserContext(\"all\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>>;\n}\n\nexport function string(str: string) {\n    const string = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n        const s = state.src.slice(state.offset, state.offset + str.length);\n        if (s === str) {\n            return state.ok(s, s.length);\n        }\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        string as ParserFunction<string>,\n        createParserContext(\"string\", undefined, str)\n    );\n}\n\nexport function regex(\n    r: RegExp,\n    matchFunction: (match: RegExpMatchArray) => any = (m) => m?.[0]\n) {\n    const flags = r.flags.replace(/y/g, \"\");\n    const sticky = new RegExp(r, flags + \"y\");\n\n    const regex = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n\n        sticky.lastIndex = state.offset;\n        const match = matchFunction(state.src.match(sticky));\n\n        if (match) {\n            return state.ok(match, sticky.lastIndex - state.offset);\n        } else if (match === \"\") {\n            return state.ok(undefined);\n        }\n\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        regex as ParserFunction<string>,\n        createParserContext(\"regex\", undefined, r)\n    );\n}\n\nconst WHITESPACE = /\\s*/y;\nconst trimStateWhitespace = <T>(state: ParserState<T>) => {\n    if (state.offset >= state.src.length) {\n        return state;\n    }\n\n    WHITESPACE.lastIndex = state.offset;\n    const match = state.src.match(WHITESPACE)?.[0] ?? \"\";\n    return state.ok(state.value, match.length);\n};\n\nexport const whitespace = regex(/\\s*/);\nwhitespace.context.name = \"whitespace\";\n"],"names":["ParserState","src","value","offset","isError","nextState","lastNewline","columnNumber","lineNumber","createParserContext","name","parser","args","PARSER_ID","MEMO","LEFT_RECURSION_COUNTS","getLazyParser","fn","Parser","context","__publicField","val","state","memoize","cijKey","cij","cached","newState","mergeMemo","next","isStringParsers","concatStringParsers","m","then","nextState1","nextState2","other","or","chainError","chain","mapError","map","mapState","skip","b","opt","negate","not","start","end","wrapStringParsers","wrap","whitespace","_a","whitespaceTrim","trimStateWhitespace","tmpState","min","max","many","matches","i","sep","sepBy","sepState","p","eof","lazy","parsers","_b","_c","_d","stringParserValue","_e","delim","matchFunction","s","r","rP","regex","left","right","target","propertyName","descriptor","method","any","all","string","str","flags","sticky","match","WHITESPACE"],"mappings":"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"}