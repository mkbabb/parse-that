{"version":3,"file":"parse-5b2a50cc.js","sources":["../src/parse/state.ts","../node_modules/prettier/doc.js","../src/parse/debug.ts","../src/parse/parse.ts"],"sourcesContent":["import { Parser } from \"./parse\";\n\nexport class ParserState<T> {\n    constructor(\n        public src: string,\n        public value: T = undefined,\n        public offset: number = 0,\n        public isError: boolean = false,\n        public furthest: number = 0\n    ) {}\n\n    ok<S>(value: S, offset: number = 0) {\n        offset += this.offset;\n        return new ParserState<S>(this.src, value, offset, false);\n    }\n\n    err<S>(value?: S, offset: number = 0) {\n        const nextState = this.ok(value, offset);\n        nextState.isError = true;\n        return nextState;\n    }\n\n    from<S>(value: S, offset: number = 0) {\n        offset += this.offset;\n        return new ParserState<S>(this.src, value, offset, this.isError);\n    }\n\n    getColumnNumber(): number {\n        const offset = this.offset;\n        const lastNewline = this.src.lastIndexOf(\"\\n\", offset);\n        const columnNumber = lastNewline === -1 ? offset : offset - (lastNewline + 1);\n        return Math.max(0, columnNumber);\n    }\n\n    getLineNumber(): number {\n        const newlineIndex = this.src.lastIndexOf(\"\\n\", this.offset);\n        return newlineIndex >= 0\n            ? this.src.slice(0, newlineIndex).split(\"\\n\").length\n            : 0;\n    }\n}\n\nexport const parserNames = [\n    \"string\",\n    \"regex\",\n    \"then\",\n    \"or\",\n    \"chain\",\n    \"map\",\n    \"many\",\n    \"lazy\",\n    \"memoize\",\n    \"mergeMemo\",\n    \"not\",\n    \"skip\",\n    \"next\",\n    \"trim\",\n    \"trimWhitespace\",\n    \"whitespace\",\n    \"wrap\",\n    \"sepBy\",\n    \"any\",\n    \"all\",\n    \"opt\",\n    \"lookAhead\",\n    \"lookBehind\",\n    \"eof\",\n    \"regexConcat\",\n    \"regexWrap\",\n    \"debug\",\n    \"mapState\",\n] as const;\n\nexport type ParserContext<T = any> = {\n    name?: (typeof parserNames)[number];\n    parser?: Parser<T>;\n    args?: any[];\n};\n\n// TODO: maybe reintroduce debug check.\nexport function createParserContext<T = any>(\n    name: (typeof parserNames)[number],\n    parser: Parser<T>,\n    ...args: any[]\n) {\n    return {\n        name,\n        parser,\n        args,\n    };\n}\n","(function (factory) {\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    module.exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else {\n    var root =\n      typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof self !== \"undefined\"\n        ? self\n        : this || {};\n    root.doc = factory();\n  }\n})(function() {\n  \"use strict\";\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\n  // dist/_doc.js.umd.js\n  var require_doc_js_umd = __commonJS({\n    \"dist/_doc.js.umd.js\"(exports, module) {\n      var __create = Object.create;\n      var __defProp = Object.defineProperty;\n      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n      var __getOwnPropNames2 = Object.getOwnPropertyNames;\n      var __getProtoOf = Object.getPrototypeOf;\n      var __hasOwnProp = Object.prototype.hasOwnProperty;\n      var __esm = (fn, res) => function __init() {\n        return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;\n      };\n      var __commonJS2 = (cb, mod) => function __require() {\n        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {\n          exports: {}\n        }).exports, mod), mod.exports;\n      };\n      var __export = (target, all) => {\n        for (var name in all)\n          __defProp(target, name, {\n            get: all[name],\n            enumerable: true\n          });\n      };\n      var __copyProps = (to, from, except, desc) => {\n        if (from && typeof from === \"object\" || typeof from === \"function\") {\n          for (let key of __getOwnPropNames2(from))\n            if (!__hasOwnProp.call(to, key) && key !== except)\n              __defProp(to, key, {\n                get: () => from[key],\n                enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n              });\n        }\n        return to;\n      };\n      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n      }) : target, mod));\n      var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", {\n        value: true\n      }), mod);\n      var init_define_process = __esm({\n        \"<define:process>\"() {\n        }\n      });\n      var require_doc_builders = __commonJS2({\n        \"src/document/doc-builders.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function concat(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"concat\",\n              parts\n            };\n          }\n          function indent(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"indent\",\n              contents\n            };\n          }\n          function align(widthOrString, contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"align\",\n              contents,\n              n: widthOrString\n            };\n          }\n          function group(contents) {\n            let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"group\",\n              id: opts.id,\n              contents,\n              break: Boolean(opts.shouldBreak),\n              expandedStates: opts.expandedStates\n            };\n          }\n          function dedentToRoot(contents) {\n            return align(Number.NEGATIVE_INFINITY, contents);\n          }\n          function markAsRoot(contents) {\n            return align({\n              type: \"root\"\n            }, contents);\n          }\n          function dedent(contents) {\n            return align(-1, contents);\n          }\n          function conditionalGroup(states, opts) {\n            return group(states[0], Object.assign(Object.assign({}, opts), {}, {\n              expandedStates: states\n            }));\n          }\n          function fill(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"fill\",\n              parts\n            };\n          }\n          function ifBreak(breakContents, flatContents) {\n            let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (false) {\n              if (breakContents) {\n                assertDoc(breakContents);\n              }\n              if (flatContents) {\n                assertDoc(flatContents);\n              }\n            }\n            return {\n              type: \"if-break\",\n              breakContents,\n              flatContents,\n              groupId: opts.groupId\n            };\n          }\n          function indentIfBreak(contents, opts) {\n            return {\n              type: \"indent-if-break\",\n              contents,\n              groupId: opts.groupId,\n              negate: opts.negate\n            };\n          }\n          function lineSuffix(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"line-suffix\",\n              contents\n            };\n          }\n          var lineSuffixBoundary = {\n            type: \"line-suffix-boundary\"\n          };\n          var breakParent = {\n            type: \"break-parent\"\n          };\n          var trim = {\n            type: \"trim\"\n          };\n          var hardlineWithoutBreakParent = {\n            type: \"line\",\n            hard: true\n          };\n          var literallineWithoutBreakParent = {\n            type: \"line\",\n            hard: true,\n            literal: true\n          };\n          var line = {\n            type: \"line\"\n          };\n          var softline = {\n            type: \"line\",\n            soft: true\n          };\n          var hardline = concat([hardlineWithoutBreakParent, breakParent]);\n          var literalline = concat([literallineWithoutBreakParent, breakParent]);\n          var cursor = {\n            type: \"cursor\",\n            placeholder: Symbol(\"cursor\")\n          };\n          function join(sep, arr) {\n            const res = [];\n            for (let i = 0; i < arr.length; i++) {\n              if (i !== 0) {\n                res.push(sep);\n              }\n              res.push(arr[i]);\n            }\n            return concat(res);\n          }\n          function addAlignmentToDoc(doc, size, tabWidth) {\n            let aligned = doc;\n            if (size > 0) {\n              for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n                aligned = indent(aligned);\n              }\n              aligned = align(size % tabWidth, aligned);\n              aligned = align(Number.NEGATIVE_INFINITY, aligned);\n            }\n            return aligned;\n          }\n          function label(label2, contents) {\n            return {\n              type: \"label\",\n              label: label2,\n              contents\n            };\n          }\n          module2.exports = {\n            concat,\n            join,\n            line,\n            softline,\n            hardline,\n            literalline,\n            group,\n            conditionalGroup,\n            fill,\n            lineSuffix,\n            lineSuffixBoundary,\n            cursor,\n            breakParent,\n            ifBreak,\n            trim,\n            indent,\n            indentIfBreak,\n            align,\n            addAlignmentToDoc,\n            markAsRoot,\n            dedentToRoot,\n            dedent,\n            hardlineWithoutBreakParent,\n            literallineWithoutBreakParent,\n            label\n          };\n        }\n      });\n      var require_end_of_line = __commonJS2({\n        \"src/common/end-of-line.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function guessEndOfLine(text) {\n            const index = text.indexOf(\"\\r\");\n            if (index >= 0) {\n              return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n            }\n            return \"lf\";\n          }\n          function convertEndOfLineToChars(value) {\n            switch (value) {\n              case \"cr\":\n                return \"\\r\";\n              case \"crlf\":\n                return \"\\r\\n\";\n              default:\n                return \"\\n\";\n            }\n          }\n          function countEndOfLineChars(text, eol) {\n            let regex;\n            switch (eol) {\n              case \"\\n\":\n                regex = /\\n/g;\n                break;\n              case \"\\r\":\n                regex = /\\r/g;\n                break;\n              case \"\\r\\n\":\n                regex = /\\r\\n/g;\n                break;\n              default:\n                throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);\n            }\n            const endOfLines = text.match(regex);\n            return endOfLines ? endOfLines.length : 0;\n          }\n          function normalizeEndOfLine(text) {\n            return text.replace(/\\r\\n?/g, \"\\n\");\n          }\n          module2.exports = {\n            guessEndOfLine,\n            convertEndOfLineToChars,\n            countEndOfLineChars,\n            normalizeEndOfLine\n          };\n        }\n      });\n      var require_get_last = __commonJS2({\n        \"src/utils/get-last.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = (arr) => arr[arr.length - 1];\n          module2.exports = getLast;\n        }\n      });\n      function ansiRegex() {\n        let {\n          onlyFirst = false\n        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const pattern = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n        return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n      }\n      var init_ansi_regex = __esm({\n        \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n          init_define_process();\n        }\n      });\n      function stripAnsi(string) {\n        if (typeof string !== \"string\") {\n          throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string}\\``);\n        }\n        return string.replace(ansiRegex(), \"\");\n      }\n      var init_strip_ansi = __esm({\n        \"node_modules/strip-ansi/index.js\"() {\n          init_define_process();\n          init_ansi_regex();\n        }\n      });\n      function isFullwidthCodePoint(codePoint) {\n        if (!Number.isInteger(codePoint)) {\n          return false;\n        }\n        return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);\n      }\n      var init_is_fullwidth_code_point = __esm({\n        \"node_modules/is-fullwidth-code-point/index.js\"() {\n          init_define_process();\n        }\n      });\n      var require_emoji_regex = __commonJS2({\n        \"node_modules/emoji-regex/index.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          module2.exports = function() {\n            return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n          };\n        }\n      });\n      var string_width_exports = {};\n      __export(string_width_exports, {\n        default: () => stringWidth\n      });\n      function stringWidth(string) {\n        if (typeof string !== \"string\" || string.length === 0) {\n          return 0;\n        }\n        string = stripAnsi(string);\n        if (string.length === 0) {\n          return 0;\n        }\n        string = string.replace((0, import_emoji_regex.default)(), \"  \");\n        let width = 0;\n        for (let index = 0; index < string.length; index++) {\n          const codePoint = string.codePointAt(index);\n          if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n            continue;\n          }\n          if (codePoint >= 768 && codePoint <= 879) {\n            continue;\n          }\n          if (codePoint > 65535) {\n            index++;\n          }\n          width += isFullwidthCodePoint(codePoint) ? 2 : 1;\n        }\n        return width;\n      }\n      var import_emoji_regex;\n      var init_string_width = __esm({\n        \"node_modules/string-width/index.js\"() {\n          init_define_process();\n          init_strip_ansi();\n          init_is_fullwidth_code_point();\n          import_emoji_regex = __toESM(require_emoji_regex());\n        }\n      });\n      var require_get_string_width = __commonJS2({\n        \"src/utils/get-string-width.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var stringWidth2 = (init_string_width(), __toCommonJS(string_width_exports)).default;\n          var notAsciiRegex = /[^\\x20-\\x7F]/;\n          function getStringWidth(text) {\n            if (!text) {\n              return 0;\n            }\n            if (!notAsciiRegex.test(text)) {\n              return text.length;\n            }\n            return stringWidth2(text);\n          }\n          module2.exports = getStringWidth;\n        }\n      });\n      var require_doc_utils = __commonJS2({\n        \"src/document/doc-utils.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = require_get_last();\n          var {\n            literalline,\n            join\n          } = require_doc_builders();\n          var isConcat = (doc) => Array.isArray(doc) || doc && doc.type === \"concat\";\n          var getDocParts = (doc) => {\n            if (Array.isArray(doc)) {\n              return doc;\n            }\n            if (doc.type !== \"concat\" && doc.type !== \"fill\") {\n              throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n            }\n            return doc.parts;\n          };\n          var traverseDocOnExitStackMarker = {};\n          function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n            const docsStack = [doc];\n            while (docsStack.length > 0) {\n              const doc2 = docsStack.pop();\n              if (doc2 === traverseDocOnExitStackMarker) {\n                onExit(docsStack.pop());\n                continue;\n              }\n              if (onExit) {\n                docsStack.push(doc2, traverseDocOnExitStackMarker);\n              }\n              if (!onEnter || onEnter(doc2) !== false) {\n                if (isConcat(doc2) || doc2.type === \"fill\") {\n                  const parts = getDocParts(doc2);\n                  for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n                    docsStack.push(parts[i]);\n                  }\n                } else if (doc2.type === \"if-break\") {\n                  if (doc2.flatContents) {\n                    docsStack.push(doc2.flatContents);\n                  }\n                  if (doc2.breakContents) {\n                    docsStack.push(doc2.breakContents);\n                  }\n                } else if (doc2.type === \"group\" && doc2.expandedStates) {\n                  if (shouldTraverseConditionalGroups) {\n                    for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n                      docsStack.push(doc2.expandedStates[i]);\n                    }\n                  } else {\n                    docsStack.push(doc2.contents);\n                  }\n                } else if (doc2.contents) {\n                  docsStack.push(doc2.contents);\n                }\n              }\n            }\n          }\n          function mapDoc(doc, cb) {\n            const mapped = /* @__PURE__ */ new Map();\n            return rec(doc);\n            function rec(doc2) {\n              if (mapped.has(doc2)) {\n                return mapped.get(doc2);\n              }\n              const result = process2(doc2);\n              mapped.set(doc2, result);\n              return result;\n            }\n            function process2(doc2) {\n              if (Array.isArray(doc2)) {\n                return cb(doc2.map(rec));\n              }\n              if (doc2.type === \"concat\" || doc2.type === \"fill\") {\n                const parts = doc2.parts.map(rec);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  parts\n                }));\n              }\n              if (doc2.type === \"if-break\") {\n                const breakContents = doc2.breakContents && rec(doc2.breakContents);\n                const flatContents = doc2.flatContents && rec(doc2.flatContents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  breakContents,\n                  flatContents\n                }));\n              }\n              if (doc2.type === \"group\" && doc2.expandedStates) {\n                const expandedStates = doc2.expandedStates.map(rec);\n                const contents = expandedStates[0];\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents,\n                  expandedStates\n                }));\n              }\n              if (doc2.contents) {\n                const contents = rec(doc2.contents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents\n                }));\n              }\n              return cb(doc2);\n            }\n          }\n          function findInDoc(doc, fn, defaultValue) {\n            let result = defaultValue;\n            let hasStopped = false;\n            function findInDocOnEnterFn(doc2) {\n              const maybeResult = fn(doc2);\n              if (maybeResult !== void 0) {\n                hasStopped = true;\n                result = maybeResult;\n              }\n              if (hasStopped) {\n                return false;\n              }\n            }\n            traverseDoc(doc, findInDocOnEnterFn);\n            return result;\n          }\n          function willBreakFn(doc) {\n            if (doc.type === \"group\" && doc.break) {\n              return true;\n            }\n            if (doc.type === \"line\" && doc.hard) {\n              return true;\n            }\n            if (doc.type === \"break-parent\") {\n              return true;\n            }\n          }\n          function willBreak(doc) {\n            return findInDoc(doc, willBreakFn, false);\n          }\n          function breakParentGroup(groupStack) {\n            if (groupStack.length > 0) {\n              const parentGroup = getLast(groupStack);\n              if (!parentGroup.expandedStates && !parentGroup.break) {\n                parentGroup.break = \"propagated\";\n              }\n            }\n            return null;\n          }\n          function propagateBreaks(doc) {\n            const alreadyVisitedSet = /* @__PURE__ */ new Set();\n            const groupStack = [];\n            function propagateBreaksOnEnterFn(doc2) {\n              if (doc2.type === \"break-parent\") {\n                breakParentGroup(groupStack);\n              }\n              if (doc2.type === \"group\") {\n                groupStack.push(doc2);\n                if (alreadyVisitedSet.has(doc2)) {\n                  return false;\n                }\n                alreadyVisitedSet.add(doc2);\n              }\n            }\n            function propagateBreaksOnExitFn(doc2) {\n              if (doc2.type === \"group\") {\n                const group = groupStack.pop();\n                if (group.break) {\n                  breakParentGroup(groupStack);\n                }\n              }\n            }\n            traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);\n          }\n          function removeLinesFn(doc) {\n            if (doc.type === \"line\" && !doc.hard) {\n              return doc.soft ? \"\" : \" \";\n            }\n            if (doc.type === \"if-break\") {\n              return doc.flatContents || \"\";\n            }\n            return doc;\n          }\n          function removeLines(doc) {\n            return mapDoc(doc, removeLinesFn);\n          }\n          var isHardline = (doc, nextDoc) => doc && doc.type === \"line\" && doc.hard && nextDoc && nextDoc.type === \"break-parent\";\n          function stripDocTrailingHardlineFromDoc(doc) {\n            if (!doc) {\n              return doc;\n            }\n            if (isConcat(doc) || doc.type === \"fill\") {\n              const parts = getDocParts(doc);\n              while (parts.length > 1 && isHardline(...parts.slice(-2))) {\n                parts.length -= 2;\n              }\n              if (parts.length > 0) {\n                const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));\n                parts[parts.length - 1] = lastPart;\n              }\n              return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n                parts\n              });\n            }\n            switch (doc.type) {\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"group\":\n              case \"line-suffix\":\n              case \"label\": {\n                const contents = stripDocTrailingHardlineFromDoc(doc.contents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  contents\n                });\n              }\n              case \"if-break\": {\n                const breakContents = stripDocTrailingHardlineFromDoc(doc.breakContents);\n                const flatContents = stripDocTrailingHardlineFromDoc(doc.flatContents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  breakContents,\n                  flatContents\n                });\n              }\n            }\n            return doc;\n          }\n          function stripTrailingHardline(doc) {\n            return stripDocTrailingHardlineFromDoc(cleanDoc(doc));\n          }\n          function cleanDocFn(doc) {\n            switch (doc.type) {\n              case \"fill\":\n                if (doc.parts.every((part) => part === \"\")) {\n                  return \"\";\n                }\n                break;\n              case \"group\":\n                if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n                  return \"\";\n                }\n                if (doc.contents.type === \"group\" && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n                  return doc.contents;\n                }\n                break;\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"line-suffix\":\n                if (!doc.contents) {\n                  return \"\";\n                }\n                break;\n              case \"if-break\":\n                if (!doc.flatContents && !doc.breakContents) {\n                  return \"\";\n                }\n                break;\n            }\n            if (!isConcat(doc)) {\n              return doc;\n            }\n            const parts = [];\n            for (const part of getDocParts(doc)) {\n              if (!part) {\n                continue;\n              }\n              const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];\n              if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {\n                parts[parts.length - 1] += currentPart;\n              } else {\n                parts.push(currentPart);\n              }\n              parts.push(...restParts);\n            }\n            if (parts.length === 0) {\n              return \"\";\n            }\n            if (parts.length === 1) {\n              return parts[0];\n            }\n            return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n              parts\n            });\n          }\n          function cleanDoc(doc) {\n            return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n          }\n          function normalizeParts(parts) {\n            const newParts = [];\n            const restParts = parts.filter(Boolean);\n            while (restParts.length > 0) {\n              const part = restParts.shift();\n              if (!part) {\n                continue;\n              }\n              if (isConcat(part)) {\n                restParts.unshift(...getDocParts(part));\n                continue;\n              }\n              if (newParts.length > 0 && typeof getLast(newParts) === \"string\" && typeof part === \"string\") {\n                newParts[newParts.length - 1] += part;\n                continue;\n              }\n              newParts.push(part);\n            }\n            return newParts;\n          }\n          function normalizeDoc(doc) {\n            return mapDoc(doc, (currentDoc) => {\n              if (Array.isArray(currentDoc)) {\n                return normalizeParts(currentDoc);\n              }\n              if (!currentDoc.parts) {\n                return currentDoc;\n              }\n              return Object.assign(Object.assign({}, currentDoc), {}, {\n                parts: normalizeParts(currentDoc.parts)\n              });\n            });\n          }\n          function replaceEndOfLine(doc) {\n            return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? replaceTextEndOfLine(currentDoc) : currentDoc);\n          }\n          function replaceTextEndOfLine(text) {\n            let replacement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : literalline;\n            return join(replacement, text.split(\"\\n\")).parts;\n          }\n          function canBreakFn(doc) {\n            if (doc.type === \"line\") {\n              return true;\n            }\n          }\n          function canBreak(doc) {\n            return findInDoc(doc, canBreakFn, false);\n          }\n          module2.exports = {\n            isConcat,\n            getDocParts,\n            willBreak,\n            traverseDoc,\n            findInDoc,\n            mapDoc,\n            propagateBreaks,\n            removeLines,\n            stripTrailingHardline,\n            normalizeParts,\n            normalizeDoc,\n            cleanDoc,\n            replaceTextEndOfLine,\n            replaceEndOfLine,\n            canBreak\n          };\n        }\n      });\n      var require_doc_printer = __commonJS2({\n        \"src/document/doc-printer.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            convertEndOfLineToChars\n          } = require_end_of_line();\n          var getLast = require_get_last();\n          var getStringWidth = require_get_string_width();\n          var {\n            fill,\n            cursor,\n            indent\n          } = require_doc_builders();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          var groupModeMap;\n          var MODE_BREAK = 1;\n          var MODE_FLAT = 2;\n          function rootIndent() {\n            return {\n              value: \"\",\n              length: 0,\n              queue: []\n            };\n          }\n          function makeIndent(ind, options) {\n            return generateInd(ind, {\n              type: \"indent\"\n            }, options);\n          }\n          function makeAlign(indent2, widthOrDoc, options) {\n            if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n              return indent2.root || rootIndent();\n            }\n            if (widthOrDoc < 0) {\n              return generateInd(indent2, {\n                type: \"dedent\"\n              }, options);\n            }\n            if (!widthOrDoc) {\n              return indent2;\n            }\n            if (widthOrDoc.type === \"root\") {\n              return Object.assign(Object.assign({}, indent2), {}, {\n                root: indent2\n              });\n            }\n            const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n            return generateInd(indent2, {\n              type: alignType,\n              n: widthOrDoc\n            }, options);\n          }\n          function generateInd(ind, newPart, options) {\n            const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n            let value = \"\";\n            let length = 0;\n            let lastTabs = 0;\n            let lastSpaces = 0;\n            for (const part of queue) {\n              switch (part.type) {\n                case \"indent\":\n                  flush();\n                  if (options.useTabs) {\n                    addTabs(1);\n                  } else {\n                    addSpaces(options.tabWidth);\n                  }\n                  break;\n                case \"stringAlign\":\n                  flush();\n                  value += part.n;\n                  length += part.n.length;\n                  break;\n                case \"numberAlign\":\n                  lastTabs += 1;\n                  lastSpaces += part.n;\n                  break;\n                default:\n                  throw new Error(`Unexpected type '${part.type}'`);\n              }\n            }\n            flushSpaces();\n            return Object.assign(Object.assign({}, ind), {}, {\n              value,\n              length,\n              queue\n            });\n            function addTabs(count) {\n              value += \"\t\".repeat(count);\n              length += options.tabWidth * count;\n            }\n            function addSpaces(count) {\n              value += \" \".repeat(count);\n              length += count;\n            }\n            function flush() {\n              if (options.useTabs) {\n                flushTabs();\n              } else {\n                flushSpaces();\n              }\n            }\n            function flushTabs() {\n              if (lastTabs > 0) {\n                addTabs(lastTabs);\n              }\n              resetLast();\n            }\n            function flushSpaces() {\n              if (lastSpaces > 0) {\n                addSpaces(lastSpaces);\n              }\n              resetLast();\n            }\n            function resetLast() {\n              lastTabs = 0;\n              lastSpaces = 0;\n            }\n          }\n          function trim(out) {\n            if (out.length === 0) {\n              return 0;\n            }\n            let trimCount = 0;\n            while (out.length > 0 && typeof getLast(out) === \"string\" && /^[\\t ]*$/.test(getLast(out))) {\n              trimCount += out.pop().length;\n            }\n            if (out.length > 0 && typeof getLast(out) === \"string\") {\n              const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");\n              trimCount += getLast(out).length - trimmed.length;\n              out[out.length - 1] = trimmed;\n            }\n            return trimCount;\n          }\n          function fits(next, restCommands, width, hasLineSuffix, mustBeFlat) {\n            let restIdx = restCommands.length;\n            const cmds = [next];\n            const out = [];\n            while (width >= 0) {\n              if (cmds.length === 0) {\n                if (restIdx === 0) {\n                  return true;\n                }\n                cmds.push(restCommands[--restIdx]);\n                continue;\n              }\n              const {\n                mode,\n                doc\n              } = cmds.pop();\n              if (typeof doc === \"string\") {\n                out.push(doc);\n                width -= getStringWidth(doc);\n              } else if (isConcat(doc) || doc.type === \"fill\") {\n                const parts = getDocParts(doc);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc.type) {\n                  case \"indent\":\n                  case \"align\":\n                  case \"indent-if-break\":\n                  case \"label\":\n                    cmds.push({\n                      mode,\n                      doc: doc.contents\n                    });\n                    break;\n                  case \"trim\":\n                    width += trim(out);\n                    break;\n                  case \"group\": {\n                    if (mustBeFlat && doc.break) {\n                      return false;\n                    }\n                    const groupMode = doc.break ? MODE_BREAK : mode;\n                    const contents = doc.expandedStates && groupMode === MODE_BREAK ? getLast(doc.expandedStates) : doc.contents;\n                    cmds.push({\n                      mode: groupMode,\n                      doc: contents\n                    });\n                    break;\n                  }\n                  case \"if-break\": {\n                    const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n                    const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n                    if (contents) {\n                      cmds.push({\n                        mode,\n                        doc: contents\n                      });\n                    }\n                    break;\n                  }\n                  case \"line\":\n                    if (mode === MODE_BREAK || doc.hard) {\n                      return true;\n                    }\n                    if (!doc.soft) {\n                      out.push(\" \");\n                      width--;\n                    }\n                    break;\n                  case \"line-suffix\":\n                    hasLineSuffix = true;\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (hasLineSuffix) {\n                      return false;\n                    }\n                    break;\n                }\n              }\n            }\n            return false;\n          }\n          function printDocToString(doc, options) {\n            groupModeMap = {};\n            const width = options.printWidth;\n            const newLine = convertEndOfLineToChars(options.endOfLine);\n            let pos = 0;\n            const cmds = [{\n              ind: rootIndent(),\n              mode: MODE_BREAK,\n              doc\n            }];\n            const out = [];\n            let shouldRemeasure = false;\n            const lineSuffix = [];\n            while (cmds.length > 0) {\n              const {\n                ind,\n                mode,\n                doc: doc2\n              } = cmds.pop();\n              if (typeof doc2 === \"string\") {\n                const formatted = newLine !== \"\\n\" ? doc2.replace(/\\n/g, newLine) : doc2;\n                out.push(formatted);\n                pos += getStringWidth(formatted);\n              } else if (isConcat(doc2)) {\n                const parts = getDocParts(doc2);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    ind,\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc2.type) {\n                  case \"cursor\":\n                    out.push(cursor.placeholder);\n                    break;\n                  case \"indent\":\n                    cmds.push({\n                      ind: makeIndent(ind, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"align\":\n                    cmds.push({\n                      ind: makeAlign(ind, doc2.n, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"trim\":\n                    pos -= trim(out);\n                    break;\n                  case \"group\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!shouldRemeasure) {\n                          cmds.push({\n                            ind,\n                            mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                            doc: doc2.contents\n                          });\n                          break;\n                        }\n                      case MODE_BREAK: {\n                        shouldRemeasure = false;\n                        const next = {\n                          ind,\n                          mode: MODE_FLAT,\n                          doc: doc2.contents\n                        };\n                        const rem = width - pos;\n                        const hasLineSuffix = lineSuffix.length > 0;\n                        if (!doc2.break && fits(next, cmds, rem, hasLineSuffix)) {\n                          cmds.push(next);\n                        } else {\n                          if (doc2.expandedStates) {\n                            const mostExpanded = getLast(doc2.expandedStates);\n                            if (doc2.break) {\n                              cmds.push({\n                                ind,\n                                mode: MODE_BREAK,\n                                doc: mostExpanded\n                              });\n                              break;\n                            } else {\n                              for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                                if (i >= doc2.expandedStates.length) {\n                                  cmds.push({\n                                    ind,\n                                    mode: MODE_BREAK,\n                                    doc: mostExpanded\n                                  });\n                                  break;\n                                } else {\n                                  const state = doc2.expandedStates[i];\n                                  const cmd = {\n                                    ind,\n                                    mode: MODE_FLAT,\n                                    doc: state\n                                  };\n                                  if (fits(cmd, cmds, rem, hasLineSuffix)) {\n                                    cmds.push(cmd);\n                                    break;\n                                  }\n                                }\n                              }\n                            }\n                          } else {\n                            cmds.push({\n                              ind,\n                              mode: MODE_BREAK,\n                              doc: doc2.contents\n                            });\n                          }\n                        }\n                        break;\n                      }\n                    }\n                    if (doc2.id) {\n                      groupModeMap[doc2.id] = getLast(cmds).mode;\n                    }\n                    break;\n                  case \"fill\": {\n                    const rem = width - pos;\n                    const {\n                      parts\n                    } = doc2;\n                    if (parts.length === 0) {\n                      break;\n                    }\n                    const [content, whitespace] = parts;\n                    const contentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: content\n                    };\n                    const contentBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: content\n                    };\n                    const contentFits = fits(contentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (parts.length === 1) {\n                      if (contentFits) {\n                        cmds.push(contentFlatCmd);\n                      } else {\n                        cmds.push(contentBreakCmd);\n                      }\n                      break;\n                    }\n                    const whitespaceFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: whitespace\n                    };\n                    const whitespaceBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: whitespace\n                    };\n                    if (parts.length === 2) {\n                      if (contentFits) {\n                        cmds.push(whitespaceFlatCmd, contentFlatCmd);\n                      } else {\n                        cmds.push(whitespaceBreakCmd, contentBreakCmd);\n                      }\n                      break;\n                    }\n                    parts.splice(0, 2);\n                    const remainingCmd = {\n                      ind,\n                      mode,\n                      doc: fill(parts)\n                    };\n                    const secondContent = parts[0];\n                    const firstAndSecondContentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: [content, whitespace, secondContent]\n                    };\n                    const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (firstAndSecondContentFits) {\n                      cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n                    } else if (contentFits) {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n                    } else {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n                    }\n                    break;\n                  }\n                  case \"if-break\":\n                  case \"indent-if-break\": {\n                    const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n                    if (groupMode === MODE_BREAK) {\n                      const breakContents = doc2.type === \"if-break\" ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n                      if (breakContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: breakContents\n                        });\n                      }\n                    }\n                    if (groupMode === MODE_FLAT) {\n                      const flatContents = doc2.type === \"if-break\" ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n                      if (flatContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: flatContents\n                        });\n                      }\n                    }\n                    break;\n                  }\n                  case \"line-suffix\":\n                    lineSuffix.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (lineSuffix.length > 0) {\n                      cmds.push({\n                        ind,\n                        mode,\n                        doc: {\n                          type: \"line\",\n                          hard: true\n                        }\n                      });\n                    }\n                    break;\n                  case \"line\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!doc2.hard) {\n                          if (!doc2.soft) {\n                            out.push(\" \");\n                            pos += 1;\n                          }\n                          break;\n                        } else {\n                          shouldRemeasure = true;\n                        }\n                      case MODE_BREAK:\n                        if (lineSuffix.length > 0) {\n                          cmds.push({\n                            ind,\n                            mode,\n                            doc: doc2\n                          }, ...lineSuffix.reverse());\n                          lineSuffix.length = 0;\n                          break;\n                        }\n                        if (doc2.literal) {\n                          if (ind.root) {\n                            out.push(newLine, ind.root.value);\n                            pos = ind.root.length;\n                          } else {\n                            out.push(newLine);\n                            pos = 0;\n                          }\n                        } else {\n                          pos -= trim(out);\n                          out.push(newLine + ind.value);\n                          pos = ind.length;\n                        }\n                        break;\n                    }\n                    break;\n                  case \"label\":\n                    cmds.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  default:\n                }\n              }\n              if (cmds.length === 0 && lineSuffix.length > 0) {\n                cmds.push(...lineSuffix.reverse());\n                lineSuffix.length = 0;\n              }\n            }\n            const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n            if (cursorPlaceholderIndex !== -1) {\n              const otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n              const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n              const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n              const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n              return {\n                formatted: beforeCursor + aroundCursor + afterCursor,\n                cursorNodeStart: beforeCursor.length,\n                cursorNodeText: aroundCursor\n              };\n            }\n            return {\n              formatted: out.join(\"\")\n            };\n          }\n          module2.exports = {\n            printDocToString\n          };\n        }\n      });\n      var require_doc_debug = __commonJS2({\n        \"src/document/doc-debug.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          function flattenDoc(doc) {\n            if (!doc) {\n              return \"\";\n            }\n            if (isConcat(doc)) {\n              const res = [];\n              for (const part of getDocParts(doc)) {\n                if (isConcat(part)) {\n                  res.push(...flattenDoc(part).parts);\n                } else {\n                  const flattened = flattenDoc(part);\n                  if (flattened !== \"\") {\n                    res.push(flattened);\n                  }\n                }\n              }\n              return {\n                type: \"concat\",\n                parts: res\n              };\n            }\n            if (doc.type === \"if-break\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                breakContents: flattenDoc(doc.breakContents),\n                flatContents: flattenDoc(doc.flatContents)\n              });\n            }\n            if (doc.type === \"group\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents),\n                expandedStates: doc.expandedStates && doc.expandedStates.map(flattenDoc)\n              });\n            }\n            if (doc.type === \"fill\") {\n              return {\n                type: \"fill\",\n                parts: doc.parts.map(flattenDoc)\n              };\n            }\n            if (doc.contents) {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents)\n              });\n            }\n            return doc;\n          }\n          function printDocToDebug(doc) {\n            const printedSymbols = /* @__PURE__ */ Object.create(null);\n            const usedKeysForSymbols = /* @__PURE__ */ new Set();\n            return printDoc(flattenDoc(doc));\n            function printDoc(doc2, index, parentParts) {\n              if (typeof doc2 === \"string\") {\n                return JSON.stringify(doc2);\n              }\n              if (isConcat(doc2)) {\n                const printed = getDocParts(doc2).map(printDoc).filter(Boolean);\n                return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;\n              }\n              if (doc2.type === \"line\") {\n                const withBreakParent = Array.isArray(parentParts) && parentParts[index + 1] && parentParts[index + 1].type === \"break-parent\";\n                if (doc2.literal) {\n                  return withBreakParent ? \"literalline\" : \"literallineWithoutBreakParent\";\n                }\n                if (doc2.hard) {\n                  return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";\n                }\n                if (doc2.soft) {\n                  return \"softline\";\n                }\n                return \"line\";\n              }\n              if (doc2.type === \"break-parent\") {\n                const afterHardline = Array.isArray(parentParts) && parentParts[index - 1] && parentParts[index - 1].type === \"line\" && parentParts[index - 1].hard;\n                return afterHardline ? void 0 : \"breakParent\";\n              }\n              if (doc2.type === \"trim\") {\n                return \"trim\";\n              }\n              if (doc2.type === \"indent\") {\n                return \"indent(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"align\") {\n                return doc2.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + printDoc(doc2.contents) + \")\" : doc2.n < 0 ? \"dedent(\" + printDoc(doc2.contents) + \")\" : doc2.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc2.contents) + \")\" : \"align(\" + JSON.stringify(doc2.n) + \", \" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"if-break\") {\n                return \"ifBreak(\" + printDoc(doc2.breakContents) + (doc2.flatContents ? \", \" + printDoc(doc2.flatContents) : \"\") + (doc2.groupId ? (!doc2.flatContents ? ', \"\"' : \"\") + `, { groupId: ${printGroupId(doc2.groupId)} }` : \"\") + \")\";\n              }\n              if (doc2.type === \"indent-if-break\") {\n                const optionsParts = [];\n                if (doc2.negate) {\n                  optionsParts.push(\"negate: true\");\n                }\n                if (doc2.groupId) {\n                  optionsParts.push(`groupId: ${printGroupId(doc2.groupId)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                return `indentIfBreak(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"group\") {\n                const optionsParts = [];\n                if (doc2.break && doc2.break !== \"propagated\") {\n                  optionsParts.push(\"shouldBreak: true\");\n                }\n                if (doc2.id) {\n                  optionsParts.push(`id: ${printGroupId(doc2.id)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                if (doc2.expandedStates) {\n                  return `conditionalGroup([${doc2.expandedStates.map((part) => printDoc(part)).join(\",\")}]${options})`;\n                }\n                return `group(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"fill\") {\n                return `fill([${doc2.parts.map((part) => printDoc(part)).join(\", \")}])`;\n              }\n              if (doc2.type === \"line-suffix\") {\n                return \"lineSuffix(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"line-suffix-boundary\") {\n                return \"lineSuffixBoundary\";\n              }\n              if (doc2.type === \"label\") {\n                return `label(${JSON.stringify(doc2.label)}, ${printDoc(doc2.contents)})`;\n              }\n              throw new Error(\"Unknown doc type \" + doc2.type);\n            }\n            function printGroupId(id) {\n              if (typeof id !== \"symbol\") {\n                return JSON.stringify(String(id));\n              }\n              if (id in printedSymbols) {\n                return printedSymbols[id];\n              }\n              const prefix = String(id).slice(7, -1) || \"symbol\";\n              for (let counter = 0; ; counter++) {\n                const key = prefix + (counter > 0 ? ` #${counter}` : \"\");\n                if (!usedKeysForSymbols.has(key)) {\n                  usedKeysForSymbols.add(key);\n                  return printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`;\n                }\n              }\n            }\n          }\n          module2.exports = {\n            printDocToDebug\n          };\n        }\n      });\n      init_define_process();\n      module.exports = {\n        builders: require_doc_builders(),\n        printer: require_doc_printer(),\n        utils: require_doc_utils(),\n        debug: require_doc_debug()\n      };\n    }\n  });\n  return require_doc_js_umd();\n});","import { createParserContext, ParserState } from \"./state\";\nimport { getLazyParser, Parser, lastState } from \"./parse\";\n\nimport { Options, RequiredOptions } from \"prettier\";\nimport { Doc } from \"prettier\";\nimport { builders as b, printer } from \"prettier/doc\";\nimport chalk from \"chalk\";\n\nconst MAX_LINES = 4;\nconst MAX_LINE_LENGTH = 80;\n\nconst defaultGroupOptions = {};\n\nconst defaultOptions = {\n    printWidth: 30,\n    tabWidth: 4,\n    useTabs: false,\n} as RequiredOptions;\n\nexport function prettierPrint(doc: Doc) {\n    return printer.printDocToString(doc, defaultOptions).formatted;\n}\n\nexport const summarizeLine = (line: string, maxLength: number = MAX_LINE_LENGTH) => {\n    const newLine = line.indexOf(\"\\n\");\n    const length = Math.min(line.length, newLine === -1 ? line.length : newLine);\n\n    if (length <= MAX_LINE_LENGTH) {\n        return line;\n    } else {\n        return line.slice(0, maxLength) + \"...\";\n    }\n};\n\nexport function addCursor(\n    state: ParserState<any>,\n    cursor: string = \"^\",\n    error: boolean = false\n): string {\n    const color = (error ? chalk.red : chalk.green).bold;\n\n    const lines = state.src.split(\"\\n\");\n    const lineIdx = Math.min(lines.length - 1, state.getLineNumber());\n    const startIdx = Math.max(lineIdx - MAX_LINES, 0);\n    const endIdx = Math.min(lineIdx + MAX_LINES + 1, lines.length);\n\n    const lineSummaries = lines.slice(startIdx, endIdx);\n\n    if (cursor) {\n        const cursorLine = \" \".repeat(state.getColumnNumber()) + color(cursor);\n        lineSummaries.splice(lineIdx - startIdx + 1, 0, cursorLine);\n    }\n\n    const resultLines = lineSummaries.map((line, idx) => {\n        const lineNum = startIdx + idx + 1;\n        let paddedLineNum = color.reset.black(String(lineNum));\n\n        line = lineNum === lineIdx + 1 ? color(line) : line;\n        const paddedLine = `      ${paddedLineNum}| ${line}`;\n\n        return paddedLine;\n    });\n\n    return resultLines.join(\"\\n\");\n}\n\nconst group = (docs: Doc, groupOptions: Options = {}) => {\n    return b.group(docs, { ...defaultOptions, ...groupOptions } as any);\n};\n\nconst opStyle = (op: string) => chalk.gray(op);\nconst PARSER_STRINGS = new Map<number, any>();\n\nexport function parserPrint(parser: Parser<any>) {\n    if (PARSER_STRINGS.has(parser.id)) {\n        return PARSER_STRINGS.get(parser.id);\n    }\n\n    const print = (innerParser: Parser<any>, id?: number) => {\n        if (PARSER_STRINGS.has(innerParser.id)) {\n            return PARSER_STRINGS.get(innerParser.id);\n        }\n\n        const { name, args, parser: innerInnerParser } = innerParser.context;\n        const parserString =\n            innerInnerParser != null\n                ? print(innerInnerParser, id)\n                : chalk.red.bold(\"unknown\");\n\n        let s = (() => {\n            switch (name) {\n                case \"string\":\n                    return chalk.yellow(`\"${args[0]}\"`);\n                case \"regex\":\n                case \"regexConcat\":\n                case \"regexWrap\":\n                    return chalk.redBright(`${args[0]}`);\n                case \"wrap\":\n                case \"trim\": {\n                    const [left, right] = args;\n                    return group([\n                        print(left, id),\n                        b.indent([b.softline, parserString]),\n                        b.softline,\n                        print(right, id),\n                    ]);\n                }\n                case \"trimWhitespace\":\n                    return group([parserString, opStyle(\"?w\")]);\n                case \"not\":\n                    return group([\"!\", parserString]);\n                case \"opt\":\n                    return group([parserString, opStyle(\"?\")]);\n                case \"next\":\n                    const [next] = args;\n                    return group([parserString, opStyle(\" >> \"), print(next, id)]);\n                case \"skip\":\n                    const [skip] = args;\n                    return group([parserString, opStyle(\" << \"), print(skip, id)]);\n\n                case \"map\":\n                    return parserString;\n                case \"all\":\n                case \"then\": {\n                    const delim = opStyle(\", \");\n                    return group([\n                        \"[\",\n                        b.indent([\n                            b.softline,\n                            b.join(\n                                [delim, b.softline],\n                                args.map((x) => print(x, id))\n                            ),\n                        ]),\n                        b.softline,\n                        \"]\",\n                    ]);\n                }\n                case \"any\":\n                case \"or\": {\n                    const delim = opStyle(\"| \");\n                    return group([\n                        [\n                            b.join(\n                                [b.softline, b.ifBreak(delim, \" \" + delim)],\n                                args.map((x) => print(x, id))\n                            ),\n                        ],\n                    ]);\n                }\n                case \"many\":\n                    const [min, max] = args;\n                    let bounds = max === Infinity ? `${min},` : `${min},${max}`;\n                    bounds = chalk.bold.gray(` {${bounds}}`);\n                    return group([parserString, bounds]);\n                case \"sepBy\":\n                    return group([\n                        parserString,\n                        b.indent([\" sepBy \", print(args[0], id)]),\n                    ]);\n                case \"lazy\": {\n                    const [lazy] = args;\n                    const p = getLazyParser(lazy);\n\n                    if (!id) {\n                        const s = print(p, p.id);\n                        PARSER_STRINGS.set(p.id, s);\n                        return s;\n                    } else {\n                        return chalk.bold.blue(name);\n                    }\n                }\n                case \"debug\":\n                    return parserString;\n            }\n        })();\n        s ??= chalk.red.bold(name);\n        if (id) {\n            PARSER_STRINGS.set(innerParser.id, s);\n        }\n        return s;\n    };\n\n    const doc = print(parser);\n    const s = prettierPrint(doc);\n    PARSER_STRINGS.set(parser.id, s);\n\n    return s;\n}\n\nexport function statePrint(\n    state: ParserState<any>,\n    name: string = \"\",\n    parserString: string = \"\"\n) {\n    const stateBgColor = !state.isError ? chalk.bgGreen : chalk.bgRed;\n    const stateColor = !state.isError ? chalk.green : chalk.red;\n\n    const finished = state.offset >= state.src.length;\n\n    const stateSymbol = !state.isError ? (finished ? \"🎉\" : \"✓\") : \"ｘ\";\n    const stateName = !state.isError ? (finished ? \"Done\" : \"Ok\") : \"Err\";\n    const stateString = \" \" + stateName + \" \" + stateSymbol + \" \";\n\n    const header = group([\n        stateBgColor.bold(stateString),\n        stateColor(`\\t${name}\\t${state.offset}`),\n        b.softline,\n        \"\\t\" + chalk.yellow(parserString),\n    ]);\n\n    const body = (() => {\n        if (state.offset >= state.src.length) {\n            return chalk.bold.greenBright(addCursor(state, \"\", state.isError));\n        }\n        return addCursor(state, \"^\", state.isError);\n    })();\n\n    const headerBody = group([header, b.hardline, b.indent([body])]);\n\n    return prettierPrint(headerBody);\n}\n\nexport function parserDebug<T>(\n    parser: Parser<T>,\n    name: string = \"\",\n    recursivePrint: boolean = false,\n    logger: (...s: any[]) => void = console.log\n) {\n    const debug = (state: ParserState<T>) => {\n        const newState = parser.parser(state);\n\n        const parserString = recursivePrint ? parserPrint(parser) : parser.context.name;\n        const s = statePrint(newState, name, parserString);\n\n        logger(s);\n\n        return newState;\n    };\n    return new Parser(debug, createParserContext(\"debug\", parser, logger));\n}\n","import { createParserContext, ParserContext, ParserState } from \"./state\";\nimport { parserDebug, parserPrint } from \"./debug\";\n\ntype ExtractValue<T extends ReadonlyArray<Parser<any>>> = {\n    [K in keyof T]: T[K] extends Parser<infer V> ? V : never;\n};\n\ntype ParserFunction<T = string> = (val: ParserState<T>) => ParserState<T>;\n\nlet PARSER_ID = 0;\n\nconst MEMO = new Map<number, ParserState<any>>();\nconst LEFT_RECURSION_COUNTS = new Map<string, number>();\n\nlet lastState: ParserState<any> | undefined;\n\nexport function mergeErrorState(state: ParserState<any>) {\n    if (!lastState || (lastState && state.offset > lastState.offset)) {\n        lastState = state;\n    }\n    return lastState;\n}\n\nexport function getLazyParser<T>(fn: () => Parser<T>) {\n    if (fn.parser) {\n        return fn.parser;\n    }\n    return (fn.parser = fn());\n}\n\nexport class Parser<T = string> {\n    id: number = PARSER_ID++;\n    state: ParserState<T> | undefined;\n\n    constructor(public parser: ParserFunction<T>, public context: ParserContext = {}) {}\n\n    reset() {\n        lastState = undefined;\n        MEMO.clear();\n        LEFT_RECURSION_COUNTS.clear();\n    }\n\n    parse(val: string) {\n        this.reset();\n\n        const newState = this.parser(new ParserState(val));\n\n        this.state = mergeErrorState(newState);\n        this.state.isError = newState.isError;\n\n        return newState.value;\n    }\n\n    getCijKey(state: ParserState<T>) {\n        return `${this.id}${state.offset}`;\n    }\n\n    atLeftRecursionLimit(state: ParserState<T>) {\n        const cij = LEFT_RECURSION_COUNTS.get(this.getCijKey(state)) ?? 0;\n        return cij > state.src.length - state.offset;\n    }\n\n    memoize() {\n        const memoize = (state: ParserState<T>) => {\n            const cijKey = this.getCijKey(state);\n            const cij = LEFT_RECURSION_COUNTS.get(cijKey) ?? 0;\n\n            let cached = MEMO.get(this.id);\n\n            if (cached && cached.offset >= state.offset) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            LEFT_RECURSION_COUNTS.set(cijKey, cij + 1);\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n\n            if (cached && cached.offset > newState.offset) {\n                newState.offset = cached.offset;\n            } else if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n\n            return newState;\n        };\n        return new Parser(\n            memoize as ParserFunction<T>,\n            createParserContext(\"memoize\", this)\n        );\n    }\n\n    mergeMemos<S>() {\n        const mergeMemo = (state: ParserState<T>) => {\n            let cached = MEMO.get(this.id);\n            if (cached) {\n                return cached;\n            } else if (this.atLeftRecursionLimit(state)) {\n                return state.err(undefined);\n            }\n\n            const newState = this.parser(state);\n\n            cached = MEMO.get(this.id);\n            if (!cached) {\n                MEMO.set(this.id, newState);\n            }\n            return newState;\n        };\n\n        return new Parser(\n            mergeMemo as ParserFunction<[T, S]>,\n            createParserContext(\"mergeMemo\", this)\n        );\n    }\n\n    then<S>(next: Parser<S | T>) {\n        if (isStringParsers(this, next)) {\n            return concatStringParsers([this, next], \"\", (m) => [m?.[0], m?.[1]]);\n        }\n\n        const then = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n\n            if (!nextState1.isError) {\n                const nextState2 = next.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok([nextState1.value, nextState2.value]);\n                }\n            }\n            mergeErrorState(state);\n            return state.err(undefined);\n        };\n\n        return new Parser(\n            then as ParserFunction<[T, S]>,\n            createParserContext(\"then\", this, this, next)\n        );\n    }\n\n    or<S>(other: Parser<S | T>) {\n        if (isStringParsers(this, other)) {\n            return concatStringParsers([this, other], \"|\");\n        }\n\n        const or = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (!newState.isError) {\n                return newState;\n            }\n            return other.parser(state);\n        };\n\n        return new Parser(\n            or as ParserFunction<T | S>,\n            createParserContext(\"or\", this, this, other)\n        );\n    }\n\n    chain<S>(fn: (value: T) => Parser<S | T>, chainError: boolean = false) {\n        const chain = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            } else if (newState.value || chainError) {\n                return fn(newState.value).parser(newState);\n            }\n            return state;\n        };\n\n        return new Parser(chain, createParserContext(\"chain\", this, fn));\n    }\n\n    map<S>(fn: (value: T) => S, mapError: boolean = false) {\n        const map = (state: ParserState<T | S>) => {\n            const newState = this.parser(state as ParserState<T>);\n\n            if (!newState.isError || mapError) {\n                return newState.ok(fn(newState.value));\n            }\n            return newState;\n        };\n\n        return new Parser(map as ParserFunction<S>, createParserContext(\"map\", this));\n    }\n\n    mapState<S extends T>(fn: (state: ParserState<T>) => ParserState<S>) {\n        const mapState = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            return fn(newState);\n        };\n\n        return new Parser(\n            mapState as ParserFunction<S>,\n            createParserContext(\"mapState\", this)\n        );\n    }\n\n    skip<S>(parser: Parser<T | S>) {\n        const skip = (state: ParserState<T>) => {\n            const nextState1 = this.parser(state);\n            let nextState2;\n\n            if (!nextState1.isError) {\n                nextState2 = parser.parser(nextState1);\n                if (!nextState2.isError) {\n                    return nextState2.ok(nextState1.value);\n                }\n            }\n            mergeErrorState(state);\n            return state.err(undefined);\n        };\n        return new Parser(\n            skip as ParserFunction<T>,\n            createParserContext(\"skip\", this, parser)\n        );\n    }\n\n    next<S>(parser: Parser<S>) {\n        const next = this.then(parser).map(([, b]) => {\n            return b;\n        }) as Parser<S>;\n        next.context = createParserContext(\"next\", this, parser);\n        return next;\n    }\n\n    opt() {\n        const opt = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n            if (newState.isError) {\n                mergeErrorState(state);\n                return state.ok(undefined);\n            }\n            return newState;\n        };\n        return new Parser(opt as ParserFunction<T>, createParserContext(\"opt\", this));\n    }\n\n    not<S>(parser?: Parser<S>) {\n        const negate = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                mergeErrorState(state);\n                return state.ok(state.value);\n            } else {\n                return state.err(undefined);\n            }\n        };\n\n        const not = (state: ParserState<T>) => {\n            const newState = this.parser(state);\n\n            if (newState.isError) {\n                mergeErrorState(state);\n                return newState;\n            } else {\n                const nextState = parser.parser(state);\n                if (nextState.isError) {\n                    return newState;\n                } else {\n                    mergeErrorState(state);\n                    return state.err(undefined);\n                }\n            }\n        };\n\n        return new Parser(\n            parser ? not : negate,\n            createParserContext(\"not\", this, parser)\n        );\n    }\n\n    wrap<L, R>(start: Parser<L>, end: Parser<R>, discard: boolean = true) {\n        if (!discard) {\n            return all(start, this, end);\n        }\n\n        if (isStringParsers(start, this, end)) {\n            return wrapStringParsers(start, this, end);\n        }\n        const wrap = start.next(this).skip(end) as Parser<T>;\n        wrap.context = createParserContext(\"wrap\", this, start, end);\n        return wrap;\n    }\n\n    trim(parser: Parser<T> = whitespace as Parser<T>, discard: boolean = true) {\n        if (!discard) {\n            return all(parser, this, parser);\n        }\n\n        if (parser.context?.name === \"whitespace\") {\n            if (isStringParsers(this, parser)) {\n                return concatStringParsers(\n                    [parser, this, parser],\n                    \"\",\n                    (m) => m?.[2]\n                ) as Parser<T>;\n            }\n\n            const whitespaceTrim = (state: ParserState<T>) => {\n                const newState = trimStateWhitespace(state);\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    mergeErrorState(state);\n                    return state.err(undefined);\n                } else {\n                    return trimStateWhitespace(tmpState);\n                }\n            };\n\n            return new Parser(\n                whitespaceTrim as ParserFunction<T>,\n                createParserContext(\"trimWhitespace\", this)\n            ) as Parser<T>;\n        }\n\n        return this.wrap(parser, parser) as Parser<T>;\n    }\n\n    many(min: number = 0, max: number = Infinity) {\n        const many = (state: ParserState<T>) => {\n            const matches: T[] = [];\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n\n                if (tmpState.isError) {\n                    break;\n                }\n                matches.push(tmpState.value);\n                newState = tmpState;\n            }\n\n            if (matches.length >= min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            mergeErrorState(state);\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            many as ParserFunction<T[]>,\n            createParserContext(\"many\", this, min, max)\n        );\n    }\n\n    sepBy<S>(sep: Parser<S | T>, min: number = 0, max: number = Infinity) {\n        const sepBy = (state: ParserState<T>) => {\n            const matches: T[] = [];\n\n            let newState = state;\n\n            for (let i = 0; i < max; i += 1) {\n                const tmpState = this.parser(newState);\n                if (tmpState.isError) {\n                    break;\n                }\n                newState = tmpState;\n                matches.push(newState.value);\n\n                const sepState = sep.parser(newState);\n                if (sepState.isError) {\n                    break;\n                }\n                newState = sepState as ParserState<T>;\n            }\n\n            if (matches.length > min) {\n                return newState.ok(matches) as ParserState<T[]>;\n            }\n            mergeErrorState(state);\n            return state.err([]) as ParserState<T[]>;\n        };\n\n        return new Parser(\n            sepBy as ParserFunction<T[]>,\n            createParserContext(\"sepBy\", this, sep)\n        );\n    }\n\n    eof() {\n        const p = this.skip(eof()) as Parser<T>;\n        p.context = createParserContext(\"eof\", this);\n        return p;\n    }\n\n    debug(\n        name: string = \"\",\n        recursivePrint: boolean = false,\n        logger: (...s: any[]) => void = console.log\n    ) {\n        return parserDebug(this, name, recursivePrint, logger);\n    }\n\n    toString() {\n        return parserPrint(this);\n    }\n\n    static lazy<T>(fn: () => Parser<T>) {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(fn).parser(state);\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, fn));\n    }\n}\n\nfunction isStringParsers(...parsers: Parser<any>[]) {\n    return parsers.every(\n        (p) =>\n            (p.context?.name === \"string\" ||\n                p.context?.name === \"regex\" ||\n                p.context?.name === \"whitespace\") &&\n            p.context?.args\n    );\n}\n\nfunction stringParserValue(p: Parser<any>) {\n    if (p.context?.name === \"string\") {\n        return p.context?.args[0].replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    } else if (p.context?.name === \"regex\" || p.context?.name === \"whitespace\") {\n        return p.context?.args[0].source;\n    }\n}\n\nfunction concatStringParsers(\n    parsers: Parser<any>[],\n    delim: string = \"\",\n    matchFunction?: (m: RegExpMatchArray) => any\n): Parser<string> {\n    const s = parsers.map((s) => `(${stringParserValue(s)})`).join(delim);\n    const r = new RegExp(s);\n    const rP = regex(r, matchFunction);\n\n    if (delim !== \"|\") {\n        rP.context = createParserContext(\"regexConcat\", this, r);\n    }\n    return rP;\n}\n\nfunction wrapStringParsers<L, T, R>(\n    left: Parser<L>,\n    p: Parser<T>,\n    right: Parser<R>\n): Parser<string> {\n    const rP = concatStringParsers([left, p, right], \"\", (m) => {\n        return m?.[2];\n    });\n    rP.context.name = \"regexWrap\";\n    return rP;\n}\n\nexport function eof<T>() {\n    const eof = (state: ParserState<T>) => {\n        if (state.offset >= state.src.length) {\n            return state.ok(undefined);\n        } else {\n            return state.err();\n        }\n    };\n    return new Parser(eof, createParserContext(\"eof\", undefined)) as Parser<any>;\n}\n\nexport function lazy<T>(\n    target: any,\n    propertyName: string,\n    descriptor: TypedPropertyDescriptor<() => Parser<T>>\n) {\n    const method = descriptor.value.bind(target)!;\n\n    descriptor.value = function () {\n        const lazy = (state: ParserState<T>) => {\n            return getLazyParser(method).parser(state) as ParserState<T>;\n        };\n        return new Parser<T>(lazy, createParserContext(\"lazy\", undefined, method));\n    };\n}\n\nexport function any<T extends any[]>(...parsers: T) {\n    if (isStringParsers(...parsers)) {\n        return concatStringParsers(parsers, \"|\") as Parser<ExtractValue<T>[number]>;\n    }\n\n    const any = (state: ParserState<T>) => {\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n            if (!newState.isError) {\n                return newState;\n            }\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : any,\n        createParserContext(\"any\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>[number]>;\n}\n\nexport function all<T extends any[]>(...parsers: T) {\n    const all = (state: ParserState<ExtractValue<T>>): ParserState<ExtractValue<T>> => {\n        const matches = [] as any;\n\n        for (const parser of parsers) {\n            const newState = parser.parser(state);\n\n            if (newState.isError) {\n                return newState;\n            }\n\n            // TODO! hack or ...?\n            if (newState.value !== undefined) {\n                matches.push(newState.value);\n            }\n            state = newState;\n        }\n        mergeErrorState(state);\n        return state.ok(matches);\n    };\n\n    return new Parser(\n        parsers.length === 1 ? parsers[0].parser : all,\n        createParserContext(\"all\", undefined, ...parsers)\n    ) as Parser<ExtractValue<T>>;\n}\n\nexport function string(str: string) {\n    const string = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n        const s = state.src.slice(state.offset, state.offset + str.length);\n        if (s === str) {\n            return state.ok(s, s.length);\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        string as ParserFunction<string>,\n        createParserContext(\"string\", undefined, str)\n    );\n}\n\nexport function regex(\n    r: RegExp,\n    matchFunction: (match: RegExpMatchArray) => any = (m) => m?.[0]\n) {\n    const flags = r.flags.replace(/y/g, \"\");\n    const sticky = new RegExp(r, flags + \"y\");\n\n    const regex = (state: ParserState<string>) => {\n        if (state.offset >= state.src.length) {\n            return state.err(undefined);\n        }\n\n        sticky.lastIndex = state.offset;\n        const match = matchFunction(state.src.match(sticky));\n\n        if (match) {\n            return state.ok(match, sticky.lastIndex - state.offset);\n        } else if (match === \"\") {\n            return state.ok(undefined);\n        }\n        mergeErrorState(state);\n        return state.err(undefined);\n    };\n\n    return new Parser(\n        regex as ParserFunction<string>,\n        createParserContext(\"regex\", undefined, r)\n    );\n}\n\nconst WHITESPACE = /\\s*/y;\nconst trimStateWhitespace = <T>(state: ParserState<T>) => {\n    if (state.offset >= state.src.length) {\n        return state;\n    }\n\n    WHITESPACE.lastIndex = state.offset;\n    const match = state.src.match(WHITESPACE)?.[0] ?? \"\";\n    return state.ok(state.value, match.length);\n};\n\nexport const whitespace = regex(/\\s*/);\nwhitespace.context.name = \"whitespace\";\n"],"names":["ParserState","src","value","offset","isError","furthest","nextState","lastNewline","columnNumber","newlineIndex","parserNames","createParserContext","name","parser","args","factory","module","__getOwnPropNames","__commonJS","cb","mod","require_doc_js_umd","exports","__create","__defProp","__getOwnPropDesc","__getOwnPropNames2","__getProtoOf","__hasOwnProp","__esm","fn","res","__commonJS2","__export","target","all","__copyProps","to","from","except","desc","key","__toESM","isNodeMode","__toCommonJS","init_define_process","require_doc_builders","exports2","module2","concat","parts","indent","contents","align","widthOrString","group","opts","dedentToRoot","markAsRoot","dedent","conditionalGroup","states","fill","ifBreak","breakContents","flatContents","indentIfBreak","lineSuffix","lineSuffixBoundary","breakParent","trim","hardlineWithoutBreakParent","literallineWithoutBreakParent","line","softline","hardline","literalline","cursor","join","sep","arr","i","addAlignmentToDoc","doc","size","tabWidth","aligned","label","label2","require_end_of_line","guessEndOfLine","text","index","convertEndOfLineToChars","countEndOfLineChars","eol","regex","endOfLines","normalizeEndOfLine","require_get_last","getLast","ansiRegex","onlyFirst","pattern","init_ansi_regex","stripAnsi","string","init_strip_ansi","isFullwidthCodePoint","codePoint","init_is_fullwidth_code_point","require_emoji_regex","string_width_exports","stringWidth","import_emoji_regex","width","init_string_width","require_get_string_width","stringWidth2","notAsciiRegex","getStringWidth","require_doc_utils","isConcat","getDocParts","traverseDocOnExitStackMarker","traverseDoc","onEnter","onExit","shouldTraverseConditionalGroups","docsStack","doc2","ic","mapDoc","mapped","rec","result","process2","expandedStates","findInDoc","defaultValue","hasStopped","findInDocOnEnterFn","maybeResult","willBreakFn","willBreak","breakParentGroup","groupStack","parentGroup","propagateBreaks","alreadyVisitedSet","propagateBreaksOnEnterFn","propagateBreaksOnExitFn","removeLinesFn","removeLines","isHardline","nextDoc","stripDocTrailingHardlineFromDoc","lastPart","stripTrailingHardline","cleanDoc","cleanDocFn","part","currentPart","restParts","currentDoc","normalizeParts","newParts","normalizeDoc","replaceEndOfLine","replaceTextEndOfLine","replacement","canBreakFn","canBreak","require_doc_printer","groupModeMap","MODE_BREAK","MODE_FLAT","rootIndent","makeIndent","ind","options","generateInd","makeAlign","indent2","widthOrDoc","newPart","queue","length","lastTabs","lastSpaces","flush","addTabs","addSpaces","flushSpaces","count","flushTabs","resetLast","out","trimCount","trimmed","fits","next","restCommands","hasLineSuffix","mustBeFlat","restIdx","cmds","mode","groupMode","printDocToString","newLine","pos","shouldRemeasure","formatted","rem","mostExpanded","state","cmd","content","whitespace","contentFlatCmd","contentBreakCmd","contentFits","whitespaceFlatCmd","whitespaceBreakCmd","remainingCmd","secondContent","cursorPlaceholderIndex","otherCursorPlaceholderIndex","beforeCursor","aroundCursor","afterCursor","require_doc_debug","flattenDoc","flattened","printDocToDebug","printedSymbols","usedKeysForSymbols","printDoc","parentParts","printed","withBreakParent","printGroupId","optionsParts","id","prefix","counter","MAX_LINES","MAX_LINE_LENGTH","defaultOptions","prettierPrint","printer","summarizeLine","maxLength","addCursor","error","color","chalk","lines","lineIdx","startIdx","endIdx","lineSummaries","cursorLine","idx","lineNum","paddedLineNum","docs","groupOptions","b","opStyle","op","PARSER_STRINGS","parserPrint","print","innerParser","innerInnerParser","parserString","s","left","right","skip","delim","x","min","max","bounds","lazy","p","getLazyParser","statePrint","stateBgColor","stateColor","finished","stateSymbol","stateString","header","body","headerBody","parserDebug","recursivePrint","logger","debug","newState","Parser","PARSER_ID","MEMO","LEFT_RECURSION_COUNTS","lastState","mergeErrorState","context","__publicField","val","memoize","cijKey","cij","cached","mergeMemo","isStringParsers","concatStringParsers","m","then","nextState1","nextState2","other","or","chainError","chain","mapError","map","mapState","opt","negate","not","start","end","discard","wrapStringParsers","wrap","_a","whitespaceTrim","trimStateWhitespace","tmpState","many","matches","sepBy","sepState","eof","parsers","_b","_c","_d","stringParserValue","_e","matchFunction","r","rP","propertyName","descriptor","method","any","str","flags","sticky","match","WHITESPACE"],"mappings":";;;;AAEO,MAAMA,GAAe;AAAA,EACxB,YACWC,GACAC,IAAW,QACXC,IAAiB,GACjBC,IAAmB,IACnBC,IAAmB,GAC5B;AALS,SAAA,MAAAJ,GACA,KAAA,QAAAC,GACA,KAAA,SAAAC,GACA,KAAA,UAAAC,GACA,KAAA,WAAAC;AAAA,EACR;AAAA,EAEH,GAAMH,GAAUC,IAAiB,GAAG;AAChC,WAAAA,KAAU,KAAK,QACR,IAAIH,GAAe,KAAK,KAAKE,GAAOC,GAAQ,EAAK;AAAA,EAC5D;AAAA,EAEA,IAAOD,GAAWC,IAAiB,GAAG;AAClC,UAAMG,IAAY,KAAK,GAAGJ,GAAOC,CAAM;AACvC,WAAAG,EAAU,UAAU,IACbA;AAAA,EACX;AAAA,EAEA,KAAQJ,GAAUC,IAAiB,GAAG;AAClC,WAAAA,KAAU,KAAK,QACR,IAAIH,GAAe,KAAK,KAAKE,GAAOC,GAAQ,KAAK,OAAO;AAAA,EACnE;AAAA,EAEA,kBAA0B;AACtB,UAAMA,IAAS,KAAK,QACdI,IAAc,KAAK,IAAI,YAAY;AAAA,GAAMJ,CAAM,GAC/CK,IAAeD,MAAgB,KAAKJ,IAASA,KAAUI,IAAc;AACpE,WAAA,KAAK,IAAI,GAAGC,CAAY;AAAA,EACnC;AAAA,EAEA,gBAAwB;AACpB,UAAMC,IAAe,KAAK,IAAI,YAAY;AAAA,GAAM,KAAK,MAAM;AACpD,WAAAA,KAAgB,IACjB,KAAK,IAAI,MAAM,GAAGA,CAAY,EAAE,MAAM;AAAA,CAAI,EAAE,SAC5C;AAAA,EACV;AACJ;AAEO,MAAMC,KAAc;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AASgB,SAAAC,EACZC,GACAC,MACGC,GACL;AACS,SAAA;AAAA,IACH,MAAAF;AAAA,IACA,QAAAC;AAAA,IACA,MAAAC;AAAA,EAAA;AAER;;;;;;;;;;AC1FA,GAAC,SAAUC,GAAS;AAEhB,IAAAC,EAAA,UAAiBD;EAcrB,GAAG,WAAW;AAEZ,QAAIE,IAAoB,OAAO,qBAC3BC,IAAa,CAACC,GAAIC,MAAQ,WAAqB;AACjD,aAAOA,SAAWD,EAAGF,EAAkBE,CAAE,EAAE,CAAC,CAAC,IAAIC,IAAM,EAAE,SAAS,CAAA,KAAM,SAASA,CAAG,GAAGA,EAAI;AAAA,IAC/F,GAGMC,IAAqBH,EAAW;AAAA,MAClC,sBAAsBI,GAASN,GAAQ;AACrC,YAAIO,IAAW,OAAO,QAClBC,IAAY,OAAO,gBACnBC,IAAmB,OAAO,0BAC1BC,IAAqB,OAAO,qBAC5BC,KAAe,OAAO,gBACtBC,KAAe,OAAO,UAAU,gBAChCC,KAAQ,CAACC,GAAIC,MAAQ,WAAkB;AACzC,iBAAOD,MAAOC,QAAUD,EAAGJ,EAAmBI,CAAE,EAAE,CAAC,CAAC,GAAGA,IAAK,CAAC,IAAIC;AAAA,QACzE,GACUC,IAAc,CAACb,GAAIC,MAAQ,WAAqB;AAClD,iBAAOA,SAAWD,EAAGO,EAAmBP,CAAE,EAAE,CAAC,CAAC,IAAIC,IAAM;AAAA,YACtD,SAAS,CAAE;AAAA,UACZ,GAAE,SAASA,CAAG,GAAGA,EAAI;AAAA,QAC9B,GACUa,KAAW,CAACC,GAAQC,MAAQ;AAC9B,mBAASvB,KAAQuB;AACf,YAAAX,EAAUU,GAAQtB,GAAM;AAAA,cACtB,KAAKuB,EAAIvB,CAAI;AAAA,cACb,YAAY;AAAA,YACxB,CAAW;AAAA,QACX,GACUwB,IAAc,CAACC,GAAIC,GAAMC,GAAQC,MAAS;AAC5C,cAAIF,KAAQ,OAAOA,KAAS,YAAY,OAAOA,KAAS;AACtD,qBAASG,KAAOf,EAAmBY,CAAI;AACrC,cAAI,CAACV,GAAa,KAAKS,GAAII,CAAG,KAAKA,MAAQF,KACzCf,EAAUa,GAAII,GAAK;AAAA,gBACjB,KAAK,MAAMH,EAAKG,CAAG;AAAA,gBACnB,YAAY,EAAED,IAAOf,EAAiBa,GAAMG,CAAG,MAAMD,EAAK;AAAA,cAC1E,CAAe;AAEP,iBAAOH;AAAA,QACf,GACUK,IAAU,CAACtB,GAAKuB,GAAYT,OAAYA,IAASd,KAAO,OAAOG,EAASI,GAAaP,CAAG,CAAC,IAAI,IAAIgB,EAAYO,KAAc,CAACvB,KAAO,CAACA,EAAI,aAAaI,EAAUU,GAAQ,WAAW;AAAA,UACpL,OAAOd;AAAA,UACP,YAAY;AAAA,QACpB,CAAO,IAAIc,GAAQd,CAAG,IACZwB,KAAe,CAACxB,MAAQgB,EAAYZ,EAAU,CAAE,GAAE,cAAc;AAAA,UAClE,OAAO;AAAA,QACf,CAAO,GAAGJ,CAAG,GACHyB,IAAsBhB,GAAM;AAAA,UAC9B,qBAAqB;AAAA,UACpB;AAAA,QACT,CAAO,GACGiB,KAAuBd,EAAY;AAAA,UACrC,+BAA+Be,GAAUC,GAAS;AAEhD,YAAAH;AACA,qBAASI,EAAOC,GAAO;AAMrB,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,OAAAA;AAAA,cACd;AAAA,YACW;AACD,qBAASC,EAAOC,GAAU;AAIxB,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,UAAAA;AAAA,cACd;AAAA,YACW;AACD,qBAASC,EAAMC,GAAeF,GAAU;AAItC,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,UAAAA;AAAA,gBACA,GAAGE;AAAA,cACjB;AAAA,YACW;AACD,qBAASC,EAAMH,GAAU;AACvB,kBAAII,IAAO,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAS,UAAU,CAAC,IAAI,CAAA;AAI5E,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,IAAIA,EAAK;AAAA,gBACT,UAAAJ;AAAA,gBACA,OAAO,QAAQI,EAAK,WAAW;AAAA,gBAC/B,gBAAgBA,EAAK;AAAA,cACnC;AAAA,YACW;AACD,qBAASC,EAAaL,GAAU;AAC9B,qBAAOC,EAAM,OAAO,mBAAmBD,CAAQ;AAAA,YAChD;AACD,qBAASM,EAAWN,GAAU;AAC5B,qBAAOC,EAAM;AAAA,gBACX,MAAM;AAAA,cACP,GAAED,CAAQ;AAAA,YACZ;AACD,qBAASO,EAAOP,GAAU;AACxB,qBAAOC,EAAM,IAAID,CAAQ;AAAA,YAC1B;AACD,qBAASQ,EAAiBC,GAAQL,GAAM;AACtC,qBAAOD,EAAMM,EAAO,CAAC,GAAG,OAAO,OAAO,OAAO,OAAO,CAAA,GAAIL,CAAI,GAAG,CAAA,GAAI;AAAA,gBACjE,gBAAgBK;AAAA,cACjB,CAAA,CAAC;AAAA,YACH;AACD,qBAASC,EAAKZ,GAAO;AAMnB,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,OAAAA;AAAA,cACd;AAAA,YACW;AACD,qBAASa,EAAQC,GAAeC,GAAc;AAC5C,kBAAIT,IAAO,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAS,UAAU,CAAC,IAAI,CAAA;AAS5E,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,eAAAQ;AAAA,gBACA,cAAAC;AAAA,gBACA,SAAST,EAAK;AAAA,cAC5B;AAAA,YACW;AACD,qBAASU,EAAcd,GAAUI,GAAM;AACrC,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,UAAAJ;AAAA,gBACA,SAASI,EAAK;AAAA,gBACd,QAAQA,EAAK;AAAA,cAC3B;AAAA,YACW;AACD,qBAASW,EAAWf,GAAU;AAI5B,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,UAAAA;AAAA,cACd;AAAA,YACW;AACD,gBAAIgB,IAAqB;AAAA,cACvB,MAAM;AAAA,YAClB,GACcC,IAAc;AAAA,cAChB,MAAM;AAAA,YAClB,GACcC,KAAO;AAAA,cACT,MAAM;AAAA,YAClB,GACcC,KAA6B;AAAA,cAC/B,MAAM;AAAA,cACN,MAAM;AAAA,YAClB,GACcC,IAAgC;AAAA,cAClC,MAAM;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,YACrB,GACcC,KAAO;AAAA,cACT,MAAM;AAAA,YAClB,GACcC,IAAW;AAAA,cACb,MAAM;AAAA,cACN,MAAM;AAAA,YAClB,GACcC,IAAW1B,EAAO,CAACsB,IAA4BF,CAAW,CAAC,GAC3DO,IAAc3B,EAAO,CAACuB,GAA+BH,CAAW,CAAC,GACjEQ,IAAS;AAAA,cACX,MAAM;AAAA,cACN,aAAa,OAAO,QAAQ;AAAA,YACxC;AACU,qBAASC,EAAKC,GAAKC,GAAK;AACtB,oBAAMjD,IAAM,CAAA;AACZ,uBAASkD,IAAI,GAAGA,IAAID,EAAI,QAAQC;AAC9B,gBAAIA,MAAM,KACRlD,EAAI,KAAKgD,CAAG,GAEdhD,EAAI,KAAKiD,EAAIC,CAAC,CAAC;AAEjB,qBAAOhC,EAAOlB,CAAG;AAAA,YAClB;AACD,qBAASmD,EAAkBC,GAAKC,GAAMC,GAAU;AAC9C,kBAAIC,IAAUH;AACd,kBAAIC,IAAO,GAAG;AACZ,yBAASH,IAAI,GAAGA,IAAI,KAAK,MAAMG,IAAOC,CAAQ,GAAG,EAAEJ;AACjD,kBAAAK,IAAUnC,EAAOmC,CAAO;AAE1B,gBAAAA,IAAUjC,EAAM+B,IAAOC,GAAUC,CAAO,GACxCA,IAAUjC,EAAM,OAAO,mBAAmBiC,CAAO;AAAA,cAClD;AACD,qBAAOA;AAAA,YACR;AACD,qBAASC,EAAMC,GAAQpC,GAAU;AAC/B,qBAAO;AAAA,gBACL,MAAM;AAAA,gBACN,OAAOoC;AAAA,gBACP,UAAApC;AAAA,cACd;AAAA,YACW;AACD,YAAAJ,EAAQ,UAAU;AAAA,cAChB,QAAAC;AAAA,cACA,MAAA6B;AAAA,cACA,MAAAL;AAAA,cACA,UAAAC;AAAA,cACA,UAAAC;AAAA,cACA,aAAAC;AAAA,cACA,OAAArB;AAAA,cACA,kBAAAK;AAAA,cACA,MAAAE;AAAA,cACA,YAAAK;AAAA,cACA,oBAAAC;AAAA,cACA,QAAAS;AAAA,cACA,aAAAR;AAAA,cACA,SAAAN;AAAA,cACA,MAAAO;AAAA,cACA,QAAAnB;AAAA,cACA,eAAAe;AAAA,cACA,OAAAb;AAAA,cACA,mBAAA6B;AAAA,cACA,YAAAxB;AAAA,cACA,cAAAD;AAAA,cACA,QAAAE;AAAA,cACA,4BAAAY;AAAA,cACA,+BAAAC;AAAA,cACA,OAAAe;AAAA,YACZ;AAAA,UACS;AAAA,QACT,CAAO,GACGE,KAAsBzD,EAAY;AAAA,UACpC,4BAA4Be,GAAUC,GAAS;AAE7C,YAAAH;AACA,qBAAS6C,EAAeC,GAAM;AAC5B,oBAAMC,IAAQD,EAAK,QAAQ,IAAI;AAC/B,qBAAIC,KAAS,IACJD,EAAK,OAAOC,IAAQ,CAAC,MAAM;AAAA,IAAO,SAAS,OAE7C;AAAA,YACR;AACD,qBAASC,EAAwB3F,GAAO;AACtC,sBAAQA,GAAK;AAAA,gBACX,KAAK;AACH,yBAAO;AAAA,gBACT,KAAK;AACH,yBAAO;AAAA;AAAA,gBACT;AACE,yBAAO;AAAA;AAAA,cACV;AAAA,YACF;AACD,qBAAS4F,EAAoBH,GAAMI,GAAK;AACtC,kBAAIC;AACJ,sBAAQD,GAAG;AAAA,gBACT,KAAK;AAAA;AACH,kBAAAC,IAAQ;AACR;AAAA,gBACF,KAAK;AACH,kBAAAA,IAAQ;AACR;AAAA,gBACF,KAAK;AAAA;AACH,kBAAAA,IAAQ;AACR;AAAA,gBACF;AACE,wBAAM,IAAI,MAAM,oBAAoB,KAAK,UAAUD,CAAG,IAAI;AAAA,cAC7D;AACD,oBAAME,IAAaN,EAAK,MAAMK,CAAK;AACnC,qBAAOC,IAAaA,EAAW,SAAS;AAAA,YACzC;AACD,qBAASC,EAAmBP,GAAM;AAChC,qBAAOA,EAAK,QAAQ,UAAU;AAAA,CAAI;AAAA,YACnC;AACD,YAAA3C,EAAQ,UAAU;AAAA,cAChB,gBAAA0C;AAAA,cACA,yBAAAG;AAAA,cACA,qBAAAC;AAAA,cACA,oBAAAI;AAAA,YACZ;AAAA,UACS;AAAA,QACT,CAAO,GACGC,KAAmBnE,EAAY;AAAA,UACjC,wBAAwBe,GAAUC,GAAS;AAEzC,YAAAH;AACA,gBAAIuD,IAAU,CAACpB,MAAQA,EAAIA,EAAI,SAAS,CAAC;AACzC,YAAAhC,EAAQ,UAAUoD;AAAA,UACnB;AAAA,QACT,CAAO;AACD,iBAASC,KAAY;AACnB,cAAI;AAAA,YACF,WAAAC,IAAY;AAAA,UACb,IAAG,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAS,UAAU,CAAC,IAAI,CAAA;AACrE,gBAAMC,IAAU,CAAC,gIAAgI,0DAA0D,EAAE,KAAK,GAAG;AACrN,iBAAO,IAAI,OAAOA,GAASD,IAAY,SAAS,GAAG;AAAA,QACpD;AACD,YAAIE,KAAkB3E,GAAM;AAAA,UAC1B,6DAA6D;AAC3D,YAAAgB;UACD;AAAA,QACT,CAAO;AACD,iBAAS4D,GAAUC,GAAQ;AACzB,cAAI,OAAOA,KAAW;AACpB,kBAAM,IAAI,UAAU,gCAAgC,OAAOA,KAAU;AAEvE,iBAAOA,EAAO,QAAQL,GAAW,GAAE,EAAE;AAAA,QACtC;AACD,YAAIM,KAAkB9E,GAAM;AAAA,UAC1B,qCAAqC;AACnC,YAAAgB,KACA2D;UACD;AAAA,QACT,CAAO;AACD,iBAASI,GAAqBC,GAAW;AACvC,iBAAK,OAAO,UAAUA,CAAS,IAGxBA,KAAa,SAASA,KAAa,QAAQA,MAAc,QAAQA,MAAc,QAAQ,SAASA,KAAaA,KAAa,SAASA,MAAc,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,SAASA,KAAaA,KAAa,SAAS,UAAUA,KAAaA,KAAa,UAAU,UAAUA,KAAaA,KAAa,UAAU,UAAUA,KAAaA,KAAa,UAFpqB;AAAA,QAGV;AACD,YAAIC,KAA+BjF,GAAM;AAAA,UACvC,kDAAkD;AAChD,YAAAgB;UACD;AAAA,QACT,CAAO,GACGkE,KAAsB/E,EAAY;AAAA,UACpC,oCAAoCe,GAAUC,GAAS;AAErD,YAAAH,KACAG,EAAQ,UAAU,WAAW;AAC3B,qBAAO;AAAA,YACnB;AAAA,UACS;AAAA,QACT,CAAO,GACGgE,KAAuB,CAAA;AAC3B,QAAA/E,GAAS+E,IAAsB;AAAA,UAC7B,SAAS,MAAMC;AAAA,QACvB,CAAO;AACD,iBAASA,GAAYP,GAAQ;AAK3B,cAJI,OAAOA,KAAW,YAAYA,EAAO,WAAW,MAGpDA,IAASD,GAAUC,CAAM,GACrBA,EAAO,WAAW;AACpB,mBAAO;AAET,UAAAA,IAASA,EAAO,YAAYQ,GAAmB,SAAO,GAAK,IAAI;AAC/D,cAAIC,IAAQ;AACZ,mBAASvB,IAAQ,GAAGA,IAAQc,EAAO,QAAQd,KAAS;AAClD,kBAAMiB,IAAYH,EAAO,YAAYd,CAAK;AAC1C,YAAIiB,KAAa,MAAMA,KAAa,OAAOA,KAAa,OAGpDA,KAAa,OAAOA,KAAa,QAGjCA,IAAY,SACdjB,KAEFuB,KAASP,GAAqBC,CAAS,IAAI,IAAI;AAAA,UAChD;AACD,iBAAOM;AAAA,QACR;AACD,YAAID,IACAE,KAAoBvF,GAAM;AAAA,UAC5B,uCAAuC;AACrC,YAAAgB,KACA8D,MACAG,MACAI,KAAqBxE,EAAQqE,GAAmB,CAAE;AAAA,UACnD;AAAA,QACT,CAAO,GACGM,KAA2BrF,EAAY;AAAA,UACzC,gCAAgCe,GAAUC,GAAS;AAEjD,YAAAH;AACA,gBAAIyE,KAAgBF,GAAiB,GAAIxE,GAAaoE,EAAoB,GAAG,SACzEO,IAAgB;AACpB,qBAASC,EAAe7B,GAAM;AAC5B,qBAAKA,IAGA4B,EAAc,KAAK5B,CAAI,IAGrB2B,EAAa3B,CAAI,IAFfA,EAAK,SAHL;AAAA,YAMV;AACD,YAAA3C,EAAQ,UAAUwE;AAAA,UACnB;AAAA,QACT,CAAO,GACGC,KAAoBzF,EAAY;AAAA,UAClC,4BAA4Be,GAAUC,GAAS;AAE7C,YAAAH;AACA,gBAAIuD,IAAUD,MACV;AAAA,cACF,aAAAvB;AAAA,cACA,MAAAE;AAAA,YACD,IAAGhC,GAAoB,GACpB4E,IAAW,CAACvC,MAAQ,MAAM,QAAQA,CAAG,KAAKA,KAAOA,EAAI,SAAS,UAC9DwC,IAAc,CAACxC,MAAQ;AACzB,kBAAI,MAAM,QAAQA,CAAG;AACnB,uBAAOA;AAET,kBAAIA,EAAI,SAAS,YAAYA,EAAI,SAAS;AACxC,sBAAM,IAAI,MAAM,2CAA2C;AAE7D,qBAAOA,EAAI;AAAA,YACvB,GACcyC,IAA+B,CAAA;AACnC,qBAASC,EAAY1C,GAAK2C,GAASC,GAAQC,GAAiC;AAC1E,oBAAMC,IAAY,CAAC9C,CAAG;AACtB,qBAAO8C,EAAU,SAAS,KAAG;AAC3B,sBAAMC,IAAOD,EAAU;AACvB,oBAAIC,MAASN,GAA8B;AACzC,kBAAAG,EAAOE,EAAU,IAAG,CAAE;AACtB;AAAA,gBACD;AAID,oBAHIF,KACFE,EAAU,KAAKC,GAAMN,CAA4B,GAE/C,CAACE,KAAWA,EAAQI,CAAI,MAAM;AAChC,sBAAIR,EAASQ,CAAI,KAAKA,EAAK,SAAS,QAAQ;AAC1C,0BAAMhF,IAAQyE,EAAYO,CAAI;AAC9B,6BAASC,IAAKjF,EAAM,QAAQ+B,KAAIkD,IAAK,GAAGlD,MAAK,GAAG,EAAEA;AAChD,sBAAAgD,EAAU,KAAK/E,EAAM+B,EAAC,CAAC;AAAA,kBAE3C,WAA2BiD,EAAK,SAAS;AACvB,oBAAIA,EAAK,gBACPD,EAAU,KAAKC,EAAK,YAAY,GAE9BA,EAAK,iBACPD,EAAU,KAAKC,EAAK,aAAa;AAAA,2BAE1BA,EAAK,SAAS,WAAWA,EAAK;AACvC,wBAAIF;AACF,+BAASG,IAAKD,EAAK,eAAe,QAAQjD,IAAIkD,IAAK,GAAGlD,KAAK,GAAG,EAAEA;AAC9D,wBAAAgD,EAAU,KAAKC,EAAK,eAAejD,CAAC,CAAC;AAAA;AAGvC,sBAAAgD,EAAU,KAAKC,EAAK,QAAQ;AAAA;AAEzB,oBAAIA,EAAK,YACdD,EAAU,KAAKC,EAAK,QAAQ;AAAA,cAGjC;AAAA,YACF;AACD,qBAASE,EAAOjD,GAAKhE,GAAI;AACvB,oBAAMkH,IAAyB,oBAAI;AACnC,qBAAOC,EAAInD,CAAG;AACd,uBAASmD,EAAIJ,GAAM;AACjB,oBAAIG,EAAO,IAAIH,CAAI;AACjB,yBAAOG,EAAO,IAAIH,CAAI;AAExB,sBAAMK,IAASC,EAASN,CAAI;AAC5B,uBAAAG,EAAO,IAAIH,GAAMK,CAAM,GAChBA;AAAA,cACR;AACD,uBAASC,EAASN,GAAM;AACtB,oBAAI,MAAM,QAAQA,CAAI;AACpB,yBAAO/G,EAAG+G,EAAK,IAAII,CAAG,CAAC;AAEzB,oBAAIJ,EAAK,SAAS,YAAYA,EAAK,SAAS,QAAQ;AAClD,wBAAMhF,IAAQgF,EAAK,MAAM,IAAII,CAAG;AAChC,yBAAOnH,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,GAAE+G,CAAI,GAAG,IAAI;AAAA,oBACnD,OAAAhF;AAAA,kBACD,CAAA,CAAC;AAAA,gBACH;AACD,oBAAIgF,EAAK,SAAS,YAAY;AAC5B,wBAAMlE,IAAgBkE,EAAK,iBAAiBI,EAAIJ,EAAK,aAAa,GAC5DjE,IAAeiE,EAAK,gBAAgBI,EAAIJ,EAAK,YAAY;AAC/D,yBAAO/G,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,GAAE+G,CAAI,GAAG,IAAI;AAAA,oBACnD,eAAAlE;AAAA,oBACA,cAAAC;AAAA,kBACD,CAAA,CAAC;AAAA,gBACH;AACD,oBAAIiE,EAAK,SAAS,WAAWA,EAAK,gBAAgB;AAChD,wBAAMO,IAAiBP,EAAK,eAAe,IAAII,CAAG,GAC5ClF,IAAWqF,EAAe,CAAC;AACjC,yBAAOtH,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,GAAE+G,CAAI,GAAG,IAAI;AAAA,oBACnD,UAAA9E;AAAA,oBACA,gBAAAqF;AAAA,kBACD,CAAA,CAAC;AAAA,gBACH;AACD,oBAAIP,EAAK,UAAU;AACjB,wBAAM9E,IAAWkF,EAAIJ,EAAK,QAAQ;AAClC,yBAAO/G,EAAG,OAAO,OAAO,OAAO,OAAO,CAAE,GAAE+G,CAAI,GAAG,IAAI;AAAA,oBACnD,UAAA9E;AAAA,kBACD,CAAA,CAAC;AAAA,gBACH;AACD,uBAAOjC,EAAG+G,CAAI;AAAA,cACf;AAAA,YACF;AACD,qBAASQ,EAAUvD,GAAKrD,GAAI6G,GAAc;AACxC,kBAAIJ,IAASI,GACTC,IAAa;AACjB,uBAASC,EAAmBX,GAAM;AAChC,sBAAMY,IAAchH,EAAGoG,CAAI;AAK3B,oBAJIY,MAAgB,WAClBF,IAAa,IACbL,IAASO,IAEPF;AACF,yBAAO;AAAA,cAEV;AACD,qBAAAf,EAAY1C,GAAK0D,CAAkB,GAC5BN;AAAA,YACR;AACD,qBAASQ,EAAY5D,GAAK;AAOxB,kBANIA,EAAI,SAAS,WAAWA,EAAI,SAG5BA,EAAI,SAAS,UAAUA,EAAI,QAG3BA,EAAI,SAAS;AACf,uBAAO;AAAA,YAEV;AACD,qBAAS6D,EAAU7D,GAAK;AACtB,qBAAOuD,EAAUvD,GAAK4D,GAAa,EAAK;AAAA,YACzC;AACD,qBAASE,EAAiBC,GAAY;AACpC,kBAAIA,EAAW,SAAS,GAAG;AACzB,sBAAMC,IAAc/C,EAAQ8C,CAAU;AACtC,gBAAI,CAACC,EAAY,kBAAkB,CAACA,EAAY,UAC9CA,EAAY,QAAQ;AAAA,cAEvB;AACD,qBAAO;AAAA,YACR;AACD,qBAASC,EAAgBjE,GAAK;AAC5B,oBAAMkE,IAAoC,oBAAI,OACxCH,IAAa,CAAA;AACnB,uBAASI,EAAyBpB,GAAM;AAItC,oBAHIA,EAAK,SAAS,kBAChBe,EAAiBC,CAAU,GAEzBhB,EAAK,SAAS,SAAS;AAEzB,sBADAgB,EAAW,KAAKhB,CAAI,GAChBmB,EAAkB,IAAInB,CAAI;AAC5B,2BAAO;AAET,kBAAAmB,EAAkB,IAAInB,CAAI;AAAA,gBAC3B;AAAA,cACF;AACD,uBAASqB,EAAwBrB,GAAM;AACrC,gBAAIA,EAAK,SAAS,WACFgB,EAAW,MACf,SACRD,EAAiBC,CAAU;AAAA,cAGhC;AACD,cAAArB,EAAY1C,GAAKmE,GAA0BC,GAAyB,EAAI;AAAA,YACzE;AACD,qBAASC,EAAcrE,GAAK;AAC1B,qBAAIA,EAAI,SAAS,UAAU,CAACA,EAAI,OACvBA,EAAI,OAAO,KAAK,MAErBA,EAAI,SAAS,aACRA,EAAI,gBAAgB,KAEtBA;AAAA,YACR;AACD,qBAASsE,GAAYtE,GAAK;AACxB,qBAAOiD,EAAOjD,GAAKqE,CAAa;AAAA,YACjC;AACD,gBAAIE,KAAa,CAACvE,GAAKwE,MAAYxE,KAAOA,EAAI,SAAS,UAAUA,EAAI,QAAQwE,KAAWA,EAAQ,SAAS;AACzG,qBAASC,EAAgCzE,GAAK;AAC5C,kBAAI,CAACA;AACH,uBAAOA;AAET,kBAAIuC,EAASvC,CAAG,KAAKA,EAAI,SAAS,QAAQ;AACxC,sBAAMjC,IAAQyE,EAAYxC,CAAG;AAC7B,uBAAOjC,EAAM,SAAS,KAAKwG,GAAW,GAAGxG,EAAM,MAAM,EAAE,CAAC;AACtD,kBAAAA,EAAM,UAAU;AAElB,oBAAIA,EAAM,SAAS,GAAG;AACpB,wBAAM2G,IAAWD,EAAgCxD,EAAQlD,CAAK,CAAC;AAC/D,kBAAAA,EAAMA,EAAM,SAAS,CAAC,IAAI2G;AAAA,gBAC3B;AACD,uBAAO,MAAM,QAAQ1E,CAAG,IAAIjC,IAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,GAAIiC,CAAG,GAAG,CAAA,GAAI;AAAA,kBAC5E,OAAAjC;AAAA,gBAChB,CAAe;AAAA,cACF;AACD,sBAAQiC,EAAI,MAAI;AAAA,gBACd,KAAK;AAAA,gBACL,KAAK;AAAA,gBACL,KAAK;AAAA,gBACL,KAAK;AAAA,gBACL,KAAK;AAAA,gBACL,KAAK,SAAS;AACZ,wBAAM/B,IAAWwG,EAAgCzE,EAAI,QAAQ;AAC7D,yBAAO,OAAO,OAAO,OAAO,OAAO,IAAIA,CAAG,GAAG,IAAI;AAAA,oBAC/C,UAAA/B;AAAA,kBAClB,CAAiB;AAAA,gBACF;AAAA,gBACD,KAAK,YAAY;AACf,wBAAMY,IAAgB4F,EAAgCzE,EAAI,aAAa,GACjElB,IAAe2F,EAAgCzE,EAAI,YAAY;AACrE,yBAAO,OAAO,OAAO,OAAO,OAAO,IAAIA,CAAG,GAAG,IAAI;AAAA,oBAC/C,eAAAnB;AAAA,oBACA,cAAAC;AAAA,kBAClB,CAAiB;AAAA,gBACF;AAAA,cACF;AACD,qBAAOkB;AAAA,YACR;AACD,qBAAS2E,GAAsB3E,GAAK;AAClC,qBAAOyE,EAAgCG,EAAS5E,CAAG,CAAC;AAAA,YACrD;AACD,qBAAS6E,EAAW7E,GAAK;AACvB,sBAAQA,EAAI,MAAI;AAAA,gBACd,KAAK;AACH,sBAAIA,EAAI,MAAM,MAAM,CAAC8E,MAASA,MAAS,EAAE;AACvC,2BAAO;AAET;AAAA,gBACF,KAAK;AACH,sBAAI,CAAC9E,EAAI,YAAY,CAACA,EAAI,MAAM,CAACA,EAAI,SAAS,CAACA,EAAI;AACjD,2BAAO;AAET,sBAAIA,EAAI,SAAS,SAAS,WAAWA,EAAI,SAAS,OAAOA,EAAI,MAAMA,EAAI,SAAS,UAAUA,EAAI,SAASA,EAAI,SAAS,mBAAmBA,EAAI;AACzI,2BAAOA,EAAI;AAEb;AAAA,gBACF,KAAK;AAAA,gBACL,KAAK;AAAA,gBACL,KAAK;AAAA,gBACL,KAAK;AACH,sBAAI,CAACA,EAAI;AACP,2BAAO;AAET;AAAA,gBACF,KAAK;AACH,sBAAI,CAACA,EAAI,gBAAgB,CAACA,EAAI;AAC5B,2BAAO;AAET;AAAA,cACH;AACD,kBAAI,CAACuC,EAASvC,CAAG;AACf,uBAAOA;AAET,oBAAMjC,IAAQ,CAAA;AACd,yBAAW+G,KAAQtC,EAAYxC,CAAG,GAAG;AACnC,oBAAI,CAAC8E;AACH;AAEF,sBAAM,CAACC,GAAa,GAAGC,CAAS,IAAIzC,EAASuC,CAAI,IAAItC,EAAYsC,CAAI,IAAI,CAACA,CAAI;AAC9E,gBAAI,OAAOC,KAAgB,YAAY,OAAO9D,EAAQlD,CAAK,KAAM,WAC/DA,EAAMA,EAAM,SAAS,CAAC,KAAKgH,IAE3BhH,EAAM,KAAKgH,CAAW,GAExBhH,EAAM,KAAK,GAAGiH,CAAS;AAAA,cACxB;AACD,qBAAIjH,EAAM,WAAW,IACZ,KAELA,EAAM,WAAW,IACZA,EAAM,CAAC,IAET,MAAM,QAAQiC,CAAG,IAAIjC,IAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,GAAIiC,CAAG,GAAG,CAAA,GAAI;AAAA,gBAC5E,OAAAjC;AAAA,cACd,CAAa;AAAA,YACF;AACD,qBAAS6G,EAAS5E,GAAK;AACrB,qBAAOiD,EAAOjD,GAAK,CAACiF,MAAeJ,EAAWI,CAAU,CAAC;AAAA,YAC1D;AACD,qBAASC,EAAenH,GAAO;AAC7B,oBAAMoH,IAAW,CAAA,GACXH,IAAYjH,EAAM,OAAO,OAAO;AACtC,qBAAOiH,EAAU,SAAS,KAAG;AAC3B,sBAAMF,IAAOE,EAAU;AACvB,oBAAKF,GAGL;AAAA,sBAAIvC,EAASuC,CAAI,GAAG;AAClB,oBAAAE,EAAU,QAAQ,GAAGxC,EAAYsC,CAAI,CAAC;AACtC;AAAA,kBACD;AACD,sBAAIK,EAAS,SAAS,KAAK,OAAOlE,EAAQkE,CAAQ,KAAM,YAAY,OAAOL,KAAS,UAAU;AAC5F,oBAAAK,EAASA,EAAS,SAAS,CAAC,KAAKL;AACjC;AAAA,kBACD;AACD,kBAAAK,EAAS,KAAKL,CAAI;AAAA;AAAA,cACnB;AACD,qBAAOK;AAAA,YACR;AACD,qBAASC,EAAapF,GAAK;AACzB,qBAAOiD,EAAOjD,GAAK,CAACiF,MACd,MAAM,QAAQA,CAAU,IACnBC,EAAeD,CAAU,IAE7BA,EAAW,QAGT,OAAO,OAAO,OAAO,OAAO,IAAIA,CAAU,GAAG,IAAI;AAAA,gBACtD,OAAOC,EAAeD,EAAW,KAAK;AAAA,cACtD,CAAe,IAJQA,CAKV;AAAA,YACF;AACD,qBAASI,EAAiBrF,GAAK;AAC7B,qBAAOiD,EAAOjD,GAAK,CAACiF,MAAe,OAAOA,KAAe,YAAYA,EAAW,SAAS;AAAA,CAAI,IAAIK,EAAqBL,CAAU,IAAIA,CAAU;AAAA,YAC/I;AACD,qBAASK,EAAqB9E,GAAM;AAClC,kBAAI+E,IAAc,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAS,UAAU,CAAC,IAAI9F;AACnF,qBAAOE,EAAK4F,GAAa/E,EAAK,MAAM;AAAA,CAAI,CAAC,EAAE;AAAA,YAC5C;AACD,qBAASgF,EAAWxF,GAAK;AACvB,kBAAIA,EAAI,SAAS;AACf,uBAAO;AAAA,YAEV;AACD,qBAASyF,EAASzF,GAAK;AACrB,qBAAOuD,EAAUvD,GAAKwF,GAAY,EAAK;AAAA,YACxC;AACD,YAAA3H,EAAQ,UAAU;AAAA,cAChB,UAAA0E;AAAA,cACA,aAAAC;AAAA,cACA,WAAAqB;AAAA,cACA,aAAAnB;AAAA,cACA,WAAAa;AAAA,cACA,QAAAN;AAAA,cACA,iBAAAgB;AAAA,cACA,aAAAK;AAAA,cACA,uBAAAK;AAAA,cACA,gBAAAO;AAAA,cACA,cAAAE;AAAA,cACA,UAAAR;AAAA,cACA,sBAAAU;AAAA,cACA,kBAAAD;AAAA,cACA,UAAAI;AAAA,YACZ;AAAA,UACS;AAAA,QACT,CAAO,GACGC,KAAsB7I,EAAY;AAAA,UACpC,8BAA8Be,GAAUC,GAAS;AAE/C,YAAAH;AACA,gBAAI;AAAA,cACF,yBAAAgD;AAAA,YACD,IAAGJ,GAAmB,GACnBW,IAAUD,MACVqB,IAAiBH,MACjB;AAAA,cACF,MAAAvD;AAAA,cACA,QAAAe;AAAA,cACA,QAAA1B;AAAA,YACD,IAAGL,GAAoB,GACpB;AAAA,cACF,UAAA4E;AAAA,cACA,aAAAC;AAAA,YACD,IAAGF,GAAiB,GACjBqD,GACAC,IAAa,GACbC,IAAY;AAChB,qBAASC,IAAa;AACpB,qBAAO;AAAA,gBACL,OAAO;AAAA,gBACP,QAAQ;AAAA,gBACR,OAAO,CAAE;AAAA,cACvB;AAAA,YACW;AACD,qBAASC,EAAWC,GAAKC,GAAS;AAChC,qBAAOC,GAAYF,GAAK;AAAA,gBACtB,MAAM;AAAA,cACP,GAAEC,CAAO;AAAA,YACX;AACD,qBAASE,EAAUC,GAASC,GAAYJ,GAAS;AAC/C,qBAAII,MAAe,OAAO,oBACjBD,EAAQ,QAAQN,MAErBO,IAAa,IACRH,GAAYE,GAAS;AAAA,gBAC1B,MAAM;AAAA,cACP,GAAEH,CAAO,IAEPI,IAGDA,EAAW,SAAS,SACf,OAAO,OAAO,OAAO,OAAO,IAAID,CAAO,GAAG,IAAI;AAAA,gBACnD,MAAMA;AAAA,cACtB,CAAe,IAGIF,GAAYE,GAAS;AAAA,gBAC1B,MAFgB,OAAOC,KAAe,WAAW,gBAAgB;AAAA,gBAGjE,GAAGA;AAAA,cACJ,GAAEJ,CAAO,IAXDG;AAAA,YAYV;AACD,qBAASF,GAAYF,GAAKM,GAASL,GAAS;AAC1C,oBAAMM,IAAQD,EAAQ,SAAS,WAAWN,EAAI,MAAM,MAAM,GAAG,EAAE,IAAI,CAAC,GAAGA,EAAI,OAAOM,CAAO;AACzF,kBAAIvL,IAAQ,IACRyL,IAAS,GACTC,IAAW,GACXC,IAAa;AACjB,yBAAW5B,KAAQyB;AACjB,wBAAQzB,EAAK,MAAI;AAAA,kBACf,KAAK;AACH,oBAAA6B,KACIV,EAAQ,UACVW,EAAQ,CAAC,IAETC,EAAUZ,EAAQ,QAAQ;AAE5B;AAAA,kBACF,KAAK;AACH,oBAAAU,KACA5L,KAAS+J,EAAK,GACd0B,KAAU1B,EAAK,EAAE;AACjB;AAAA,kBACF,KAAK;AACH,oBAAA2B,KAAY,GACZC,KAAc5B,EAAK;AACnB;AAAA,kBACF;AACE,0BAAM,IAAI,MAAM,oBAAoBA,EAAK,OAAO;AAAA,gBACnD;AAEH,qBAAAgC,KACO,OAAO,OAAO,OAAO,OAAO,IAAId,CAAG,GAAG,IAAI;AAAA,gBAC/C,OAAAjL;AAAA,gBACA,QAAAyL;AAAA,gBACA,OAAAD;AAAA,cACd,CAAa;AACD,uBAASK,EAAQG,GAAO;AACtB,gBAAAhM,KAAS,IAAI,OAAOgM,CAAK,GACzBP,KAAUP,EAAQ,WAAWc;AAAA,cAC9B;AACD,uBAASF,EAAUE,GAAO;AACxB,gBAAAhM,KAAS,IAAI,OAAOgM,CAAK,GACzBP,KAAUO;AAAA,cACX;AACD,uBAASJ,IAAQ;AACf,gBAAIV,EAAQ,UACVe,MAEAF;cAEH;AACD,uBAASE,IAAY;AACnB,gBAAIP,IAAW,KACbG,EAAQH,CAAQ,GAElBQ;cACD;AACD,uBAASH,IAAc;AACrB,gBAAIJ,IAAa,KACfG,EAAUH,CAAU,GAEtBO;cACD;AACD,uBAASA,IAAY;AACnB,gBAAAR,IAAW,GACXC,IAAa;AAAA,cACd;AAAA,YACF;AACD,qBAASvH,GAAK+H,GAAK;AACjB,kBAAIA,EAAI,WAAW;AACjB,uBAAO;AAET,kBAAIC,IAAY;AAChB,qBAAOD,EAAI,SAAS,KAAK,OAAOjG,EAAQiG,CAAG,KAAM,YAAY,WAAW,KAAKjG,EAAQiG,CAAG,CAAC;AACvF,gBAAAC,KAAaD,EAAI,IAAK,EAAC;AAEzB,kBAAIA,EAAI,SAAS,KAAK,OAAOjG,EAAQiG,CAAG,KAAM,UAAU;AACtD,sBAAME,IAAUnG,EAAQiG,CAAG,EAAE,QAAQ,WAAW,EAAE;AAClD,gBAAAC,KAAalG,EAAQiG,CAAG,EAAE,SAASE,EAAQ,QAC3CF,EAAIA,EAAI,SAAS,CAAC,IAAIE;AAAA,cACvB;AACD,qBAAOD;AAAA,YACR;AACD,qBAASE,EAAKC,GAAMC,GAAcvF,GAAOwF,GAAeC,GAAY;AAClE,kBAAIC,IAAUH,EAAa;AAC3B,oBAAMI,IAAO,CAACL,CAAI,GACZJ,IAAM,CAAA;AACZ,qBAAOlF,KAAS,KAAG;AACjB,oBAAI2F,EAAK,WAAW,GAAG;AACrB,sBAAID,MAAY;AACd,2BAAO;AAET,kBAAAC,EAAK,KAAKJ,EAAa,EAAEG,CAAO,CAAC;AACjC;AAAA,gBACD;AACD,sBAAM;AAAA,kBACJ,MAAAE;AAAA,kBACA,KAAA5H;AAAA,gBAChB,IAAkB2H,EAAK;AACT,oBAAI,OAAO3H,KAAQ;AACjB,kBAAAkH,EAAI,KAAKlH,CAAG,GACZgC,KAASK,EAAerC,CAAG;AAAA,yBAClBuC,EAASvC,CAAG,KAAKA,EAAI,SAAS,QAAQ;AAC/C,wBAAMjC,IAAQyE,EAAYxC,CAAG;AAC7B,2BAASF,IAAI/B,EAAM,SAAS,GAAG+B,KAAK,GAAGA;AACrC,oBAAA6H,EAAK,KAAK;AAAA,sBACR,MAAAC;AAAA,sBACA,KAAK7J,EAAM+B,CAAC;AAAA,oBAChC,CAAmB;AAAA,gBAEnB;AACgB,0BAAQE,EAAI,MAAI;AAAA,oBACd,KAAK;AAAA,oBACL,KAAK;AAAA,oBACL,KAAK;AAAA,oBACL,KAAK;AACH,sBAAA2H,EAAK,KAAK;AAAA,wBACR,MAAAC;AAAA,wBACA,KAAK5H,EAAI;AAAA,sBAC/B,CAAqB;AACD;AAAA,oBACF,KAAK;AACH,sBAAAgC,KAAS7C,GAAK+H,CAAG;AACjB;AAAA,oBACF,KAAK,SAAS;AACZ,0BAAIO,KAAczH,EAAI;AACpB,+BAAO;AAET,4BAAM6H,IAAY7H,EAAI,QAAQ4F,IAAagC,GACrC3J,IAAW+B,EAAI,kBAAkB6H,MAAcjC,IAAa3E,EAAQjB,EAAI,cAAc,IAAIA,EAAI;AACpG,sBAAA2H,EAAK,KAAK;AAAA,wBACR,MAAME;AAAA,wBACN,KAAK5J;AAAA,sBAC3B,CAAqB;AACD;AAAA,oBACD;AAAA,oBACD,KAAK,YAAY;AAEf,4BAAMA,KADY+B,EAAI,UAAU2F,EAAa3F,EAAI,OAAO,KAAK6F,IAAY+B,OAC1ChC,IAAa5F,EAAI,gBAAgBA,EAAI;AACpE,sBAAI/B,KACF0J,EAAK,KAAK;AAAA,wBACR,MAAAC;AAAA,wBACA,KAAK3J;AAAA,sBAC7B,CAAuB;AAEH;AAAA,oBACD;AAAA,oBACD,KAAK;AACH,0BAAI2J,MAAShC,KAAc5F,EAAI;AAC7B,+BAAO;AAET,sBAAKA,EAAI,SACPkH,EAAI,KAAK,GAAG,GACZlF;AAEF;AAAA,oBACF,KAAK;AACH,sBAAAwF,IAAgB;AAChB;AAAA,oBACF,KAAK;AACH,0BAAIA;AACF,+BAAO;AAET;AAAA,kBACH;AAAA,cAEJ;AACD,qBAAO;AAAA,YACR;AACD,qBAASM,GAAiB9H,GAAKiG,GAAS;AACtC,cAAAN,IAAe,CAAA;AACf,oBAAM3D,IAAQiE,EAAQ,YAChB8B,IAAUrH,EAAwBuF,EAAQ,SAAS;AACzD,kBAAI+B,IAAM;AACV,oBAAML,IAAO,CAAC;AAAA,gBACZ,KAAK7B,EAAY;AAAA,gBACjB,MAAMF;AAAA,gBACN,KAAA5F;AAAA,cACd,CAAa,GACKkH,IAAM,CAAA;AACZ,kBAAIe,IAAkB;AACtB,oBAAMjJ,IAAa,CAAA;AACnB,qBAAO2I,EAAK,SAAS,KAAG;AACtB,sBAAM;AAAA,kBACJ,KAAA3B;AAAA,kBACA,MAAA4B;AAAA,kBACA,KAAK7E;AAAA,gBACrB,IAAkB4E,EAAK;AACT,oBAAI,OAAO5E,KAAS,UAAU;AAC5B,wBAAMmF,IAAYH,MAAY;AAAA,IAAOhF,EAAK,QAAQ,OAAOgF,CAAO,IAAIhF;AACpE,kBAAAmE,EAAI,KAAKgB,CAAS,GAClBF,KAAO3F,EAAe6F,CAAS;AAAA,gBAC/C,WAAyB3F,EAASQ,CAAI,GAAG;AACzB,wBAAMhF,IAAQyE,EAAYO,CAAI;AAC9B,2BAASjD,IAAI/B,EAAM,SAAS,GAAG+B,KAAK,GAAGA;AACrC,oBAAA6H,EAAK,KAAK;AAAA,sBACR,KAAA3B;AAAA,sBACA,MAAA4B;AAAA,sBACA,KAAK7J,EAAM+B,CAAC;AAAA,oBAChC,CAAmB;AAAA,gBAEnB;AACgB,0BAAQiD,EAAK,MAAI;AAAA,oBACf,KAAK;AACH,sBAAAmE,EAAI,KAAKxH,EAAO,WAAW;AAC3B;AAAA,oBACF,KAAK;AACH,sBAAAiI,EAAK,KAAK;AAAA,wBACR,KAAK5B,EAAWC,GAAKC,CAAO;AAAA,wBAC5B,MAAA2B;AAAA,wBACA,KAAK7E,EAAK;AAAA,sBAChC,CAAqB;AACD;AAAA,oBACF,KAAK;AACH,sBAAA4E,EAAK,KAAK;AAAA,wBACR,KAAKxB,EAAUH,GAAKjD,EAAK,GAAGkD,CAAO;AAAA,wBACnC,MAAA2B;AAAA,wBACA,KAAK7E,EAAK;AAAA,sBAChC,CAAqB;AACD;AAAA,oBACF,KAAK;AACH,sBAAAiF,KAAO7I,GAAK+H,CAAG;AACf;AAAA,oBACF,KAAK;AACH,8BAAQU,GAAI;AAAA,wBACV,KAAK/B;AACH,8BAAI,CAACoC,GAAiB;AACpB,4BAAAN,EAAK,KAAK;AAAA,8BACR,KAAA3B;AAAA,8BACA,MAAMjD,EAAK,QAAQ6C,IAAaC;AAAA,8BAChC,KAAK9C,EAAK;AAAA,4BACtC,CAA2B;AACD;AAAA,0BACD;AAAA,wBACH,KAAK6C,GAAY;AACf,0BAAAqC,IAAkB;AAClB,gCAAMX,IAAO;AAAA,4BACX,KAAAtB;AAAA,4BACA,MAAMH;AAAA,4BACN,KAAK9C,EAAK;AAAA,0BACpC,GAC8BoF,IAAMnG,IAAQgG,GACdR,IAAgBxI,EAAW,SAAS;AAC1C,8BAAI,CAAC+D,EAAK,SAASsE,EAAKC,GAAMK,GAAMQ,GAAKX,CAAa;AACpD,4BAAAG,EAAK,KAAKL,CAAI;AAAA,mCAEVvE,EAAK,gBAAgB;AACvB,kCAAMqF,KAAenH,EAAQ8B,EAAK,cAAc;AAChD,gCAAIA,EAAK,OAAO;AACd,8BAAA4E,EAAK,KAAK;AAAA,gCACR,KAAA3B;AAAA,gCACA,MAAMJ;AAAA,gCACN,KAAKwC;AAAA,8BACrC,CAA+B;AACD;AAAA,4BAC9B;AAC8B,uCAAStI,KAAI,GAAGA,KAAIiD,EAAK,eAAe,SAAS,GAAGjD;AAClD,oCAAIA,MAAKiD,EAAK,eAAe,QAAQ;AACnC,kCAAA4E,EAAK,KAAK;AAAA,oCACR,KAAA3B;AAAA,oCACA,MAAMJ;AAAA,oCACN,KAAKwC;AAAA,kCACzC,CAAmC;AACD;AAAA,gCAClC,OAAuC;AACL,wCAAMC,KAAQtF,EAAK,eAAejD,EAAC,GAC7BwI,KAAM;AAAA,oCACV,KAAAtC;AAAA,oCACA,MAAMH;AAAA,oCACN,KAAKwC;AAAA,kCACzC;AACkC,sCAAIhB,EAAKiB,IAAKX,GAAMQ,GAAKX,CAAa,GAAG;AACvC,oCAAAG,EAAK,KAAKW,EAAG;AACb;AAAA,kCACD;AAAA,gCACF;AAAA,0BAGjC;AAC4B,4BAAAX,EAAK,KAAK;AAAA,8BACR,KAAA3B;AAAA,8BACA,MAAMJ;AAAA,8BACN,KAAK7C,EAAK;AAAA,4BACxC,CAA6B;AAGL;AAAA,wBACD;AAAA,sBACF;AACD,sBAAIA,EAAK,OACP4C,EAAa5C,EAAK,EAAE,IAAI9B,EAAQ0G,CAAI,EAAE;AAExC;AAAA,oBACF,KAAK,QAAQ;AACX,4BAAMQ,IAAMnG,IAAQgG,GACd;AAAA,wBACJ,OAAAjK;AAAA,sBACD,IAAGgF;AACJ,0BAAIhF,EAAM,WAAW;AACnB;AAEF,4BAAM,CAACwK,GAASC,EAAU,IAAIzK,GACxB0K,KAAiB;AAAA,wBACrB,KAAAzC;AAAA,wBACA,MAAMH;AAAA,wBACN,KAAK0C;AAAA,sBAC3B,GAC0BG,KAAkB;AAAA,wBACtB,KAAA1C;AAAA,wBACA,MAAMJ;AAAA,wBACN,KAAK2C;AAAA,sBAC3B,GAC0BI,KAActB,EAAKoB,IAAgB,CAAE,GAAEN,GAAKnJ,EAAW,SAAS,GAAG,EAAI;AAC7E,0BAAIjB,EAAM,WAAW,GAAG;AACtB,wBAAI4K,KACFhB,EAAK,KAAKc,EAAc,IAExBd,EAAK,KAAKe,EAAe;AAE3B;AAAA,sBACD;AACD,4BAAME,KAAoB;AAAA,wBACxB,KAAA5C;AAAA,wBACA,MAAMH;AAAA,wBACN,KAAK2C;AAAA,sBAC3B,GAC0BK,KAAqB;AAAA,wBACzB,KAAA7C;AAAA,wBACA,MAAMJ;AAAA,wBACN,KAAK4C;AAAA,sBAC3B;AACoB,0BAAIzK,EAAM,WAAW,GAAG;AACtB,wBAAI4K,KACFhB,EAAK,KAAKiB,IAAmBH,EAAc,IAE3Cd,EAAK,KAAKkB,IAAoBH,EAAe;AAE/C;AAAA,sBACD;AACD,sBAAA3K,EAAM,OAAO,GAAG,CAAC;AACjB,4BAAM+K,KAAe;AAAA,wBACnB,KAAA9C;AAAA,wBACA,MAAA4B;AAAA,wBACA,KAAKjJ,EAAKZ,CAAK;AAAA,sBACrC,GAC0BgL,KAAgBhL,EAAM,CAAC;AAO7B,sBADkCsJ,EALG;AAAA,wBACnC,KAAArB;AAAA,wBACA,MAAMH;AAAA,wBACN,KAAK,CAAC0C,GAASC,IAAYO,EAAa;AAAA,sBAC9D,GACyF,CAAE,GAAEZ,GAAKnJ,EAAW,SAAS,GAAG,EAAI,IAEvG2I,EAAK,KAAKmB,IAAcF,IAAmBH,EAAc,IAChDE,KACThB,EAAK,KAAKmB,IAAcD,IAAoBJ,EAAc,IAE1Dd,EAAK,KAAKmB,IAAcD,IAAoBH,EAAe;AAE7D;AAAA,oBACD;AAAA,oBACD,KAAK;AAAA,oBACL,KAAK,mBAAmB;AACtB,4BAAMb,IAAY9E,EAAK,UAAU4C,EAAa5C,EAAK,OAAO,IAAI6E;AAC9D,0BAAIC,MAAcjC,GAAY;AAC5B,8BAAM/G,IAAgBkE,EAAK,SAAS,aAAaA,EAAK,gBAAgBA,EAAK,SAASA,EAAK,WAAW/E,EAAO+E,EAAK,QAAQ;AACxH,wBAAIlE,KACF8I,EAAK,KAAK;AAAA,0BACR,KAAA3B;AAAA,0BACA,MAAA4B;AAAA,0BACA,KAAK/I;AAAA,wBAC/B,CAAyB;AAAA,sBAEJ;AACD,0BAAIgJ,MAAchC,GAAW;AAC3B,8BAAM/G,IAAeiE,EAAK,SAAS,aAAaA,EAAK,eAAeA,EAAK,SAAS/E,EAAO+E,EAAK,QAAQ,IAAIA,EAAK;AAC/G,wBAAIjE,KACF6I,EAAK,KAAK;AAAA,0BACR,KAAA3B;AAAA,0BACA,MAAA4B;AAAA,0BACA,KAAK9I;AAAA,wBAC/B,CAAyB;AAAA,sBAEJ;AACD;AAAA,oBACD;AAAA,oBACD,KAAK;AACH,sBAAAE,EAAW,KAAK;AAAA,wBACd,KAAAgH;AAAA,wBACA,MAAA4B;AAAA,wBACA,KAAK7E,EAAK;AAAA,sBAChC,CAAqB;AACD;AAAA,oBACF,KAAK;AACH,sBAAI/D,EAAW,SAAS,KACtB2I,EAAK,KAAK;AAAA,wBACR,KAAA3B;AAAA,wBACA,MAAA4B;AAAA,wBACA,KAAK;AAAA,0BACH,MAAM;AAAA,0BACN,MAAM;AAAA,wBACP;AAAA,sBACzB,CAAuB;AAEH;AAAA,oBACF,KAAK;AACH,8BAAQA,GAAI;AAAA,wBACV,KAAK/B;AACH,8BAAK9C,EAAK;AAOR,4BAAAkF,IAAkB;AAAA,+BAPJ;AACd,4BAAKlF,EAAK,SACRmE,EAAI,KAAK,GAAG,GACZc,KAAO;AAET;AAAA,0BAC1B;AAAA,wBAGsB,KAAKpC;AACH,8BAAI5G,EAAW,SAAS,GAAG;AACzB,4BAAA2I,EAAK,KAAK;AAAA,8BACR,KAAA3B;AAAA,8BACA,MAAA4B;AAAA,8BACA,KAAK7E;AAAA,4BACjC,GAA6B,GAAG/D,EAAW,QAAO,CAAE,GAC1BA,EAAW,SAAS;AACpB;AAAA,0BACD;AACD,0BAAI+D,EAAK,UACHiD,EAAI,QACNkB,EAAI,KAAKa,GAAS/B,EAAI,KAAK,KAAK,GAChCgC,IAAMhC,EAAI,KAAK,WAEfkB,EAAI,KAAKa,CAAO,GAChBC,IAAM,MAGRA,KAAO7I,GAAK+H,CAAG,GACfA,EAAI,KAAKa,IAAU/B,EAAI,KAAK,GAC5BgC,IAAMhC,EAAI;AAEZ;AAAA,sBACH;AACD;AAAA,oBACF,KAAK;AACH,sBAAA2B,EAAK,KAAK;AAAA,wBACR,KAAA3B;AAAA,wBACA,MAAA4B;AAAA,wBACA,KAAK7E,EAAK;AAAA,sBAChC,CAAqB;AACD;AAAA,kBAEH;AAEH,gBAAI4E,EAAK,WAAW,KAAK3I,EAAW,SAAS,MAC3C2I,EAAK,KAAK,GAAG3I,EAAW,QAAS,CAAA,GACjCA,EAAW,SAAS;AAAA,cAEvB;AACD,oBAAMgK,IAAyB9B,EAAI,QAAQxH,EAAO,WAAW;AAC7D,kBAAIsJ,MAA2B,IAAI;AACjC,sBAAMC,IAA8B/B,EAAI,QAAQxH,EAAO,aAAasJ,IAAyB,CAAC,GACxFE,IAAehC,EAAI,MAAM,GAAG8B,CAAsB,EAAE,KAAK,EAAE,GAC3DG,IAAejC,EAAI,MAAM8B,IAAyB,GAAGC,CAA2B,EAAE,KAAK,EAAE,GACzFG,IAAclC,EAAI,MAAM+B,IAA8B,CAAC,EAAE,KAAK,EAAE;AACtE,uBAAO;AAAA,kBACL,WAAWC,IAAeC,IAAeC;AAAA,kBACzC,iBAAiBF,EAAa;AAAA,kBAC9B,gBAAgBC;AAAA,gBAChC;AAAA,cACa;AACD,qBAAO;AAAA,gBACL,WAAWjC,EAAI,KAAK,EAAE;AAAA,cACpC;AAAA,YACW;AACD,YAAArJ,EAAQ,UAAU;AAAA,cAChB,kBAAAiK;AAAA,YACZ;AAAA,UACS;AAAA,QACT,CAAO,GACGuB,KAAoBxM,EAAY;AAAA,UAClC,4BAA4Be,GAAUC,GAAS;AAE7C,YAAAH;AACA,gBAAI;AAAA,cACF,UAAA6E;AAAA,cACA,aAAAC;AAAA,YACD,IAAGF,GAAiB;AACrB,qBAASgH,EAAWtJ,GAAK;AACvB,kBAAI,CAACA;AACH,uBAAO;AAET,kBAAIuC,EAASvC,CAAG,GAAG;AACjB,sBAAMpD,IAAM,CAAA;AACZ,2BAAWkI,KAAQtC,EAAYxC,CAAG;AAChC,sBAAIuC,EAASuC,CAAI;AACf,oBAAAlI,EAAI,KAAK,GAAG0M,EAAWxE,CAAI,EAAE,KAAK;AAAA,uBAC7B;AACL,0BAAMyE,IAAYD,EAAWxE,CAAI;AACjC,oBAAIyE,MAAc,MAChB3M,EAAI,KAAK2M,CAAS;AAAA,kBAErB;AAEH,uBAAO;AAAA,kBACL,MAAM;AAAA,kBACN,OAAO3M;AAAA,gBACvB;AAAA,cACa;AACD,qBAAIoD,EAAI,SAAS,aACR,OAAO,OAAO,OAAO,OAAO,IAAIA,CAAG,GAAG,IAAI;AAAA,gBAC/C,eAAesJ,EAAWtJ,EAAI,aAAa;AAAA,gBAC3C,cAAcsJ,EAAWtJ,EAAI,YAAY;AAAA,cACzD,CAAe,IAECA,EAAI,SAAS,UACR,OAAO,OAAO,OAAO,OAAO,IAAIA,CAAG,GAAG,IAAI;AAAA,gBAC/C,UAAUsJ,EAAWtJ,EAAI,QAAQ;AAAA,gBACjC,gBAAgBA,EAAI,kBAAkBA,EAAI,eAAe,IAAIsJ,CAAU;AAAA,cACvF,CAAe,IAECtJ,EAAI,SAAS,SACR;AAAA,gBACL,MAAM;AAAA,gBACN,OAAOA,EAAI,MAAM,IAAIsJ,CAAU;AAAA,cAC/C,IAEgBtJ,EAAI,WACC,OAAO,OAAO,OAAO,OAAO,IAAIA,CAAG,GAAG,IAAI;AAAA,gBAC/C,UAAUsJ,EAAWtJ,EAAI,QAAQ;AAAA,cACjD,CAAe,IAEIA;AAAA,YACR;AACD,qBAASwJ,EAAgBxJ,GAAK;AAC5B,oBAAMyJ,IAAiC,uBAAO,OAAO,IAAI,GACnDC,IAAqC,oBAAI;AAC/C,qBAAOC,EAASL,EAAWtJ,CAAG,CAAC;AAC/B,uBAAS2J,EAAS5G,GAAMtC,GAAOmJ,GAAa;AAC1C,oBAAI,OAAO7G,KAAS;AAClB,yBAAO,KAAK,UAAUA,CAAI;AAE5B,oBAAIR,EAASQ,CAAI,GAAG;AAClB,wBAAM8G,IAAUrH,EAAYO,CAAI,EAAE,IAAI4G,CAAQ,EAAE,OAAO,OAAO;AAC9D,yBAAOE,EAAQ,WAAW,IAAIA,EAAQ,CAAC,IAAI,IAAIA,EAAQ,KAAK,IAAI;AAAA,gBACjE;AACD,oBAAI9G,EAAK,SAAS,QAAQ;AACxB,wBAAM+G,IAAkB,MAAM,QAAQF,CAAW,KAAKA,EAAYnJ,IAAQ,CAAC,KAAKmJ,EAAYnJ,IAAQ,CAAC,EAAE,SAAS;AAChH,yBAAIsC,EAAK,UACA+G,IAAkB,gBAAgB,kCAEvC/G,EAAK,OACA+G,IAAkB,aAAa,+BAEpC/G,EAAK,OACA,aAEF;AAAA,gBACR;AACD,oBAAIA,EAAK,SAAS;AAEhB,yBADsB,MAAM,QAAQ6G,CAAW,KAAKA,EAAYnJ,IAAQ,CAAC,KAAKmJ,EAAYnJ,IAAQ,CAAC,EAAE,SAAS,UAAUmJ,EAAYnJ,IAAQ,CAAC,EAAE,OACxH,SAAS;AAElC,oBAAIsC,EAAK,SAAS;AAChB,yBAAO;AAET,oBAAIA,EAAK,SAAS;AAChB,yBAAO,YAAY4G,EAAS5G,EAAK,QAAQ,IAAI;AAE/C,oBAAIA,EAAK,SAAS;AAChB,yBAAOA,EAAK,MAAM,OAAO,oBAAoB,kBAAkB4G,EAAS5G,EAAK,QAAQ,IAAI,MAAMA,EAAK,IAAI,IAAI,YAAY4G,EAAS5G,EAAK,QAAQ,IAAI,MAAMA,EAAK,EAAE,SAAS,SAAS,gBAAgB4G,EAAS5G,EAAK,QAAQ,IAAI,MAAM,WAAW,KAAK,UAAUA,EAAK,CAAC,IAAI,OAAO4G,EAAS5G,EAAK,QAAQ,IAAI;AAExS,oBAAIA,EAAK,SAAS;AAChB,yBAAO,aAAa4G,EAAS5G,EAAK,aAAa,KAAKA,EAAK,eAAe,OAAO4G,EAAS5G,EAAK,YAAY,IAAI,OAAOA,EAAK,WAAYA,EAAK,eAAwB,KAAT,UAAe,gBAAgBgH,EAAahH,EAAK,OAAO,QAAQ,MAAM;AAEjO,oBAAIA,EAAK,SAAS,mBAAmB;AACnC,wBAAMiH,IAAe,CAAA;AACrB,kBAAIjH,EAAK,UACPiH,EAAa,KAAK,cAAc,GAE9BjH,EAAK,WACPiH,EAAa,KAAK,YAAYD,EAAahH,EAAK,OAAO,GAAG;AAE5D,wBAAMkD,IAAU+D,EAAa,SAAS,IAAI,OAAOA,EAAa,KAAK,IAAI,QAAQ;AAC/E,yBAAO,iBAAiBL,EAAS5G,EAAK,QAAQ,IAAIkD;AAAA,gBACnD;AACD,oBAAIlD,EAAK,SAAS,SAAS;AACzB,wBAAMiH,IAAe,CAAA;AACrB,kBAAIjH,EAAK,SAASA,EAAK,UAAU,gBAC/BiH,EAAa,KAAK,mBAAmB,GAEnCjH,EAAK,MACPiH,EAAa,KAAK,OAAOD,EAAahH,EAAK,EAAE,GAAG;AAElD,wBAAMkD,IAAU+D,EAAa,SAAS,IAAI,OAAOA,EAAa,KAAK,IAAI,QAAQ;AAC/E,yBAAIjH,EAAK,iBACA,qBAAqBA,EAAK,eAAe,IAAI,CAAC+B,OAAS6E,EAAS7E,EAAI,CAAC,EAAE,KAAK,GAAG,KAAKmB,OAEtF,SAAS0D,EAAS5G,EAAK,QAAQ,IAAIkD;AAAA,gBAC3C;AACD,oBAAIlD,EAAK,SAAS;AAChB,yBAAO,SAASA,EAAK,MAAM,IAAI,CAAC+B,MAAS6E,EAAS7E,CAAI,CAAC,EAAE,KAAK,IAAI;AAEpE,oBAAI/B,EAAK,SAAS;AAChB,yBAAO,gBAAgB4G,EAAS5G,EAAK,QAAQ,IAAI;AAEnD,oBAAIA,EAAK,SAAS;AAChB,yBAAO;AAET,oBAAIA,EAAK,SAAS;AAChB,yBAAO,SAAS,KAAK,UAAUA,EAAK,KAAK,MAAM4G,EAAS5G,EAAK,QAAQ;AAEvE,sBAAM,IAAI,MAAM,sBAAsBA,EAAK,IAAI;AAAA,cAChD;AACD,uBAASgH,EAAaE,GAAI;AACxB,oBAAI,OAAOA,KAAO;AAChB,yBAAO,KAAK,UAAU,OAAOA,CAAE,CAAC;AAElC,oBAAIA,KAAMR;AACR,yBAAOA,EAAeQ,CAAE;AAE1B,sBAAMC,IAAS,OAAOD,CAAE,EAAE,MAAM,GAAG,EAAE,KAAK;AAC1C,yBAASE,IAAU,KAAKA,KAAW;AACjC,wBAAM7M,IAAM4M,KAAUC,IAAU,IAAI,KAAKA,MAAY;AACrD,sBAAI,CAACT,EAAmB,IAAIpM,CAAG;AAC7B,2BAAAoM,EAAmB,IAAIpM,CAAG,GACnBmM,EAAeQ,CAAE,IAAI,cAAc,KAAK,UAAU3M,CAAG;AAAA,gBAE/D;AAAA,cACF;AAAA,YACF;AACD,YAAAO,EAAQ,UAAU;AAAA,cAChB,iBAAA2L;AAAA,YACZ;AAAA,UACS;AAAA,QACT,CAAO;AACD,QAAA9L,KACA7B,EAAO,UAAU;AAAA,UACf,UAAU8B,GAAsB;AAAA,UAChC,SAAS+H,GAAqB;AAAA,UAC9B,OAAOpD,GAAmB;AAAA,UAC1B,OAAO+G,GAAmB;AAAA,QAClC;AAAA,MACK;AAAA,IACL,CAAG;AACD,WAAOnN,EAAkB;AAAA,EAC3B,CAAC;;ACx7CD,MAAMkO,KAAY,GACZC,KAAkB,IAIlBC,KAAiB;AAAA,EACnB,YAAY;AAAA,EACZ,UAAU;AAAA,EACV,SAAS;AACb;AAEO,SAASC,GAAcvK,GAAU;AACpC,SAAOwK,EAAQ,QAAA,iBAAiBxK,GAAKsK,EAAc,EAAE;AACzD;AAEO,MAAMG,KAAgB,CAACnL,GAAcoL,IAAoBL,OAAoB;AAC1E,QAAAtC,IAAUzI,EAAK,QAAQ;AAAA,CAAI;AAGjC,SAFe,KAAK,IAAIA,EAAK,QAAQyI,MAAY,KAAKzI,EAAK,SAASyI,CAAO,KAE7DsC,KACH/K,IAEAA,EAAK,MAAM,GAAGoL,CAAS,IAAI;AAE1C;AAEO,SAASC,GACZtC,GACA3I,IAAiB,KACjBkL,IAAiB,IACX;AACN,QAAMC,KAASD,IAAQE,EAAM,MAAMA,EAAM,OAAO,MAE1CC,IAAQ1C,EAAM,IAAI,MAAM;AAAA,CAAI,GAC5B2C,IAAU,KAAK,IAAID,EAAM,SAAS,GAAG1C,EAAM,eAAe,GAC1D4C,IAAW,KAAK,IAAID,IAAUZ,IAAW,CAAC,GAC1Cc,IAAS,KAAK,IAAIF,IAAUZ,KAAY,GAAGW,EAAM,MAAM,GAEvDI,IAAgBJ,EAAM,MAAME,GAAUC,CAAM;AAElD,MAAIxL,GAAQ;AACF,UAAA0L,IAAa,IAAI,OAAO/C,EAAM,iBAAiB,IAAIwC,EAAMnL,CAAM;AACrE,IAAAyL,EAAc,OAAOH,IAAUC,IAAW,GAAG,GAAGG,CAAU;AAAA,EAC9D;AAYO,SAVaD,EAAc,IAAI,CAAC7L,GAAM+L,OAAQ;AAC3C,UAAAC,KAAUL,IAAWI,KAAM;AACjC,QAAIE,KAAgBV,EAAM,MAAM,MAAM,OAAOS,EAAO,CAAC;AAErD,WAAAhM,IAAOgM,OAAYN,IAAU,IAAIH,EAAMvL,CAAI,IAAIA,GAC5B,SAASiM,OAAkBjM;AAAA,EAEvC,CACV,EAEkB,KAAK;AAAA,CAAI;AAChC;AAEA,MAAMlB,IAAQ,CAACoN,GAAWC,IAAwB,OACvCC,EAAAA,SAAE,MAAMF,GAAM,EAAE,GAAGlB,IAAgB,GAAGmB,GAAqB,GAGhEE,KAAU,CAACC,MAAed,EAAM,KAAKc,CAAE,GACvCC,yBAAqB;AAEpB,SAASC,GAAYpQ,GAAqB;AAC7C,MAAImQ,GAAe,IAAInQ,EAAO,EAAE;AACrB,WAAAmQ,GAAe,IAAInQ,EAAO,EAAE;AAGjC,QAAAqQ,IAAQ,CAACC,GAA0B/B,MAAgB;AACrD,QAAI4B,GAAe,IAAIG,EAAY,EAAE;AAC1B,aAAAH,GAAe,IAAIG,EAAY,EAAE;AAG5C,UAAM,EAAE,MAAAvQ,GAAM,MAAAE,GAAM,QAAQsQ,MAAqBD,EAAY,SACvDE,IACFD,KAAoB,OACdF,EAAME,GAAkBhC,CAAE,IAC1Ba,EAAM,IAAI,KAAK,SAAS;AAElC,QAAIqB,KAAK,MAAM;AACX,cAAQ1Q,GAAM;AAAA,QACV,KAAK;AACD,iBAAOqP,EAAM,OAAO,IAAInP,EAAK,CAAC,IAAI;AAAA,QACtC,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAOmP,EAAM,UAAU,GAAGnP,EAAK,CAAC,GAAG;AAAA,QACvC,KAAK;AAAA,QACL,KAAK,QAAQ;AACH,gBAAA,CAACyQ,GAAMC,CAAK,IAAI1Q;AACtB,iBAAOyC,EAAM;AAAA,YACT2N,EAAMK,GAAMnC,CAAE;AAAA,YACdyB,EAAAA,SAAE,OAAO,CAACA,EAAE,SAAA,UAAUQ,CAAY,CAAC;AAAA,YACnCR,EAAAA,SAAE;AAAA,YACFK,EAAMM,GAAOpC,CAAE;AAAA,UAAA,CAClB;AAAA,QACL;AAAA,QACA,KAAK;AACD,iBAAO7L,EAAM,CAAC8N,GAAcP,GAAQ,IAAI,CAAC,CAAC;AAAA,QAC9C,KAAK;AACD,iBAAOvN,EAAM,CAAC,KAAK8N,CAAY,CAAC;AAAA,QACpC,KAAK;AACD,iBAAO9N,EAAM,CAAC8N,GAAcP,GAAQ,GAAG,CAAC,CAAC;AAAA,QAC7C,KAAK;AACK,gBAAA,CAACrE,EAAI,IAAI3L;AACR,iBAAAyC,EAAM,CAAC8N,GAAcP,GAAQ,MAAM,GAAGI,EAAMzE,IAAM2C,CAAE,CAAC,CAAC;AAAA,QACjE,KAAK;AACK,gBAAA,CAACqC,EAAI,IAAI3Q;AACR,iBAAAyC,EAAM,CAAC8N,GAAcP,GAAQ,MAAM,GAAGI,EAAMO,IAAMrC,CAAE,CAAC,CAAC;AAAA,QAEjE,KAAK;AACM,iBAAAiC;AAAA,QACX,KAAK;AAAA,QACL,KAAK,QAAQ;AACH,gBAAAK,IAAQZ,GAAQ,IAAI;AAC1B,iBAAOvN,EAAM;AAAA,YACT;AAAA,YACAsN,EAAAA,SAAE,OAAO;AAAA,cACLA,EAAAA,SAAE;AAAA,cACFA,EAAAA,SAAE;AAAA,gBACE,CAACa,GAAOb,EAAA,SAAE,QAAQ;AAAA,gBAClB/P,EAAK,IAAI,CAAC6Q,MAAMT,EAAMS,GAAGvC,CAAE,CAAC;AAAA,cAChC;AAAA,YAAA,CACH;AAAA,YACDyB,EAAAA,SAAE;AAAA,YACF;AAAA,UAAA,CACH;AAAA,QACL;AAAA,QACA,KAAK;AAAA,QACL,KAAK,MAAM;AACD,gBAAAa,IAAQZ,GAAQ,IAAI;AAC1B,iBAAOvN,EAAM;AAAA,YACT;AAAA,cACIsN,EAAAA,SAAE;AAAA,gBACE,CAACA,EAAAA,SAAE,UAAUA,EAAA,SAAE,QAAQa,GAAO,MAAMA,CAAK,CAAC;AAAA,gBAC1C5Q,EAAK,IAAI,CAAC6Q,MAAMT,EAAMS,GAAGvC,CAAE,CAAC;AAAA,cAChC;AAAA,YACJ;AAAA,UAAA,CACH;AAAA,QACL;AAAA,QACA,KAAK;AACK,gBAAA,CAACwC,IAAKC,CAAG,IAAI/Q;AACnB,cAAIgR,KAASD,MAAQ,QAAW,GAAGD,QAAS,GAAGA,MAAOC;AACtD,iBAAAC,KAAS7B,EAAM,KAAK,KAAK,KAAK6B,KAAS,GAChCvO,EAAM,CAAC8N,GAAcS,EAAM,CAAC;AAAA,QACvC,KAAK;AACD,iBAAOvO,EAAM;AAAA,YACT8N;AAAA,YACAR,WAAE,OAAO,CAAC,WAAWK,EAAMpQ,EAAK,CAAC,GAAGsO,CAAE,CAAC,CAAC;AAAA,UAAA,CAC3C;AAAA,QACL,KAAK,QAAQ;AACH,gBAAA,CAAC2C,CAAI,IAAIjR,GACTkR,IAAIC,GAAcF,CAAI;AAE5B,cAAK3C;AAKM,mBAAAa,EAAM,KAAK,KAAKrP,CAAI;AALtB;AACL,kBAAM0Q,KAAIJ,EAAMc,GAAGA,EAAE,EAAE;AACR,mBAAAhB,GAAA,IAAIgB,EAAE,IAAIV,EAAC,GACnBA;AAAAA,UAAA;AAAA,QAIf;AAAA,QACA,KAAK;AACM,iBAAAD;AAAA,MACf;AAAA,IAAA;AAEJC,WAAAA,UAAMrB,EAAM,IAAI,KAAKrP,CAAI,IACrBwO,KACe4B,GAAA,IAAIG,EAAY,IAAIG,CAAC,GAEjCA;AAAAA,EAAA,GAGLnM,IAAM+L,EAAMrQ,CAAM,GAClB,IAAI6O,GAAcvK,CAAG;AACZ,SAAA6L,GAAA,IAAInQ,EAAO,IAAI,CAAC,GAExB;AACX;AAEO,SAASqR,GACZ1E,GACA5M,IAAe,IACfyQ,IAAuB,IACzB;AACE,QAAMc,IAAgB3E,EAAM,UAA0ByC,EAAM,QAAtBA,EAAM,SACtCmC,IAAc5E,EAAM,UAAwByC,EAAM,MAApBA,EAAM,OAEpCoC,IAAW7E,EAAM,UAAUA,EAAM,IAAI,QAErC8E,IAAe9E,EAAM,UAAoC,MAAzB6E,IAAW,OAAO,KAElDE,IAAc,OADD/E,EAAM,UAAuC,QAA5B6E,IAAW,SAAS,QAClB,MAAMC,IAAc,KAEpDE,IAASjP,EAAM;AAAA,IACjB4O,EAAa,KAAKI,CAAW;AAAA,IAC7BH,EAAW,IAAKxR,KAAS4M,EAAM,QAAQ;AAAA,IACvCqD,EAAAA,SAAE;AAAA,IACF,MAAOZ,EAAM,OAAOoB,CAAY;AAAA,EAAA,CACnC,GAEKoB,KAAQ,MACNjF,EAAM,UAAUA,EAAM,IAAI,SACnByC,EAAM,KAAK,YAAYH,GAAUtC,GAAO,IAAIA,EAAM,OAAO,CAAC,IAE9DsC,GAAUtC,GAAO,KAAKA,EAAM,OAAO,MAGxCkF,KAAanP,EAAM,CAACiP,GAAQ3B,EAAAA,SAAE,UAAUA,EAAE,SAAA,OAAO,CAAC4B,CAAI,CAAC,CAAC,CAAC;AAE/D,SAAO/C,GAAcgD,EAAU;AACnC;AAEgB,SAAAC,GACZ9R,GACAD,IAAe,IACfgS,IAA0B,IAC1BC,IAAgC,QAAQ,KAC1C;AACQ,QAAAC,IAAQ,CAACtF,MAA0B;AAC/B,UAAAuF,IAAWlS,EAAO,OAAO2M,CAAK,GAE9B6D,IAAeuB,IAAiB3B,GAAYpQ,CAAM,IAAIA,EAAO,QAAQ,MACrEyQ,IAAIY,GAAWa,GAAUnS,GAAMyQ,CAAY;AAEjD,WAAAwB,EAAOvB,CAAC,GAEDyB;AAAA,EAAA;AAEX,SAAO,IAAIC,EAAOF,GAAOnS,EAAoB,SAASE,GAAQgS,CAAM,CAAC;AACzE;ACvOA,IAAII,KAAY;AAEhB,MAAMC,yBAAW,OACXC,yBAA4B;AAElC,IAAIC;AAEG,SAASC,EAAgB7F,GAAyB;AACrD,UAAI,CAAC4F,MAAcA,MAAa5F,EAAM,SAAS4F,GAAU,YACzCA,KAAA5F,IAET4F;AACX;AAEO,SAASnB,GAAiBnQ,GAAqB;AAClD,SAAIA,EAAG,SACIA,EAAG,SAENA,EAAG,SAASA;AACxB;AAEO,MAAMkR,EAAmB;AAAA,EAI5B,YAAmBnS,GAAkCyS,IAAyB,IAAI;AAHlF,IAAAC,GAAA,YAAaN;AACb,IAAAM,GAAA;AAEmB,SAAA,SAAA1S,GAAkC,KAAA,UAAAyS;AAAA,EAA8B;AAAA,EAEnF,QAAQ;AACQ,IAAAF,KAAA,QACZF,GAAK,MAAM,GACXC,GAAsB,MAAM;AAAA,EAChC;AAAA,EAEA,MAAMK,GAAa;AACf,SAAK,MAAM;AAEX,UAAMT,IAAW,KAAK,OAAO,IAAI/S,GAAYwT,CAAG,CAAC;AAE5C,gBAAA,QAAQH,EAAgBN,CAAQ,GAChC,KAAA,MAAM,UAAUA,EAAS,SAEvBA,EAAS;AAAA,EACpB;AAAA,EAEA,UAAUvF,GAAuB;AACtB,WAAA,GAAG,KAAK,KAAKA,EAAM;AAAA,EAC9B;AAAA,EAEA,qBAAqBA,GAAuB;AAExC,YADY2F,GAAsB,IAAI,KAAK,UAAU3F,CAAK,CAAC,KAAK,KACnDA,EAAM,IAAI,SAASA,EAAM;AAAA,EAC1C;AAAA,EAEA,UAAU;AACA,UAAAiG,IAAU,CAACjG,MAA0B;AACjC,YAAAkG,IAAS,KAAK,UAAUlG,CAAK,GAC7BmG,IAAMR,GAAsB,IAAIO,CAAM,KAAK;AAEjD,UAAIE,IAASV,GAAK,IAAI,KAAK,EAAE;AAE7B,UAAIU,KAAUA,EAAO,UAAUpG,EAAM;AAC1B,eAAAoG;AACA,UAAA,KAAK,qBAAqBpG,CAAK;AAC/B,eAAAA,EAAM,IAAI,MAAS;AAGR,MAAA2F,GAAA,IAAIO,GAAQC,IAAM,CAAC;AACnC,YAAAZ,IAAW,KAAK,OAAOvF,CAAK;AAEzB,aAAAoG,IAAAV,GAAK,IAAI,KAAK,EAAE,GAErBU,KAAUA,EAAO,SAASb,EAAS,SACnCA,EAAS,SAASa,EAAO,SACjBA,KACHV,GAAA,IAAI,KAAK,IAAIH,CAAQ,GAGvBA;AAAA,IAAA;AAEX,WAAO,IAAIC;AAAA,MACPS;AAAA,MACA9S,EAAoB,WAAW,IAAI;AAAA,IAAA;AAAA,EAE3C;AAAA,EAEA,aAAgB;AACN,UAAAkT,IAAY,CAACrG,MAA0B;AACzC,UAAIoG,IAASV,GAAK,IAAI,KAAK,EAAE;AAC7B,UAAIU;AACO,eAAAA;AACA,UAAA,KAAK,qBAAqBpG,CAAK;AAC/B,eAAAA,EAAM,IAAI,MAAS;AAGxB,YAAAuF,IAAW,KAAK,OAAOvF,CAAK;AAEzB,aAAAoG,IAAAV,GAAK,IAAI,KAAK,EAAE,GACpBU,KACIV,GAAA,IAAI,KAAK,IAAIH,CAAQ,GAEvBA;AAAA,IAAA;AAGX,WAAO,IAAIC;AAAA,MACPa;AAAA,MACAlT,EAAoB,aAAa,IAAI;AAAA,IAAA;AAAA,EAE7C;AAAA,EAEA,KAAQ8L,GAAqB;AACrB,QAAAqH,GAAgB,MAAMrH,CAAI;AAC1B,aAAOsH,GAAoB,CAAC,MAAMtH,CAAI,GAAG,IAAI,CAACuH,MAAM,CAACA,KAAA,gBAAAA,EAAI,IAAIA,KAAA,gBAAAA,EAAI,EAAE,CAAC;AAGlE,UAAAC,IAAO,CAACzG,MAA0B;AAC9B,YAAA0G,IAAa,KAAK,OAAO1G,CAAK;AAEhC,UAAA,CAAC0G,EAAW,SAAS;AACf,cAAAC,IAAa1H,EAAK,OAAOyH,CAAU;AACrC,YAAA,CAACC,EAAW;AACZ,iBAAOA,EAAW,GAAG,CAACD,EAAW,OAAOC,EAAW,KAAK,CAAC;AAAA,MAEjE;AACA,aAAAd,EAAgB7F,CAAK,GACdA,EAAM,IAAI,MAAS;AAAA,IAAA;AAG9B,WAAO,IAAIwF;AAAA,MACPiB;AAAA,MACAtT,EAAoB,QAAQ,MAAM,MAAM8L,CAAI;AAAA,IAAA;AAAA,EAEpD;AAAA,EAEA,GAAM2H,GAAsB;AACpB,QAAAN,GAAgB,MAAMM,CAAK;AAC3B,aAAOL,GAAoB,CAAC,MAAMK,CAAK,GAAG,GAAG;AAG3C,UAAAC,IAAK,CAAC7G,MAA0B;AAC5B,YAAAuF,IAAW,KAAK,OAAOvF,CAAK;AAE9B,aAACuF,EAAS,UAGPqB,EAAM,OAAO5G,CAAK,IAFduF;AAAA,IAEc;AAG7B,WAAO,IAAIC;AAAA,MACPqB;AAAA,MACA1T,EAAoB,MAAM,MAAM,MAAMyT,CAAK;AAAA,IAAA;AAAA,EAEnD;AAAA,EAEA,MAAStS,GAAiCwS,IAAsB,IAAO;AAC7D,UAAAC,IAAQ,CAAC/G,MAA0B;AAC/B,YAAAuF,IAAW,KAAK,OAAOvF,CAAK;AAElC,aAAIuF,EAAS,UACFA,IACAA,EAAS,SAASuB,IAClBxS,EAAGiR,EAAS,KAAK,EAAE,OAAOA,CAAQ,IAEtCvF;AAAA,IAAA;AAGX,WAAO,IAAIwF,EAAOuB,GAAO5T,EAAoB,SAAS,MAAMmB,CAAE,CAAC;AAAA,EACnE;AAAA,EAEA,IAAOA,GAAqB0S,IAAoB,IAAO;AAC7C,UAAAC,IAAM,CAACjH,MAA8B;AACjC,YAAAuF,IAAW,KAAK,OAAOvF,CAAuB;AAEhD,aAAA,CAACuF,EAAS,WAAWyB,IACdzB,EAAS,GAAGjR,EAAGiR,EAAS,KAAK,CAAC,IAElCA;AAAA,IAAA;AAGX,WAAO,IAAIC,EAAOyB,GAA0B9T,EAAoB,OAAO,IAAI,CAAC;AAAA,EAChF;AAAA,EAEA,SAAsBmB,GAA+C;AAC3D,UAAA4S,IAAW,CAAClH,MAA0B;AAClC,YAAAuF,IAAW,KAAK,OAAOvF,CAAK;AAClC,aAAO1L,EAAGiR,CAAQ;AAAA,IAAA;AAGtB,WAAO,IAAIC;AAAA,MACP0B;AAAA,MACA/T,EAAoB,YAAY,IAAI;AAAA,IAAA;AAAA,EAE5C;AAAA,EAEA,KAAQE,GAAuB;AACrB,UAAA4Q,IAAO,CAACjE,MAA0B;AAC9B,YAAA0G,IAAa,KAAK,OAAO1G,CAAK;AAChC,UAAA2G;AAEA,aAAA,CAACD,EAAW,YACCC,IAAAtT,EAAO,OAAOqT,CAAU,GACjC,CAACC,EAAW,WACLA,EAAW,GAAGD,EAAW,KAAK,KAG7Cb,EAAgB7F,CAAK,GACdA,EAAM,IAAI,MAAS;AAAA,IAAA;AAE9B,WAAO,IAAIwF;AAAA,MACPvB;AAAA,MACA9Q,EAAoB,QAAQ,MAAME,CAAM;AAAA,IAAA;AAAA,EAEhD;AAAA,EAEA,KAAQA,GAAmB;AACjB,UAAA4L,IAAO,KAAK,KAAK5L,CAAM,EAAE,IAAI,CAAC,CAAG,EAAAgQ,CAAC,MAC7BA,CACV;AACD,WAAApE,EAAK,UAAU9L,EAAoB,QAAQ,MAAME,CAAM,GAChD4L;AAAA,EACX;AAAA,EAEA,MAAM;AACI,UAAAkI,IAAM,CAACnH,MAA0B;AAC7B,YAAAuF,IAAW,KAAK,OAAOvF,CAAK;AAClC,aAAIuF,EAAS,WACTM,EAAgB7F,CAAK,GACdA,EAAM,GAAG,MAAS,KAEtBuF;AAAA,IAAA;AAEX,WAAO,IAAIC,EAAO2B,GAA0BhU,EAAoB,OAAO,IAAI,CAAC;AAAA,EAChF;AAAA,EAEA,IAAOE,GAAoB;AACjB,UAAA+T,IAAS,CAACpH,MACK,KAAK,OAAOA,CAAK,EAErB,WACT6F,EAAgB7F,CAAK,GACdA,EAAM,GAAGA,EAAM,KAAK,KAEpBA,EAAM,IAAI,MAAS,GAI5BqH,IAAM,CAACrH,MAA0B;AAC7B,YAAAuF,IAAW,KAAK,OAAOvF,CAAK;AAElC,aAAIuF,EAAS,WACTM,EAAgB7F,CAAK,GACduF,KAEWlS,EAAO,OAAO2M,CAAK,EACvB,UACHuF,KAEPM,EAAgB7F,CAAK,GACdA,EAAM,IAAI,MAAS;AAAA,IAElC;AAGJ,WAAO,IAAIwF;AAAA,MACPnS,IAASgU,IAAMD;AAAA,MACfjU,EAAoB,OAAO,MAAME,CAAM;AAAA,IAAA;AAAA,EAE/C;AAAA,EAEA,KAAWiU,GAAkBC,GAAgBC,IAAmB,IAAM;AAClE,QAAI,CAACA;AACM,aAAA7S,GAAI2S,GAAO,MAAMC,CAAG;AAG/B,QAAIjB,GAAgBgB,GAAO,MAAMC,CAAG;AACzB,aAAAE,GAAkBH,GAAO,MAAMC,CAAG;AAE7C,UAAMG,IAAOJ,EAAM,KAAK,IAAI,EAAE,KAAKC,CAAG;AACtC,WAAAG,EAAK,UAAUvU,EAAoB,QAAQ,MAAMmU,GAAOC,CAAG,GACpDG;AAAA,EACX;AAAA,EAEA,KAAKrU,IAAoB8M,IAAyBqH,IAAmB,IAAM;;AACvE,QAAI,CAACA;AACM,aAAA7S,GAAItB,GAAQ,MAAMA,CAAM;AAG/B,UAAAsU,IAAAtU,EAAO,YAAP,gBAAAsU,EAAgB,UAAS,cAAc;AACnC,UAAArB,GAAgB,MAAMjT,CAAM;AACrB,eAAAkT;AAAA,UACH,CAAClT,GAAQ,MAAMA,CAAM;AAAA,UACrB;AAAA,UACA,CAACmT,MAAMA,KAAA,gBAAAA,EAAI;AAAA,QAAC;AAId,YAAAoB,IAAiB,CAAC5H,MAA0B;AACxC,cAAAuF,IAAWsC,GAAoB7H,CAAK,GACpC8H,IAAW,KAAK,OAAOvC,CAAQ;AAErC,eAAIuC,EAAS,WACTjC,EAAgB7F,CAAK,GACdA,EAAM,IAAI,MAAS,KAEnB6H,GAAoBC,CAAQ;AAAA,MACvC;AAGJ,aAAO,IAAItC;AAAA,QACPoC;AAAA,QACAzU,EAAoB,kBAAkB,IAAI;AAAA,MAAA;AAAA,IAElD;AAEO,WAAA,KAAK,KAAKE,GAAQA,CAAM;AAAA,EACnC;AAAA,EAEA,KAAK+Q,IAAc,GAAGC,IAAc,OAAU;AACpC,UAAA0D,IAAO,CAAC/H,MAA0B;AACpC,YAAMgI,IAAe,CAAA;AACrB,UAAIzC,IAAWvF;AAEf,eAASvI,IAAI,GAAGA,IAAI4M,GAAK5M,KAAK,GAAG;AACvB,cAAAqQ,IAAW,KAAK,OAAOvC,CAAQ;AAErC,YAAIuC,EAAS;AACT;AAEI,QAAAE,EAAA,KAAKF,EAAS,KAAK,GAChBvC,IAAAuC;AAAA,MACf;AAEI,aAAAE,EAAQ,UAAU5D,IACXmB,EAAS,GAAGyC,CAAO,KAE9BnC,EAAgB7F,CAAK,GACdA,EAAM,IAAI,CAAA,CAAE;AAAA,IAAA;AAGvB,WAAO,IAAIwF;AAAA,MACPuC;AAAA,MACA5U,EAAoB,QAAQ,MAAMiR,GAAKC,CAAG;AAAA,IAAA;AAAA,EAElD;AAAA,EAEA,MAAS9M,GAAoB6M,IAAc,GAAGC,IAAc,OAAU;AAC5D,UAAA4D,IAAQ,CAACjI,MAA0B;AACrC,YAAMgI,IAAe,CAAA;AAErB,UAAIzC,IAAWvF;AAEf,eAASvI,IAAI,GAAGA,IAAI4M,GAAK5M,KAAK,GAAG;AACvB,cAAAqQ,IAAW,KAAK,OAAOvC,CAAQ;AACrC,YAAIuC,EAAS;AACT;AAEO,QAAAvC,IAAAuC,GACHE,EAAA,KAAKzC,EAAS,KAAK;AAErB,cAAA2C,IAAW3Q,EAAI,OAAOgO,CAAQ;AACpC,YAAI2C,EAAS;AACT;AAEO,QAAA3C,IAAA2C;AAAA,MACf;AAEI,aAAAF,EAAQ,SAAS5D,IACVmB,EAAS,GAAGyC,CAAO,KAE9BnC,EAAgB7F,CAAK,GACdA,EAAM,IAAI,CAAA,CAAE;AAAA,IAAA;AAGvB,WAAO,IAAIwF;AAAA,MACPyC;AAAA,MACA9U,EAAoB,SAAS,MAAMoE,CAAG;AAAA,IAAA;AAAA,EAE9C;AAAA,EAEA,MAAM;AACF,UAAMiN,IAAI,KAAK,KAAK2D,GAAK,CAAA;AACvB,WAAA3D,EAAA,UAAUrR,EAAoB,OAAO,IAAI,GACpCqR;AAAA,EACX;AAAA,EAEA,MACIpR,IAAe,IACfgS,IAA0B,IAC1BC,IAAgC,QAAQ,KAC1C;AACE,WAAOF,GAAY,MAAM/R,GAAMgS,GAAgBC,CAAM;AAAA,EACzD;AAAA,EAEA,WAAW;AACP,WAAO5B,GAAY,IAAI;AAAA,EAC3B;AAAA,EAEA,OAAO,KAAQnP,GAAqB;AAC1BiQ,UAAAA,IAAO,CAACvE,MACHyE,GAAcnQ,CAAE,EAAE,OAAO0L,CAAK;AAEzC,WAAO,IAAIwF,EAAUjB,GAAMpR,EAAoB,QAAQ,QAAWmB,CAAE,CAAC;AAAA,EACzE;AACJ;AAEA,SAASgS,MAAmB8B,GAAwB;AAChD,SAAOA,EAAQ;AAAA,IACX,CAAC5D,MAAA;;AACI,gBAAAmD,IAAAnD,EAAE,YAAF,gBAAAmD,EAAW,UAAS,cACjBU,IAAA7D,EAAE,YAAF,gBAAA6D,EAAW,UAAS,aACpBC,IAAA9D,EAAE,YAAF,gBAAA8D,EAAW,UAAS,mBACxBC,IAAA/D,EAAE,YAAF,gBAAA+D,EAAW;AAAA;AAAA,EAAA;AAEvB;AAEA,SAASC,GAAkBhE,GAAgB;;AACnC,QAAAmD,IAAAnD,EAAE,YAAF,gBAAAmD,EAAW,UAAS;AACpB,YAAOU,IAAA7D,EAAE,YAAF,gBAAA6D,EAAW,KAAK,GAAG,QAAQ,0BAA0B;AAChE,QAAWC,IAAA9D,EAAE,YAAF,gBAAA8D,EAAW,UAAS,aAAWC,IAAA/D,EAAE,YAAF,gBAAA+D,EAAW,UAAS;AAC1D,YAAOE,IAAAjE,EAAE,YAAF,gBAAAiE,EAAW,KAAK,GAAG;AAElC;AAEA,SAASlC,GACL6B,GACAlE,IAAgB,IAChBwE,GACc;AACR,QAAA,IAAIN,EAAQ,IAAI,CAACtE,MAAM,IAAI0E,GAAkB1E,CAAC,IAAI,EAAE,KAAKI,CAAK,GAC9DyE,IAAI,IAAI,OAAO,CAAC,GAChBC,IAAKpQ,GAAMmQ,GAAGD,CAAa;AAEjC,SAAIxE,MAAU,QACV0E,EAAG,UAAUzV,EAAoB,eAAe,MAAMwV,CAAC,IAEpDC;AACX;AAEA,SAASnB,GACL1D,GACAS,GACAR,GACc;AACR,QAAA4E,IAAKrC,GAAoB,CAACxC,GAAMS,GAAGR,CAAK,GAAG,IAAI,CAACwC,MAC3CA,KAAA,gBAAAA,EAAI,EACd;AACD,SAAAoC,EAAG,QAAQ,OAAO,aACXA;AACX;AAEO,SAAST,KAAS;AACfA,QAAAA,IAAM,CAACnI,MACLA,EAAM,UAAUA,EAAM,IAAI,SACnBA,EAAM,GAAG,MAAS,IAElBA,EAAM;AAGrB,SAAO,IAAIwF,EAAO2C,GAAKhV,EAAoB,OAAO,MAAS,CAAC;AAChE;AAEgB,SAAAoR,GACZ7P,GACAmU,GACAC,GACF;AACE,QAAMC,IAASD,EAAW,MAAM,KAAKpU,CAAM;AAE3C,EAAAoU,EAAW,QAAQ,WAAY;AACrBvE,UAAAA,IAAO,CAACvE,MACHyE,GAAcsE,CAAM,EAAE,OAAO/I,CAAK;AAE7C,WAAO,IAAIwF,EAAUjB,GAAMpR,EAAoB,QAAQ,QAAW4V,CAAM,CAAC;AAAA,EAAA;AAEjF;AAEO,SAASC,MAAwBZ,GAAY;AAC5C,MAAA9B,GAAgB,GAAG8B,CAAO;AACnB,WAAA7B,GAAoB6B,GAAS,GAAG;AAGrCY,QAAAA,IAAM,CAAChJ,MAA0B;AACnC,eAAW3M,KAAU+U,GAAS;AACpB,YAAA7C,IAAWlS,EAAO,OAAO2M,CAAK;AAChC,UAAA,CAACuF,EAAS;AACH,eAAAA;AAAA,IAEf;AACA,WAAAM,EAAgB7F,CAAK,GACdA,EAAM,IAAI,MAAS;AAAA,EAAA;AAG9B,SAAO,IAAIwF;AAAA,IACP4C,EAAQ,WAAW,IAAIA,EAAQ,CAAC,EAAE,SAASY;AAAAA,IAC3C7V,EAAoB,OAAO,QAAW,GAAGiV,CAAO;AAAA,EAAA;AAExD;AAEO,SAASzT,MAAwByT,GAAY;AAC1CzT,QAAAA,IAAM,CAACqL,MAAsE;AAC/E,UAAMgI,IAAU,CAAA;AAEhB,eAAW3U,KAAU+U,GAAS;AACpB,YAAA7C,IAAWlS,EAAO,OAAO2M,CAAK;AAEpC,UAAIuF,EAAS;AACF,eAAAA;AAIP,MAAAA,EAAS,UAAU,UACXyC,EAAA,KAAKzC,EAAS,KAAK,GAEvBvF,IAAAuF;AAAA,IACZ;AACA,WAAAM,EAAgB7F,CAAK,GACdA,EAAM,GAAGgI,CAAO;AAAA,EAAA;AAG3B,SAAO,IAAIxC;AAAA,IACP4C,EAAQ,WAAW,IAAIA,EAAQ,CAAC,EAAE,SAASzT;AAAAA,IAC3CxB,EAAoB,OAAO,QAAW,GAAGiV,CAAO;AAAA,EAAA;AAExD;AAEO,SAASlP,GAAO+P,GAAa;AAC1B/P,QAAAA,IAAS,CAAC8G,MAA+B;AAC3C,QAAIA,EAAM,UAAUA,EAAM,IAAI;AACnB,aAAAA,EAAM,IAAI,MAAS;AAExB,UAAA,IAAIA,EAAM,IAAI,MAAMA,EAAM,QAAQA,EAAM,SAASiJ,EAAI,MAAM;AACjE,WAAI,MAAMA,IACCjJ,EAAM,GAAG,GAAG,EAAE,MAAM,KAE/B6F,EAAgB7F,CAAK,GACdA,EAAM,IAAI,MAAS;AAAA,EAAA;AAG9B,SAAO,IAAIwF;AAAA,IACPtM;AAAAA,IACA/F,EAAoB,UAAU,QAAW8V,CAAG;AAAA,EAAA;AAEpD;AAEO,SAASzQ,GACZmQ,GACAD,IAAkD,CAAClC,MAAMA,KAAA,gBAAAA,EAAI,IAC/D;AACE,QAAM0C,IAAQP,EAAE,MAAM,QAAQ,MAAM,EAAE,GAChCQ,IAAS,IAAI,OAAOR,GAAGO,IAAQ,GAAG,GAElC1Q,IAAQ,CAACwH,MAA+B;AAC1C,QAAIA,EAAM,UAAUA,EAAM,IAAI;AACnB,aAAAA,EAAM,IAAI,MAAS;AAG9B,IAAAmJ,EAAO,YAAYnJ,EAAM;AACzB,UAAMoJ,IAAQV,EAAc1I,EAAM,IAAI,MAAMmJ,CAAM,CAAC;AAEnD,WAAIC,IACOpJ,EAAM,GAAGoJ,GAAOD,EAAO,YAAYnJ,EAAM,MAAM,IAC/CoJ,MAAU,KACVpJ,EAAM,GAAG,MAAS,KAE7B6F,EAAgB7F,CAAK,GACdA,EAAM,IAAI,MAAS;AAAA,EAAA;AAG9B,SAAO,IAAIwF;AAAA,IACPhN;AAAAA,IACArF,EAAoB,SAAS,QAAWwV,CAAC;AAAA,EAAA;AAEjD;AAEA,MAAMU,KAAa,QACbxB,KAAsB,CAAI7H,MAA0B;;AACtD,MAAIA,EAAM,UAAUA,EAAM,IAAI;AACnB,WAAAA;AAGX,EAAAqJ,GAAW,YAAYrJ,EAAM;AAC7B,QAAMoJ,MAAQzB,IAAA3H,EAAM,IAAI,MAAMqJ,EAAU,MAA1B,gBAAA1B,EAA8B,OAAM;AAClD,SAAO3H,EAAM,GAAGA,EAAM,OAAOoJ,EAAM,MAAM;AAC7C,GAEajJ,KAAa3H,GAAM,KAAK;AACrC2H,GAAW,QAAQ,OAAO;"}