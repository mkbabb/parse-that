{"version":3,"file":"ebnf.cjs","sources":["../src/ebnf/grammar.ts","../src/ebnf/optimize.ts","../src/ebnf/generate.ts"],"sourcesContent":["import { Parser, string, lazy, all, any, regex } from \"../parse\";\n\nexport type Expression =\n    | Literal\n    | Nonterminal\n    | Group\n    | Regex\n    | Optional\n    | Minus\n    | Many\n    | Many1\n    | Skip\n    | Next\n    | Concatenation\n    | Alteration\n    | Epsilon\n    | OptionalWhitespace;\n\ninterface BaseExpression<T, V = string> {\n    type: T;\n    value: V;\n    comment?: {\n        left: string[];\n        right: string[];\n    };\n}\n\nexport type Nonterminal = BaseExpression<\"nonterminal\">;\n\nexport type Literal = BaseExpression<\"literal\">;\nexport type Regex = BaseExpression<\"regex\", RegExp>;\nexport type Epsilon = BaseExpression<\"epsilon\">;\n\nexport type Group = BaseExpression<\"group\", Expression>;\nexport type ManyGroup = BaseExpression<\"many\", Expression>;\nexport type OptionalGroup = BaseExpression<\"optional\", Expression>;\n\nexport type Optional = BaseExpression<\"optional\", Expression>;\nexport type OptionalWhitespace = BaseExpression<\"optionalWhitespace\", undefined>;\n\nexport type Minus = BaseExpression<\"minus\", [Expression, Expression]>;\n\nexport type Many = BaseExpression<\"many\", Expression>;\nexport type Many1 = BaseExpression<\"many1\", Expression>;\nexport type Skip = BaseExpression<\"skip\", [Expression, Expression]>;\nexport type Next = BaseExpression<\"next\", [Expression, Expression]>;\n\nexport type Concatenation = BaseExpression<\"concatenation\", Expression[]>;\nexport type Alteration = BaseExpression<\"alternation\", Expression[]>;\n\nexport type ProductionRule = {\n    expression: Expression;\n    name: string;\n    comment: {\n        above: string[];\n        below: string[];\n    };\n};\n\nexport type AST = Map<string, ProductionRule>;\nexport type Nonterminals = { [key: string]: Parser<any> };\n\nconst operatorToType = {\n    \"|\": \"alternation\",\n    \",\": \"concatenation\",\n    \"-\": \"minus\",\n    \"<<\": \"skip\",\n    \">>\": \"next\",\n    \"*\": \"many\",\n    \"+\": \"many1\",\n    \"?\": \"optional\",\n    \"?w\": \"optionalWhitespace\",\n};\n\nconst reduceBinaryExpression = ([left, rightExpression]) => {\n    if (rightExpression.length === 0) {\n        return left;\n    }\n    return rightExpression.reduce((acc, [op, right]) => {\n        return {\n            type: operatorToType[op],\n            value: [acc, right],\n        };\n    }, left);\n};\n\nconst mapFactor = ([term, op]) => {\n    if (op === undefined) {\n        return term;\n    }\n    const type = operatorToType[op];\n    return {\n        type,\n        value: term,\n    } as Expression;\n};\n\ntype Options = {\n    debug: boolean;\n    comments: boolean;\n};\n\nconst defaultOptions = {\n    debug: false,\n    comments: true,\n} as Options;\n\nexport class EBNFGrammar {\n    options: Options;\n\n    constructor(options?: Partial<Options>) {\n        this.options = {\n            ...defaultOptions,\n            ...(options ?? {}),\n        };\n    }\n\n    identifier() {\n        return regex(/[_a-zA-Z][_a-zA-Z0-9]*/).trim();\n    }\n\n    literal() {\n        return this.trimBigComment(\n            any(\n                regex(/[^\"]+/).wrap(string('\"'), string('\"')),\n                regex(/[^']+/).wrap(string(\"'\"), string(\"'\"))\n            ).map((value) => {\n                return {\n                    type: \"literal\",\n                    value,\n                } as Literal;\n            })\n        );\n    }\n\n    epsilon() {\n        return any(string(\"epsilon\"), string(\"Îµ\"))\n            .trim()\n            .map((value) => {\n                return {\n                    type: \"epsilon\",\n                    value: undefined,\n                } as Epsilon;\n            });\n    }\n\n    nonterminal() {\n        return this.identifier().map((value) => {\n            return {\n                type: \"nonterminal\",\n                value,\n            } as Nonterminal;\n        });\n    }\n\n    @lazy\n    bigComment() {\n        return regex(/\\/\\*[^\\*]*\\*\\//).trim();\n    }\n\n    @lazy\n    comment() {\n        return regex(/\\/\\/.*/)\n            .or(this.bigComment())\n            .trim();\n    }\n\n    trimBigComment(e: Parser<any>) {\n        return e\n            .trim(this.bigComment().many(), false)\n            .map(([left, expression, right]) => {\n                expression.comment = {\n                    left,\n                    right,\n                };\n                return expression as unknown as Expression;\n            }) as Parser<Expression>;\n    }\n\n    @lazy\n    group() {\n        return this.rhs()\n            .trim()\n            .wrap(string(\"(\"), string(\")\"))\n            .map((value) => {\n                return {\n                    type: \"group\",\n                    value,\n                } as Group;\n            });\n    }\n\n    @lazy\n    regex() {\n        return regex(/[^\\/]*/)\n            .wrap(string(\"/\"), string(\"/\"))\n            .then(regex(/[gimuy]*/).opt())\n            .map(([r, flags]) => {\n                return {\n                    type: \"regex\",\n                    value: new RegExp(r, flags),\n                } as Regex;\n            });\n    }\n\n    @lazy\n    optionalGroup() {\n        return this.rhs()\n            .trim()\n            .wrap(string(\"[\"), string(\"]\"))\n            .map((value) => {\n                return {\n                    type: \"optional\",\n                    value,\n                } as Optional;\n            });\n    }\n\n    @lazy\n    manyGroup() {\n        return this.rhs()\n            .trim()\n            .wrap(string(\"{\"), string(\"}\"))\n            .map((value) => {\n                return {\n                    type: \"many\",\n                    value,\n                } as Many;\n            });\n    }\n\n    @lazy\n    lhs() {\n        return this.identifier();\n    }\n\n    @lazy\n    term() {\n        return any(\n            this.epsilon(),\n            this.group(),\n            this.optionalGroup(),\n            this.manyGroup(),\n            this.nonterminal(),\n            this.literal(),\n            this.regex()\n        );\n    }\n\n    @lazy\n    factor() {\n        return this.trimBigComment(\n            all(\n                this.term(),\n                any(\n                    string(\"?w\").trim(),\n                    string(\"?\").trim(),\n                    string(\"*\").trim(),\n                    string(\"+\").trim()\n                ).opt()\n            ).map(mapFactor)\n        ) as Parser<Expression>;\n    }\n\n    @lazy\n    binaryFactor() {\n        return all(\n            this.factor(),\n            all(\n                any(string(\"<<\").trim(), string(\">>\").trim(), string(\"-\").trim()),\n                this.factor()\n            ).many()\n        ).map(reduceBinaryExpression);\n    }\n\n    @lazy\n    concatenation() {\n        return this.binaryFactor()\n            .sepBy(string(\",\").trim())\n            .map((value) => {\n                if (value.length === 1) {\n                    return value[0];\n                }\n\n                return {\n                    type: \"concatenation\",\n                    value,\n                } as Concatenation;\n            });\n    }\n\n    @lazy\n    alternation() {\n        return this.concatenation()\n            .sepBy(string(\"|\").trim())\n            .map((value) => {\n                if (value.length === 1) {\n                    return value[0];\n                }\n\n                return {\n                    type: \"alternation\",\n                    value,\n                } as Alteration;\n            });\n    }\n\n    @lazy\n    rhs() {\n        return this.alternation();\n    }\n\n    @lazy\n    productionRule() {\n        return all(\n            this.lhs(),\n            string(\"=\").trim(),\n            this.rhs(),\n            any(string(\";\"), string(\".\")).trim()\n        ).map(([name, , expression]) => {\n            return { name, expression } as ProductionRule;\n        });\n    }\n\n    @lazy\n    grammar() {\n        return this.productionRule()\n            .trim(this.comment().many(), false)\n            .map(([above, rule, below]: any) => {\n                rule.comment = {\n                    above,\n                    below,\n                };\n                return rule;\n            })\n            .many(1);\n    }\n}\n","import {\n    Alteration,\n    AST,\n    Concatenation,\n    Epsilon,\n    Expression,\n    Nonterminal,\n    ProductionRule,\n} from \"./grammar\";\n\nexport function topologicalSort(ast: AST) {\n    const visited = new Set<string>();\n    const order: ProductionRule[] = [];\n\n    function visit(node: string, stack: Set<string>) {\n        if (stack.has(node) || visited.has(node)) {\n            return;\n        }\n\n        stack.add(node);\n        const productionRule = ast.get(node)!;\n\n        if (!productionRule) {\n            return;\n        }\n\n        const expr = productionRule.expression;\n\n        if (expr.type === \"nonterminal\") {\n            visit(expr.value, stack);\n        } else if (expr.value instanceof Array) {\n            for (const child of expr.value) {\n                if (child.type === \"nonterminal\") {\n                    visit(child.value, stack);\n                }\n            }\n        }\n\n        visited.add(node);\n        stack.delete(node);\n\n        order.unshift(ast.get(node) as ProductionRule);\n    }\n\n    for (const [name] of ast) {\n        visit(name, new Set<string>());\n    }\n\n    const newAST = new Map() as AST;\n    for (const rule of order) {\n        newAST.set(rule.name, rule);\n    }\n\n    return newAST;\n}\n\nexport const findCommonPrefix = (\n    e1: Expression,\n    e2: Expression\n): [Expression | null, Expression, Expression] => {\n    if (!e1?.type || !e2?.type || e1.type !== e2.type) {\n        return undefined;\n    }\n\n    switch (e1.type) {\n        case \"literal\":\n        case \"nonterminal\": {\n            if (e1.value !== e2.value) {\n                return undefined;\n            } else {\n                return [e1, { type: \"epsilon\" }, { type: \"epsilon\" }] as [\n                    Expression,\n                    Expression,\n                    Expression\n                ];\n            }\n        }\n        case \"group\":\n        case \"optional\":\n        case \"optionalWhitespace\":\n        case \"many\":\n        case \"many1\": {\n            const common = findCommonPrefix(e1.value, e2.value as Expression);\n            if (!common) {\n                return undefined;\n            } else {\n                return [\n                    {\n                        type: e1.type,\n                        value: common[0],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[1],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[2],\n                    },\n                ] as [Expression, Expression, Expression];\n            }\n        }\n\n        case \"concatenation\": {\n            const commons = e1.value.map((_, i) =>\n                findCommonPrefix(e1.value[i], e2.value[i])\n            );\n            if (commons.some((x) => x === undefined)) {\n                return undefined;\n            }\n\n            const prefixes = commons.map((x) => x[0]);\n            const e1s = commons.map((x) => x[1]);\n            const e2s = commons.map((x) => x[2]);\n\n            const startIx = prefixes.lastIndexOf(null);\n            if (startIx === prefixes.length - 1) {\n                return undefined;\n            }\n            const prefix = prefixes.slice(startIx + 1);\n            return [\n                {\n                    type: \"concatenation\",\n                    value: prefix,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e1s,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e2s,\n                },\n            ];\n        }\n\n        case \"alternation\":\n            // TODO! This is not correct\n            for (const e of e1.value) {\n                const common = findCommonPrefix(e, e2);\n                if (common) {\n                    return common;\n                }\n            }\n            for (const e of e2.value as Expression[]) {\n                const common = findCommonPrefix(e1, e);\n                if (common) {\n                    return common;\n                }\n            }\n            return undefined;\n    }\n    return undefined;\n};\n\nexport const comparePrefix = (prefix: Expression, expr: Expression): boolean => {\n    if (prefix.type !== expr.type) {\n        return false;\n    }\n    switch (prefix.type) {\n        case \"literal\":\n        case \"nonterminal\":\n            return prefix.value === expr.value;\n        case \"group\":\n        case \"optional\":\n        case \"many\":\n        case \"many1\":\n            return comparePrefix(prefix.value, expr.value as Expression);\n        case \"minus\":\n        case \"skip\":\n        case \"next\":\n            return (\n                comparePrefix(prefix.value[0], expr.value[0]) &&\n                comparePrefix(prefix.value[1], expr.value[1])\n            );\n        case \"concatenation\":\n            return prefix.value.every((e, i) => comparePrefix(e, expr.value[i]));\n        case \"alternation\":\n            return prefix.value.some((e, i) => comparePrefix(e, expr.value[i]));\n        case \"epsilon\":\n            return true;\n    }\n};\n\nexport function rewriteTreeLeftRecursion(name: string, expr: Alteration) {\n    const prefixMap = new Map<Expression, Expression[]>();\n    let commonPrefix: Expression | null = null;\n\n    for (let i = 0; i < expr.value.length - 1; i++) {\n        const e1 = expr.value[i];\n        const e2 = expr.value[i + 1];\n\n        const common = findCommonPrefix(e1, e2);\n        if (common) {\n            const [prefix, te1, te2] = common;\n\n            if (commonPrefix !== null && comparePrefix(prefix, commonPrefix)) {\n                prefixMap.get(commonPrefix)!.push(te2);\n            } else {\n                prefixMap.set(prefix, [te1, te2]);\n                commonPrefix = prefix;\n            }\n            if (i === expr.value.length - 2) {\n                expr.value.shift();\n            }\n            expr.value.shift();\n            i -= 1;\n        }\n    }\n\n    for (const [prefix, expressions] of prefixMap) {\n        const alternation = {\n            type: \"alternation\",\n            value: expressions,\n        } as Alteration;\n        const newExpr = {\n            type: \"concatenation\",\n            value: [\n                {\n                    type: \"group\",\n                    value: alternation,\n                },\n                {\n                    type: \"group\",\n                    value: prefix,\n                },\n            ],\n        } as Concatenation;\n\n        expr.value.push(newExpr);\n    }\n}\n\nconst removeDirectLeftRecursionProduction = (\n    name: string,\n    expr: Alteration,\n    tailName: string\n) => {\n    const head = [];\n    const tail = [];\n\n    const APrime = {\n        type: \"nonterminal\",\n        value: tailName,\n    } as Nonterminal;\n\n    for (let i = 0; i < expr.value.length; i++) {\n        const e = expr.value[i];\n\n        if (e.type === \"concatenation\" && e.value[0].value === name) {\n            tail.push({\n                type: \"concatenation\",\n                value: [...e.value.slice(1), APrime],\n            });\n        } else {\n            head.push({\n                type: \"concatenation\",\n                value: [e, APrime],\n            });\n        }\n    }\n\n    if (tail.length === 0) {\n        return [undefined, undefined];\n    }\n\n    tail.push({\n        type: \"epsilon\",\n    } as Epsilon);\n\n    return [\n        {\n            type: \"alternation\",\n            value: head,\n        } as Alteration,\n        {\n            type: \"alternation\",\n            value: tail,\n        } as Alteration,\n    ] as const;\n};\n\nexport function removeDirectLeftRecursion(ast: AST) {\n    const newNodes = new Map() as AST;\n\n    let uniqueIndex = 0;\n    for (const [name, productionRule] of ast) {\n        const { expression } = productionRule;\n\n        if (expression.type === \"alternation\") {\n            const tailName = `${name}_${uniqueIndex++}`;\n\n            const [head, tail] = removeDirectLeftRecursionProduction(\n                name,\n                expression,\n                tailName\n            );\n\n            if (head) {\n                newNodes.set(tailName, {\n                    name: tailName,\n                    expression: tail,\n                } as ProductionRule);\n                newNodes.set(name, {\n                    name,\n                    expression: head,\n                    comment: productionRule.comment,\n                } as ProductionRule);\n            }\n        }\n    }\n\n    if (newNodes.size === 0) {\n        return ast;\n    }\n    for (const [name, productionRule] of newNodes) {\n        ast.set(name, productionRule);\n    }\n\n    for (const [name, productionRule] of ast) {\n        const { expression } = productionRule;\n        if (expression.type === \"alternation\") {\n            rewriteTreeLeftRecursion(name, expression);\n        }\n    }\n}\n\nexport function removeIndirectLeftRecursion(ast: AST) {\n    let i = 0;\n\n    let uniqueIndex = 0;\n    const betas = new Map<string, Expression>();\n\n    const recurse = (name: string, expr: Expression) => {\n        if (expr.type === \"concatenation\") {\n            if (expr.value[0].type === \"nonterminal\" && expr.value[0].value === name) {\n                const beta = {\n                    type: \"concatenation\",\n                    value: expr.value.slice(1, expr.value.length),\n                } as Concatenation;\n                const aj = expr.value.shift();\n                const tailName = `${name}_${uniqueIndex++}`;\n            }\n        }\n    };\n\n    for (const [name, expression] of ast) {\n        // recurse(name, expression);\n\n        i += 1;\n    }\n}\n\nexport function removeAllLeftRecursion(ast: AST) {\n    const newAST = topologicalSort(ast);\n\n    // removeIndirectLeftRecursion(newAST);\n    removeDirectLeftRecursion(newAST);\n\n    return newAST;\n}\n","import { Parser, all, any, eof, regex, string } from \"../parse\";\nimport { Expression, Nonterminals, AST, EBNFGrammar, ProductionRule } from \"./grammar\";\nimport { removeAllLeftRecursion } from \"./optimize\";\n\nexport function generateASTFromEBNF(input: string) {\n    const parser = new EBNFGrammar().grammar().eof();\n    const parsed = parser.parse(input);\n\n    if (!parsed) {\n        return [parser] as const;\n    }\n\n    const ast = parsed.reduce((acc, productionRule, ix) => {\n        return acc.set(productionRule.name, productionRule);\n    }, new Map<string, ProductionRule>()) as AST;\n\n    return [parser, ast] as const;\n}\n\nexport function generateParserFromAST(ast: AST) {\n    function generateParser(name: string, expr: Expression): Parser<any> {\n        switch (expr.type) {\n            case \"literal\":\n                return string(expr.value);\n            case \"nonterminal\":\n                const l = Parser.lazy(() => {\n                    return nonterminals[expr.value];\n                });\n                l.context.name = expr.value as any;\n                return l;\n\n            case \"epsilon\":\n                return eof().opt();\n\n            case \"group\":\n                return generateParser(name, expr.value);\n\n            case \"regex\":\n                return regex(expr.value);\n\n            case \"optionalWhitespace\":\n                return generateParser(name, expr.value).trim();\n\n            case \"optional\":\n                return generateParser(name, expr.value).opt();\n            case \"many\":\n                return generateParser(name, expr.value).many();\n            case \"many1\":\n                return generateParser(name, expr.value).many(1);\n            case \"skip\":\n                return generateParser(name, expr.value[0]).skip(\n                    generateParser(name, expr.value[1])\n                );\n            case \"next\":\n                return generateParser(name, expr.value[0]).next(\n                    generateParser(name, expr.value[1])\n                );\n            case \"minus\":\n                return generateParser(name, expr.value[0]).not(\n                    generateParser(name, expr.value[1])\n                );\n            case \"concatenation\": {\n                const parsers = expr.value.map((x) => generateParser(name, x));\n                if (parsers.at(-1)?.context?.name === \"eof\") {\n                    parsers.pop();\n                }\n                return all(...parsers);\n            }\n            case \"alternation\": {\n                return any(...expr.value.map((x) => generateParser(name, x)));\n            }\n        }\n    }\n\n    const nonterminals: Nonterminals = {};\n\n    for (const [name, productionRule] of ast.entries()) {\n        nonterminals[name] = generateParser(name, productionRule.expression);\n    }\n    return nonterminals;\n}\n\nexport function generateParserFromEBNF(input: string, optimizeGraph: boolean = false) {\n    let [parser, ast] = generateASTFromEBNF(input);\n\n    if (optimizeGraph) {\n        ast = removeAllLeftRecursion(ast);\n    }\n    const nonterminals = generateParserFromAST(ast);\n    return [nonterminals, ast] as const;\n}\n"],"names":["regex","any","string","all","lazy","Parser","eof"],"mappings":"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"}