{"version":3,"file":"ebnf.cjs","sources":["../src/ebnf/grammar.ts","../src/ebnf/optimize.ts","../src/ebnf/generate.ts","../src/ebnf/transform.ts"],"sourcesContent":["import { Parser, string, lazy, all, any, regex } from \"../parse\";\n\nexport type Expression =\n    | Literal\n    | Nonterminal\n    | Group\n    | Regex\n    | Optional\n    | Minus\n    | Many\n    | Many1\n    | Skip\n    | Next\n    | Concatenation\n    | Alteration\n    | Epsilon\n    | OptionalWhitespace;\n\ninterface BaseExpression<T, V = string> {\n    type: T;\n    value: V;\n    comment?: string[];\n}\n\nexport type Nonterminal = BaseExpression<\"nonterminal\">;\n\nexport type Literal = BaseExpression<\"literal\">;\nexport type Regex = BaseExpression<\"regex\", RegExp>;\nexport type Epsilon = BaseExpression<\"epsilon\">;\n\nexport type Group = BaseExpression<\"group\", Expression>;\nexport type ManyGroup = BaseExpression<\"many\", Expression>;\nexport type OptionalGroup = BaseExpression<\"optional\", Expression>;\n\nexport type Optional = BaseExpression<\"optional\", Expression>;\nexport type OptionalWhitespace = BaseExpression<\"optionalWhitespace\", undefined>;\n\nexport type Minus = BaseExpression<\"minus\", [Expression, Expression]>;\n\nexport type Many = BaseExpression<\"many\", Expression>;\nexport type Many1 = BaseExpression<\"many1\", Expression>;\nexport type Skip = BaseExpression<\"skip\", [Expression, Expression]>;\nexport type Next = BaseExpression<\"next\", [Expression, Expression]>;\n\nexport type Concatenation = BaseExpression<\"concatenation\", Expression[]>;\nexport type Alteration = BaseExpression<\"alternation\", Expression[]>;\n\nexport type ProductionRule = {\n    expression: Expression;\n    name: string;\n    comment: {\n        above?: string[];\n        below?: string[];\n    };\n};\n\nexport type AST = Map<string, ProductionRule>;\nexport type Nonterminals = { [key: string]: Parser<any> };\n\nexport class EBNFGrammar {\n    identifier() {\n        return regex(/[_a-zA-Z][_a-zA-Z0-9]*/).trim();\n    }\n\n    literal() {\n        return any(\n            regex(/[^\"]+/).wrap(string('\"'), string('\"')),\n            regex(/[^']+/).wrap(string(\"'\"), string(\"'\"))\n        ).map((value) => {\n            return {\n                type: \"literal\",\n                value,\n            } as Literal;\n        });\n    }\n\n    epsilon() {\n        return any(string(\"epsilon\"), string(\"Îµ\"))\n            .trim()\n            .map((value) => {\n                return {\n                    type: \"epsilon\",\n                    value: undefined,\n                } as Epsilon;\n            });\n    }\n\n    nonterminal() {\n        return this.identifier().map((value) => {\n            return {\n                type: \"nonterminal\",\n                value,\n            } as Nonterminal;\n        });\n    }\n\n    @lazy\n    group() {\n        return this.expression()\n            .trim()\n            .wrap(string(\"(\"), string(\")\"))\n            .map((value) => {\n                return {\n                    type: \"group\",\n                    value,\n                } as Group;\n            });\n    }\n\n    @lazy\n    regex() {\n        return regex(/[^\\/]*/)\n            .wrap(string(\"/\"), string(\"/\"))\n            .map((value) => {\n                return {\n                    type: \"regex\",\n                    value: new RegExp(value),\n                } as Regex;\n            });\n    }\n\n    optional() {\n        return this.term()\n            .skip(string(\"?\").trim())\n            .map((value) => {\n                return {\n                    type: \"optional\",\n                    value,\n                } as Optional;\n            });\n    }\n\n    @lazy\n    optionalGroup() {\n        return this.expression()\n            .trim()\n            .wrap(string(\"[\"), string(\"]\"))\n            .map((value) => {\n                return {\n                    type: \"optional\",\n                    value,\n                } as Optional;\n            });\n    }\n\n    optionalWhitespace() {\n        return this.term()\n            .skip(string(\"?w\").trim())\n            .map((value) => {\n                return {\n                    type: \"optionalWhitespace\",\n                    value,\n                } as OptionalWhitespace;\n            });\n    }\n\n    minus() {\n        return all(this.term().skip(string(\"-\").trim()), this.term()).map(\n            ([left, right]) => {\n                return {\n                    type: \"minus\",\n                    value: [left, right],\n                } as Minus;\n            }\n        );\n    }\n\n    @lazy\n    manyGroup() {\n        return this.expression()\n            .trim()\n            .wrap(string(\"{\"), string(\"}\"))\n            .map((value) => {\n                return {\n                    type: \"many\",\n                    value,\n                } as Many;\n            });\n    }\n\n    many() {\n        return this.term()\n            .skip(string(\"*\").trim())\n            .map((value) => {\n                return {\n                    type: \"many\",\n                    value,\n                } as Many;\n            });\n    }\n\n    many1() {\n        return this.term()\n            .skip(string(\"+\").trim())\n            .map((value) => {\n                return {\n                    type: \"many1\",\n                    value,\n                } as Many1;\n            });\n    }\n\n    @lazy\n    next() {\n        return all(\n            this.factor().skip(string(\">>\").trim()),\n            any(this.skip(), this.factor())\n        ).map(([left, right]) => {\n            return {\n                type: \"next\",\n                value: [left, right],\n            } as Next;\n        });\n    }\n\n    @lazy\n    skip() {\n        return all(\n            any(this.next(), this.factor()).skip(string(\"<<\").trim()),\n            this.factor()\n        ).map(([left, right]) => {\n            return {\n                type: \"skip\",\n                value: [left, right],\n            } as Skip;\n        });\n    }\n\n    concatenation() {\n        return any(this.skip(), this.next(), this.factor())\n            .sepBy(string(\",\").trim(), 1)\n            .map((value) => {\n                return {\n                    type: \"concatenation\",\n                    value,\n                } as Concatenation;\n            });\n    }\n\n    alternation() {\n        return any(this.concatenation(), this.skip(), this.next(), this.factor())\n            .sepBy(string(\"|\").trim(), 1)\n            .map((value) => {\n                return {\n                    type: \"alternation\",\n                    value,\n                } as Alteration;\n            });\n    }\n\n    bigComment() {\n        return regex(/\\/\\*[^]*?\\*\\//).trim();\n    }\n\n    comment() {\n        return regex(/\\/\\/.*/)\n            .trim()\n            .or(this.bigComment());\n    }\n\n    term() {\n        return any(\n            this.epsilon(),\n            this.literal(),\n            this.nonterminal(),\n            this.regex(),\n            this.group(),\n            this.optionalGroup(),\n            this.manyGroup()\n        )\n            .then(this.bigComment().opt())\n            .map(([left, comment]) => {\n                left.comment = comment;\n                return left as unknown as Expression;\n            }) as Parser<Expression>;\n    }\n\n    factor() {\n        return any(\n            this.optionalWhitespace(),\n            this.optional(),\n            this.many(),\n            this.many1(),\n            this.minus(),\n            this.term()\n        ) as Parser<Expression>;\n    }\n\n    expression() {\n        return any(\n            this.alternation(),\n            this.concatenation(),\n            this.skip(),\n            this.next(),\n            this.factor()\n        ) as Parser<Expression>;\n    }\n\n    productionRule() {\n        return all(\n            this.identifier().skip(string(\"=\").trim()),\n            this.expression().skip(any(string(\";\").trim(), string(\".\").trim()))\n        ).map(([name, expression]) => {\n            return { name, expression } as ProductionRule;\n        });\n    }\n\n    grammar() {\n        return all(this.comment().many(), this.productionRule(), this.comment().many())\n            .map(([above, rule, below]) => {\n                rule.comment = {\n                    above,\n                    below,\n                };\n                return rule;\n            })\n            .many(1);\n    }\n}\n","import {\n    Alteration,\n    AST,\n    Concatenation,\n    Epsilon,\n    Expression,\n    Nonterminal,\n    ProductionRule,\n} from \"./grammar\";\n\nexport function topologicalSort(ast: AST) {\n    const visited = new Set<string>();\n    const order: ProductionRule[] = [];\n\n    function visit(node: string, stack: Set<string>) {\n        if (stack.has(node) || visited.has(node)) {\n            return;\n        }\n\n        stack.add(node);\n        const productionRule = ast.get(node)!;\n\n        if (!productionRule) {\n            return;\n        }\n\n        const expr = productionRule.expression;\n\n        if (expr.type === \"nonterminal\") {\n            visit(expr.value, stack);\n        } else if (expr.value instanceof Array) {\n            for (const child of expr.value) {\n                if (child.type === \"nonterminal\") {\n                    visit(child.value, stack);\n                }\n            }\n        }\n\n        visited.add(node);\n        stack.delete(node);\n\n        order.unshift(ast.get(node) as ProductionRule);\n    }\n\n    for (const [name] of ast) {\n        visit(name, new Set<string>());\n    }\n\n    const newAST = new Map() as AST;\n    for (const rule of order) {\n        newAST.set(rule.name, rule);\n    }\n\n    return newAST;\n}\n\nexport const findCommonPrefix = (\n    e1: Expression,\n    e2: Expression\n): [Expression | null, Expression, Expression] => {\n    if (!e1?.type || !e2?.type || e1.type !== e2.type) {\n        return undefined;\n    }\n\n    switch (e1.type) {\n        case \"literal\":\n        case \"nonterminal\": {\n            if (e1.value !== e2.value) {\n                return undefined;\n            } else {\n                return [e1, { type: \"epsilon\" }, { type: \"epsilon\" }] as [\n                    Expression,\n                    Expression,\n                    Expression\n                ];\n            }\n        }\n\n        case \"group\":\n        case \"optional\":\n        case \"many\":\n        case \"many1\": {\n            const common = findCommonPrefix(e1.value, e2.value as Expression);\n            if (!common) {\n                return undefined;\n            } else {\n                return [\n                    {\n                        type: e1.type,\n                        value: common[0],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[1],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[2],\n                    },\n                ] as [Expression, Expression, Expression];\n            }\n        }\n\n        case \"concatenation\": {\n            const commons = e1.value.map((_, i) =>\n                findCommonPrefix(e1.value[i], e2.value[i])\n            );\n            if (commons.some((x) => x === undefined)) {\n                return undefined;\n            }\n\n            const prefixes = commons.map((x) => x[0]);\n            const e1s = commons.map((x) => x[1]);\n            const e2s = commons.map((x) => x[2]);\n\n            const startIx = prefixes.lastIndexOf(null);\n            if (startIx === prefixes.length - 1) {\n                return undefined;\n            }\n\n            const prefix = prefixes.slice(startIx + 1);\n            return [\n                {\n                    type: \"concatenation\",\n                    value: prefix,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e1s,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e2s,\n                },\n            ];\n        }\n\n        case \"alternation\":\n            // TODO! This is not correct\n            for (const e of e1.value) {\n                const common = findCommonPrefix(e, e2);\n                if (common) {\n                    return common;\n                }\n            }\n            for (const e of e2.value as Expression[]) {\n                const common = findCommonPrefix(e1, e);\n                if (common) {\n                    return common;\n                }\n            }\n            return undefined;\n    }\n    return undefined;\n};\n\nexport const comparePrefix = (prefix: Expression, expr: Expression): boolean => {\n    if (prefix.type !== expr.type) {\n        return false;\n    }\n    switch (prefix.type) {\n        case \"literal\":\n        case \"nonterminal\":\n            return prefix.value === expr.value;\n        case \"group\":\n        case \"optional\":\n        case \"many\":\n        case \"many1\":\n            return comparePrefix(prefix.value, expr.value as Expression);\n        case \"minus\":\n        case \"skip\":\n        case \"next\":\n            return (\n                comparePrefix(prefix.value[0], expr.value[0]) &&\n                comparePrefix(prefix.value[1], expr.value[1])\n            );\n        case \"concatenation\":\n            return prefix.value.every((e, i) => comparePrefix(e, expr.value[i]));\n        case \"alternation\":\n            return prefix.value.some((e, i) => comparePrefix(e, expr.value[i]));\n        case \"epsilon\":\n            return true;\n    }\n};\n\nexport function rewriteTreeLeftRecursion(name: string, expr: Alteration) {\n    const prefixMap = new Map<Expression, Expression[]>();\n    let commonPrefix: Expression | null = null;\n\n    for (let i = 0; i < expr.value.length - 1; i++) {\n        const e1 = expr.value[i];\n        const e2 = expr.value[i + 1];\n\n        const common = findCommonPrefix(e1, e2);\n        if (common) {\n            const [prefix, te1, te2] = common;\n\n            if (commonPrefix !== null && comparePrefix(prefix, commonPrefix)) {\n                prefixMap.get(commonPrefix)!.push(te2);\n            } else {\n                prefixMap.set(prefix, [te1, te2]);\n                commonPrefix = prefix;\n            }\n            if (i === expr.value.length - 2) {\n                expr.value.shift();\n            }\n            expr.value.shift();\n            i -= 1;\n        }\n    }\n\n    for (const [prefix, expressions] of prefixMap) {\n        const alternation = {\n            type: \"alternation\",\n            value: expressions,\n        } as Alteration;\n        const newExpr = {\n            type: \"concatenation\",\n            value: [\n                {\n                    type: \"group\",\n                    value: alternation,\n                },\n                {\n                    type: \"group\",\n                    value: prefix,\n                },\n            ],\n        } as Concatenation;\n\n        expr.value.push(newExpr);\n    }\n}\n\nconst removeDirectLeftRecursionProduction = (\n    name: string,\n    expr: Alteration,\n    tailName: string\n) => {\n    const head = [];\n    const tail = [];\n\n    const APrime = {\n        type: \"nonterminal\",\n        value: tailName,\n    } as Nonterminal;\n\n    for (let i = 0; i < expr.value.length; i++) {\n        const e = expr.value[i];\n\n        if (e.type === \"concatenation\" && e.value[0].value === name) {\n            tail.push({\n                type: \"concatenation\",\n                value: [...e.value.slice(1), APrime],\n            });\n        } else {\n            head.push({\n                type: \"concatenation\",\n                value: [e, APrime],\n            });\n        }\n    }\n\n    // No direct left recursion\n    if (tail.length === 0) {\n        return [undefined, undefined];\n    }\n\n    tail.push({\n        type: \"epsilon\",\n    } as Epsilon);\n\n    return [\n        {\n            type: \"alternation\",\n            value: head,\n        } as Alteration,\n        {\n            type: \"alternation\",\n            value: tail,\n        } as Alteration,\n    ] as const;\n};\n\nexport function removeDirectLeftRecursion(ast: AST) {\n    const newNodes = new Map() as AST;\n\n    let uniqueIndex = 0;\n    for (const [name, productionRule] of ast) {\n        const { expression } = productionRule;\n\n        if (expression.type === \"alternation\") {\n            const tailName = `${name}_${uniqueIndex++}`;\n\n            const [head, tail] = removeDirectLeftRecursionProduction(\n                name,\n                expression,\n                tailName\n            );\n\n            if (head) {\n                newNodes.set(tailName, {\n                    name: tailName,\n                    expression: tail,\n                } as ProductionRule);\n                newNodes.set(name, {\n                    name,\n                    expression: head,\n                    comment: productionRule.comment,\n                } as ProductionRule);\n            }\n        }\n    }\n\n    if (newNodes.size === 0) {\n        return ast;\n    }\n    for (const [name, productionRule] of newNodes) {\n        ast.set(name, productionRule);\n    }\n\n    for (const [name, productionRule] of ast) {\n        const { expression } = productionRule;\n        if (expression.type === \"alternation\") {\n            rewriteTreeLeftRecursion(name, expression);\n        }\n    }\n}\n\nexport function removeIndirectLeftRecursion(ast: AST) {\n    let i = 0;\n\n    let uniqueIndex = 0;\n    const betas = new Map<string, Expression>();\n\n    const recurse = (name: string, expr: Expression) => {\n        if (expr.type === \"concatenation\") {\n            if (expr.value[0].type === \"nonterminal\" && expr.value[0].value === name) {\n                const beta = {\n                    type: \"concatenation\",\n                    value: expr.value.slice(1, expr.value.length),\n                } as Concatenation;\n                const aj = expr.value.shift();\n                const tailName = `${name}_${uniqueIndex++}`;\n            }\n        }\n    };\n\n    for (const [name, expression] of ast) {\n        recurse(name, expression);\n\n        i += 1;\n    }\n}\n\nexport function removeAllLeftRecursion(ast: AST) {\n    const newAST = topologicalSort(ast);\n\n    // removeIndirectLeftRecursion(newAST);\n    removeDirectLeftRecursion(newAST);\n\n    return newAST;\n}\n","import { Parser, all, any, eof, regex, string } from \"../parse\";\nimport { Expression, Nonterminals, AST, EBNFGrammar, ProductionRule } from \"./grammar\";\nimport { removeAllLeftRecursion } from \"./optimize\";\n\nexport function generateASTFromEBNF(input: string) {\n    const parser = new EBNFGrammar().grammar().trim();\n    const parsed = parser.parse(input);\n\n    if (!parsed) {\n        throw new Error(\"Failed to parse EBNF grammar\");\n    }\n\n    return parsed.reduce((acc, productionRule, ix) => {\n        acc.set(productionRule.name, productionRule);\n        return acc;\n    }, new Map<string, ProductionRule>()) as AST;\n}\n\nexport function generateParserFromAST(ast: AST) {\n    function generateParser(name: string, expr: Expression): Parser<any> {\n        switch (expr.type) {\n            case \"literal\":\n                return string(expr.value);\n            case \"nonterminal\":\n                const l = Parser.lazy(() => {\n                    return nonterminals[expr.value];\n                });\n                l.context.name = expr.value as any;\n                return l;\n\n            case \"epsilon\":\n                return eof().opt();\n\n            case \"group\":\n                return generateParser(name, expr.value);\n\n            case \"regex\":\n                return regex(expr.value);\n\n            case \"optionalWhitespace\":\n                return generateParser(name, expr.value).trim();\n\n            case \"optional\":\n                return generateParser(name, expr.value).opt();\n            case \"many\":\n                return generateParser(name, expr.value).many();\n            case \"many1\":\n                return generateParser(name, expr.value).many(1);\n            case \"skip\":\n                return generateParser(name, expr.value[0]).skip(\n                    generateParser(name, expr.value[1])\n                );\n            case \"next\":\n                return generateParser(name, expr.value[0]).next(\n                    generateParser(name, expr.value[1])\n                );\n            case \"minus\":\n                return generateParser(name, expr.value[0]).not(\n                    generateParser(name, expr.value[1])\n                );\n            case \"concatenation\": {\n                const parsers = expr.value.map((x) => generateParser(name, x));\n                if (parsers.at(-1)?.context?.name === \"eof\") {\n                    parsers.pop();\n                }\n                return all(...parsers);\n            }\n            case \"alternation\": {\n                return any(...expr.value.map((x) => generateParser(name, x)));\n            }\n        }\n    }\n\n    const nonterminals: Nonterminals = {};\n\n    for (const [name, productionRule] of ast.entries()) {\n        nonterminals[name] = generateParser(name, productionRule.expression);\n    }\n    return nonterminals;\n}\n\nexport function generateParserFromEBNF(input: string, optimizeGraph: boolean = false) {\n    let ast = generateASTFromEBNF(input);\n\n    if (optimizeGraph) {\n        ast = removeAllLeftRecursion(ast);\n    }\n    const nonterminals = generateParserFromAST(ast);\n    return [nonterminals, ast] as const;\n}\n","import { Expression, AST } from \"./grammar\";\n\nimport { generateParserFromEBNF } from \"./generate\";\n\nfunction breakLineOnSeparator(input: string, separator: string): string {\n    const lines = input.split(separator);\n\n    if (lines.length === 1) {\n        return input;\n    }\n\n    input = lines\n        .map((line, i) => {\n            if (i === lines.length - 1) {\n                return separator + line;\n            } else if (i === 0) {\n                return line;\n            }\n\n            const groups = line.split(\",\");\n\n            if (groups.length > 1) {\n                return `\\n\\t${separator} ` + line;\n            } else {\n                return separator + line;\n            }\n        })\n        .join(\"\");\n\n    const maxLineLength = 66;\n\n    if (input.length > maxLineLength) {\n        let di = maxLineLength;\n\n        for (let i = 0; i < input.length; i += di) {\n            const nearestSepIx = i === 0 ? maxLineLength : i + di;\n            const nearestSep = input.indexOf(separator, nearestSepIx);\n\n            if (nearestSep === -1) {\n                break;\n            }\n            input =\n                input.slice(0, nearestSep) +\n                `\\n\\t${separator}` +\n                input.slice(nearestSep + 1);\n        }\n    }\n\n    return input;\n}\n\nconst nonterminalsToTrim = [\n    \"symbol\",\n    \"identifier\",\n    \"terminal\",\n    \"pipe\",\n    \"comma\",\n    \"plus\",\n    \"minus\",\n    \"star\",\n    \"div\",\n    \"question\",\n    \"eof\",\n    \"optional_whitespace\",\n    \"regex\",\n    \"rhs\",\n    \"rule\",\n    \"grammar\",\n];\n\nexport const EBNFParser = (grammar: string) => {\n    const [nonterminals, ast] = generateParserFromEBNF(grammar);\n\n    for (const name of nonterminalsToTrim) {\n        nonterminals[name] = nonterminals[name].trim();\n    }\n\n    nonterminals.symbol = nonterminals.symbol;\n\n    nonterminals.identifier = nonterminals.identifier.map((v) => {\n        return v.flat().join(\"\");\n    });\n\n    nonterminals.terminal = nonterminals.terminal.map((v) => {\n        return v.flat().join(\"\");\n    });\n\n    nonterminals.regex = nonterminals.regex.map((v) => {\n        const s = v.flat().join(\"\");\n        return s;\n    });\n\n    nonterminals.rhs = nonterminals.rhs.map((v) => {\n        const a = v instanceof Array ? v.flat(Infinity) : v;\n        const s = a.join(\" \");\n        return breakLineOnSeparator(s, \"|\");\n    });\n\n    nonterminals.rule = nonterminals.rule.map((v) => {\n        const s = v.flat().join(\" \");\n        return s;\n    });\n\n    return nonterminals.grammar.map((rules) => {\n        let lastIx = 0;\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i];\n\n            if (rule.length > 80) {\n                rules[i] = rule + \"\\n\";\n                if (i > 0 && lastIx !== i - 1) {\n                    rules[i - 1] = rules[i - 1] + \"\\n\";\n                }\n                lastIx = i;\n            } else if (i - lastIx > 2) {\n                rules[i] = rule + \"\\n\";\n                lastIx = i;\n            }\n        }\n        return rules.join(\"\\n\");\n    });\n\n    // debugging(nonterminals);\n};\n\nfunction escapeRegExp(string: string): string {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\ntype TextMateProductionRule = {\n    name: string;\n    match: string;\n};\n\ntype TextMateLanguage = {\n    name: string;\n    scopeName: string;\n    fileTypes: string[];\n    patterns: TextMateProductionRule[];\n};\n\nfunction transformEBNFASTToTextMateRegExp(expression: Expression): string {\n    switch (expression.type) {\n        case \"literal\":\n            return escapeRegExp(expression.value);\n        case \"nonterminal\":\n            return `($${expression.value})`;\n        case \"epsilon\":\n            return \"\";\n        case \"group\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})`;\n        case \"regex\":\n            return expression.value.source;\n        case \"optional\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})?`;\n        case \"minus\":\n            return `${transformEBNFASTToTextMateRegExp(\n                expression.value[0]\n            )}(?!${transformEBNFASTToTextMateRegExp(expression.value[1])})`;\n        case \"many\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})*`;\n        case \"many1\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})+`;\n        case \"skip\":\n            return `${transformEBNFASTToTextMateRegExp(\n                expression.value[0]\n            )}(?:${transformEBNFASTToTextMateRegExp(expression.value[1])})?`;\n        case \"next\":\n            return `${transformEBNFASTToTextMateRegExp(\n                expression.value[0]\n            )}(?=${transformEBNFASTToTextMateRegExp(expression.value[1])})`;\n        case \"concatenation\":\n            return expression.value.map(transformEBNFASTToTextMateRegExp).join(\"\");\n        case \"alternation\":\n            return expression.value\n                .map((expr) => `(${transformEBNFASTToTextMateRegExp(expr)})`)\n                .join(\"|\");\n    }\n}\n\nexport function transformEBNFASTToTextMateLanguage(ast: AST): TextMateLanguage {\n    const rules: TextMateProductionRule[] = [];\n\n    // Traverse the EBNF AST and transform each production rule into a TextMate production rule\n    for (const [name, expr] of ast) {\n        rules.push({\n            name,\n            match: transformEBNFASTToTextMateRegExp(expr),\n        });\n    }\n    // Create and return the TextMate language object\n    return {\n        name: \"EEBNF\",\n        scopeName: \"source.eebnf\",\n        fileTypes: [\"eebnf\"],\n        patterns: rules,\n    };\n}\n"],"names":["EBNFGrammar","regex","any","string","value","all","left","right","comment","name","expression","above","rule","below","__decorateClass","lazy","topologicalSort","ast","visited","order","visit","node","stack","productionRule","expr","child","newAST","findCommonPrefix","e1","e2","common","commons","_","i","x","prefixes","e1s","e2s","startIx","e","comparePrefix","prefix","rewriteTreeLeftRecursion","prefixMap","commonPrefix","te1","te2","expressions","newExpr","removeDirectLeftRecursionProduction","tailName","head","tail","APrime","removeDirectLeftRecursion","newNodes","uniqueIndex","removeIndirectLeftRecursion","recurse","removeAllLeftRecursion","generateASTFromEBNF","input","parsed","acc","ix","generateParserFromAST","generateParser","Parser","nonterminals","eof","parsers","_b","_a","generateParserFromEBNF","optimizeGraph","breakLineOnSeparator","separator","lines","line","maxLineLength","di","nearestSepIx","nearestSep","nonterminalsToTrim","EBNFParser","grammar","v","s","rules","lastIx","escapeRegExp","transformEBNFASTToTextMateRegExp","transformEBNFASTToTextMateLanguage"],"mappings":"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"}