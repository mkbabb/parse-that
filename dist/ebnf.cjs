"use strict";var B=Object.defineProperty;var b=(o,e,n)=>e in o?B(o,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):o[e]=n;var g=(o,e,n)=>(b(o,typeof e!="symbol"?e+"":e,n),n);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const r=require("./parse.cjs");require("chalk");var A=Object.defineProperty,S=Object.getOwnPropertyDescriptor,p=(o,e,n,t)=>{for(var a=t>1?void 0:t?S(e,n):e,i=o.length-1,s;i>=0;i--)(s=o[i])&&(a=(t?s(e,n,a):s(a))||a);return t&&a&&A(e,n,a),a};const h={"|":"alternation",",":"concatenation","-":"minus","<<":"skip",">>":"next","*":"many","+":"many1","?":"optional","?w":"optionalWhitespace"},T=([o,e])=>e.length===0?o:e.reduce((n,[t,a])=>({type:h[t],value:[n,a]}),o),C=([o,e])=>e===void 0?o:{type:h[e],value:o},E={debug:!1,comments:!0};class c{constructor(e){g(this,"options");this.options={...E,...e??{}}}identifier(){return r.regex(/[_a-zA-Z][_a-zA-Z0-9]*/).trim()}literal(){return this.trimBigComment(r.any(r.regex(/[^"]+/).wrap(r.string('"'),r.string('"')),r.regex(/[^']+/).wrap(r.string("'"),r.string("'"))).map(e=>({type:"literal",value:e})))}epsilon(){return r.any(r.string("epsilon"),r.string("Îµ")).trim().map(e=>({type:"epsilon",value:void 0}))}nonterminal(){return this.identifier().map(e=>({type:"nonterminal",value:e}))}bigComment(){return r.regex(/\/\*[^\*]*\*\//).trim()}comment(){return r.regex(/\/\/.*/).or(this.bigComment()).trim()}trimBigComment(e){return e.trim(this.bigComment().many(),!1).map(([n,t,a])=>(t.comment={left:n,right:a},t))}group(){return this.rhs().trim().wrap(r.string("("),r.string(")")).map(e=>({type:"group",value:e}))}regex(){return r.regex(/[^\/]*/).wrap(r.string("/"),r.string("/")).then(r.regex(/[gimuy]*/).opt()).map(([e,n])=>({type:"regex",value:new RegExp(e,n)}))}optionalGroup(){return this.rhs().trim().wrap(r.string("["),r.string("]")).map(e=>({type:"optional",value:e}))}manyGroup(){return this.rhs().trim().wrap(r.string("{"),r.string("}")).map(e=>({type:"many",value:e}))}lhs(){return this.identifier()}term(){return r.any(this.epsilon(),this.group(),this.optionalGroup(),this.manyGroup(),this.nonterminal(),this.literal(),this.regex())}factor(){return this.trimBigComment(r.all(this.term(),r.any(r.string("?w").trim(),r.string("?").trim(),r.string("*").trim(),r.string("+").trim()).opt()).map(C))}binaryFactor(){return r.all(this.factor(),r.all(r.any(r.string("<<").trim(),r.string(">>").trim(),r.string("-").trim()),this.factor()).many()).map(T)}concatenation(){return this.binaryFactor().sepBy(r.string(",").trim()).map(e=>e.length===1?e[0]:{type:"concatenation",value:e})}alternation(){return this.concatenation().sepBy(r.string("|").trim()).map(e=>e.length===1?e[0]:{type:"alternation",value:e})}rhs(){return this.alternation()}productionRule(){return r.all(this.lhs(),r.string("=").trim(),this.rhs(),r.any(r.string(";"),r.string(".")).trim()).map(([e,,n])=>({name:e,expression:n}))}grammar(){return this.productionRule().trim(this.comment().many(),!1).map(([e,n,t])=>(n.comment={above:e,below:t},n)).many(1)}}p([r.lazy],c.prototype,"bigComment",1);p([r.lazy],c.prototype,"comment",1);p([r.lazy],c.prototype,"group",1);p([r.lazy],c.prototype,"regex",1);p([r.lazy],c.prototype,"optionalGroup",1);p([r.lazy],c.prototype,"manyGroup",1);p([r.lazy],c.prototype,"lhs",1);p([r.lazy],c.prototype,"term",1);p([r.lazy],c.prototype,"factor",1);p([r.lazy],c.prototype,"binaryFactor",1);p([r.lazy],c.prototype,"concatenation",1);p([r.lazy],c.prototype,"alternation",1);p([r.lazy],c.prototype,"rhs",1);p([r.lazy],c.prototype,"productionRule",1);p([r.lazy],c.prototype,"grammar",1);function d(o){const e=new Set,n=[];function t(i,s){if(s.has(i)||e.has(i))return;s.add(i);const l=o.get(i);if(!l)return;const u=l.expression;if(u.type==="nonterminal")t(u.value,s);else if(u.value instanceof Array)for(const m of u.value)m.type==="nonterminal"&&t(m.value,s);e.add(i),s.delete(i),n.unshift(o.get(i))}for(const[i]of o)t(i,new Set);const a=new Map;for(const i of n)a.set(i.name,i);return a}const f=(o,e)=>{if(!(!(o!=null&&o.type)||!(e!=null&&e.type)||o.type!==e.type))switch(o.type){case"literal":case"nonterminal":return o.value!==e.value?void 0:[o,{type:"epsilon"},{type:"epsilon"}];case"group":case"optional":case"optionalWhitespace":case"many":case"many1":{const n=f(o.value,e.value);return n?[{type:o.type,value:n[0]},{type:o.type,value:n[1]},{type:o.type,value:n[2]}]:void 0}case"concatenation":{const n=o.value.map((u,m)=>f(o.value[m],e.value[m]));if(n.some(u=>u===void 0))return;const t=n.map(u=>u[0]),a=n.map(u=>u[1]),i=n.map(u=>u[2]),s=t.lastIndexOf(null);return s===t.length-1?void 0:[{type:"concatenation",value:t.slice(s+1)},{type:"concatenation",value:a},{type:"concatenation",value:i}]}case"alternation":for(const n of o.value){const t=f(n,e);if(t)return t}for(const n of e.value){const t=f(o,n);if(t)return t}return}},y=(o,e)=>{if(o.type!==e.type)return!1;switch(o.type){case"literal":case"nonterminal":return o.value===e.value;case"group":case"optional":case"many":case"many1":return y(o.value,e.value);case"minus":case"skip":case"next":return y(o.value[0],e.value[0])&&y(o.value[1],e.value[1]);case"concatenation":return o.value.every((n,t)=>y(n,e.value[t]));case"alternation":return o.value.some((n,t)=>y(n,e.value[t]));case"epsilon":return!0}};function w(o,e){const n=new Map;let t=null;for(let a=0;a<e.value.length-1;a++){const i=e.value[a],s=e.value[a+1],l=f(i,s);if(l){const[u,m,v]=l;t!==null&&y(u,t)?n.get(t).push(v):(n.set(u,[m,v]),t=u),a===e.value.length-2&&e.value.shift(),e.value.shift(),a-=1}}for(const[a,i]of n){const l={type:"concatenation",value:[{type:"group",value:{type:"alternation",value:i}},{type:"group",value:a}]};e.value.push(l)}}const _=(o,e,n)=>{const t=[],a=[],i={type:"nonterminal",value:n};for(let s=0;s<e.value.length;s++){const l=e.value[s];l.type==="concatenation"&&l.value[0].value===o?a.push({type:"concatenation",value:[...l.value.slice(1),i]}):t.push({type:"concatenation",value:[l,i]})}return a.length===0?[void 0,void 0]:(a.push({type:"epsilon"}),[{type:"alternation",value:t},{type:"alternation",value:a}])};function z(o){const e=new Map;let n=0;for(const[t,a]of o){const{expression:i}=a;if(i.type==="alternation"){const s=`${t}_${n++}`,[l,u]=_(t,i,s);l&&(e.set(s,{name:s,expression:u}),e.set(t,{name:t,expression:l,comment:a.comment}))}}if(e.size===0)return o;for(const[t,a]of e)o.set(t,a);for(const[t,a]of o){const{expression:i}=a;i.type==="alternation"&&w(t,i)}}function L(o){const e=(n,t)=>{t.type==="concatenation"&&t.value[0].type==="nonterminal"&&t.value[0].value===n&&(t.value.slice(1,t.value.length),t.value.shift())};for(const[n,t]of o)e(n,t)}function F(o){const e=d(o);return z(e),e}function P(o){const n=new c().grammar().parse(o);if(!n)throw new Error("Failed to parse EBNF grammar");return n.reduce((t,a,i)=>t.set(a.name,a),new Map)}function R(o){function e(t,a){var i,s;switch(a.type){case"literal":return r.string(a.value);case"nonterminal":const l=r.Parser.lazy(()=>n[a.value]);return l.context.name=a.value,l;case"epsilon":return r.eof().opt();case"group":return e(t,a.value);case"regex":return r.regex(a.value);case"optionalWhitespace":return e(t,a.value).trim();case"optional":return e(t,a.value).opt();case"many":return e(t,a.value).many();case"many1":return e(t,a.value).many(1);case"skip":return e(t,a.value[0]).skip(e(t,a.value[1]));case"next":return e(t,a.value[0]).next(e(t,a.value[1]));case"minus":return e(t,a.value[0]).not(e(t,a.value[1]));case"concatenation":{const u=a.value.map(m=>e(t,m));return((s=(i=u.at(-1))==null?void 0:i.context)==null?void 0:s.name)==="eof"&&u.pop(),r.all(...u)}case"alternation":return r.any(...a.value.map(u=>e(t,u)))}}const n={};for(const[t,a]of o.entries())n[t]=e(t,a.expression);return n}function N(o,e=!1){let n=P(o);return e&&(n=F(n)),[R(n),n]}exports.EBNFGrammar=c;exports.comparePrefix=y;exports.findCommonPrefix=f;exports.generateASTFromEBNF=P;exports.generateParserFromAST=R;exports.generateParserFromEBNF=N;exports.removeAllLeftRecursion=F;exports.removeDirectLeftRecursion=z;exports.removeIndirectLeftRecursion=L;exports.rewriteTreeLeftRecursion=w;exports.topologicalSort=d;
//# sourceMappingURL=ebnf.cjs.map
