"use strict";var z=Object.defineProperty;var F=(a,t,o)=>t in a?z(a,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):a[t]=o;var g=(a,t,o)=>(F(a,typeof t!="symbol"?t+"":t,o),o);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const n=require("./parse.cjs");var P=Object.defineProperty,b=Object.getOwnPropertyDescriptor,p=(a,t,o,e)=>{for(var r=e>1?void 0:e?b(t,o):t,i=a.length-1,s;i>=0;i--)(s=a[i])&&(r=(e?s(t,o,r):s(r))||r);return e&&r&&P(t,o,r),r};const h={"|":"alternation",",":"concatenation","-":"minus","<<":"skip",">>":"next","*":"many","+":"many1","?":"optional","?w":"optionalWhitespace"},B=([a,t])=>t.length===0?a:t.reduce((o,[e,r])=>({type:h[e],value:[o,r]}),a),R=([a,t])=>t===void 0?a:{type:h[t],value:a},A={debug:!1,comments:!0};class c{constructor(t){g(this,"options");this.options={...A,...t??{}}}identifier(){return n.regex(/[_a-zA-Z][_a-zA-Z0-9]*/).trim()}literal(){return this.trimBigComment(n.any(n.regex(/[^"]+/).wrap(n.string('"'),n.string('"')),n.regex(/[^']+/).wrap(n.string("'"),n.string("'"))).map(t=>({type:"literal",value:t})))}epsilon(){return n.any(n.string("epsilon"),n.string("Îµ")).trim().map(t=>({type:"epsilon",value:void 0}))}nonterminal(){return this.identifier().map(t=>({type:"nonterminal",value:t}))}bigComment(){return n.regex(/\/\*[^\*]*\*\//).trim()}comment(){return n.regex(/\/\/.*/).or(this.bigComment()).trim()}trimBigComment(t){return t.trim(this.bigComment().many(),!1).map(([o,e,r])=>(e.comment={left:o,right:r},e))}group(){return this.rhs().trim().wrap(n.string("("),n.string(")")).map(t=>({type:"group",value:t}))}regex(){return n.regex(/[^\/]*/).wrap(n.string("/"),n.string("/")).map(t=>({type:"regex",value:new RegExp(t)}))}optionalGroup(){return this.rhs().trim().wrap(n.string("["),n.string("]")).map(t=>({type:"optional",value:t}))}manyGroup(){return this.rhs().trim().wrap(n.string("{"),n.string("}")).map(t=>({type:"many",value:t}))}lhs(){return this.identifier()}term(){return n.any(this.epsilon(),this.group(),this.optionalGroup(),this.manyGroup(),this.nonterminal(),this.literal(),this.regex())}factor(){return this.trimBigComment(n.all(this.term(),n.any(n.string("?w").trim(),n.string("?").trim(),n.string("*").trim(),n.string("+").trim()).opt()).map(R))}binaryFactor(){return n.all(this.factor(),n.all(n.any(n.string("<<").trim(),n.string(">>").trim(),n.string("-").trim()),this.factor()).many()).map(B)}concatenation(){return this.binaryFactor().sepBy(n.string(",").trim()).map(t=>t.length===1?t[0]:{type:"concatenation",value:t})}alternation(){return this.concatenation().sepBy(n.string("|").trim()).map(t=>t.length===1?t[0]:{type:"alternation",value:t})}rhs(){return this.alternation()}productionRule(){return n.all(this.lhs(),n.string("=").trim(),this.rhs(),n.any(n.string(";"),n.string(".")).trim()).map(([t,,o])=>({name:t,expression:o}))}grammar(){return this.productionRule().trim(this.comment().many(),!1).map(([t,o,e])=>(o.comment={above:t,below:e},o)).many(1)}}p([n.lazy],c.prototype,"bigComment",1);p([n.lazy],c.prototype,"comment",1);p([n.lazy],c.prototype,"group",1);p([n.lazy],c.prototype,"regex",1);p([n.lazy],c.prototype,"optionalGroup",1);p([n.lazy],c.prototype,"manyGroup",1);p([n.lazy],c.prototype,"lhs",1);p([n.lazy],c.prototype,"term",1);p([n.lazy],c.prototype,"factor",1);p([n.lazy],c.prototype,"binaryFactor",1);p([n.lazy],c.prototype,"concatenation",1);p([n.lazy],c.prototype,"alternation",1);p([n.lazy],c.prototype,"rhs",1);p([n.lazy],c.prototype,"productionRule",1);p([n.lazy],c.prototype,"grammar",1);function S(a){const t=new Set,o=[];function e(i,s){if(s.has(i)||t.has(i))return;s.add(i);const l=a.get(i);if(!l)return;const u=l.expression;if(u.type==="nonterminal")e(u.value,s);else if(u.value instanceof Array)for(const m of u.value)m.type==="nonterminal"&&e(m.value,s);t.add(i),s.delete(i),o.unshift(a.get(i))}for(const[i]of a)e(i,new Set);const r=new Map;for(const i of o)r.set(i.name,i);return r}const v=(a,t)=>{if(!(!(a!=null&&a.type)||!(t!=null&&t.type)||a.type!==t.type))switch(a.type){case"literal":case"nonterminal":return a.value!==t.value?void 0:[a,{type:"epsilon"},{type:"epsilon"}];case"group":case"optional":case"optionalWhitespace":case"many":case"many1":{const o=v(a.value,t.value);return o?[{type:a.type,value:o[0]},{type:a.type,value:o[1]},{type:a.type,value:o[2]}]:void 0}case"concatenation":{const o=a.value.map((u,m)=>v(a.value[m],t.value[m]));if(o.some(u=>u===void 0))return;const e=o.map(u=>u[0]),r=o.map(u=>u[1]),i=o.map(u=>u[2]),s=e.lastIndexOf(null);return s===e.length-1?void 0:[{type:"concatenation",value:e.slice(s+1)},{type:"concatenation",value:r},{type:"concatenation",value:i}]}case"alternation":for(const o of a.value){const e=v(o,t);if(e)return e}for(const o of t.value){const e=v(a,o);if(e)return e}return}},y=(a,t)=>{if(a.type!==t.type)return!1;switch(a.type){case"literal":case"nonterminal":return a.value===t.value;case"group":case"optional":case"many":case"many1":return y(a.value,t.value);case"minus":case"skip":case"next":return y(a.value[0],t.value[0])&&y(a.value[1],t.value[1]);case"concatenation":return a.value.every((o,e)=>y(o,t.value[e]));case"alternation":return a.value.some((o,e)=>y(o,t.value[e]));case"epsilon":return!0}};function T(a,t){const o=new Map;let e=null;for(let r=0;r<t.value.length-1;r++){const i=t.value[r],s=t.value[r+1],l=v(i,s);if(l){const[u,m,f]=l;e!==null&&y(u,e)?o.get(e).push(f):(o.set(u,[m,f]),e=u),r===t.value.length-2&&t.value.shift(),t.value.shift(),r-=1}}for(const[r,i]of o){const l={type:"concatenation",value:[{type:"group",value:{type:"alternation",value:i}},{type:"group",value:r}]};t.value.push(l)}}const _=(a,t,o)=>{const e=[],r=[],i={type:"nonterminal",value:o};for(let s=0;s<t.value.length;s++){const l=t.value[s];l.type==="concatenation"&&l.value[0].value===a?r.push({type:"concatenation",value:[...l.value.slice(1),i]}):e.push({type:"concatenation",value:[l,i]})}return r.length===0?[void 0,void 0]:(r.push({type:"epsilon"}),[{type:"alternation",value:e},{type:"alternation",value:r}])};function C(a){const t=new Map;let o=0;for(const[e,r]of a){const{expression:i}=r;if(i.type==="alternation"){const s=`${e}_${o++}`,[l,u]=_(e,i,s);l&&(t.set(s,{name:s,expression:u}),t.set(e,{name:e,expression:l,comment:r.comment}))}}if(t.size===0)return a;for(const[e,r]of t)a.set(e,r);for(const[e,r]of a){const{expression:i}=r;i.type==="alternation"&&T(e,i)}}function E(a){const t=S(a);return C(t),t}function d(a){const o=new c().grammar().parse(a);if(!o)throw new Error("Failed to parse EBNF grammar");return o.reduce((e,r,i)=>e.set(r.name,r),new Map)}function w(a){function t(e,r){var i,s;switch(r.type){case"literal":return n.string(r.value);case"nonterminal":const l=n.Parser.lazy(()=>o[r.value]);return l.context.name=r.value,l;case"epsilon":return n.eof().opt();case"group":return t(e,r.value);case"regex":return n.regex(r.value);case"optionalWhitespace":return t(e,r.value).trim();case"optional":return t(e,r.value).opt();case"many":return t(e,r.value).many();case"many1":return t(e,r.value).many(1);case"skip":return t(e,r.value[0]).skip(t(e,r.value[1]));case"next":return t(e,r.value[0]).next(t(e,r.value[1]));case"minus":return t(e,r.value[0]).not(t(e,r.value[1]));case"concatenation":{const u=r.value.map(m=>t(e,m));return((s=(i=u.at(-1))==null?void 0:i.context)==null?void 0:s.name)==="eof"&&u.pop(),n.all(...u)}case"alternation":return n.any(...r.value.map(u=>t(e,u)))}}const o={};for(const[e,r]of a.entries())o[e]=t(e,r.expression);return o}function N(a,t=!1){let o=d(a);return t&&(o=E(o)),[w(o),o]}exports.generateASTFromEBNF=d;exports.generateParserFromAST=w;exports.generateParserFromEBNF=N;
//# sourceMappingURL=ebnf.cjs.map
