{"version":3,"file":"ebnf.js","sources":["../src/ebnf/grammar.ts","../src/ebnf/optimize.ts","../src/ebnf/generate.ts"],"sourcesContent":["import { Parser, string, lazy, all, any, regex } from \"../parse\";\nimport { parserDebug } from \"../parse/debug\";\n\nexport type Expression =\n    | Literal\n    | Nonterminal\n    | Group\n    | Regex\n    | Optional\n    | Minus\n    | Many\n    | Many1\n    | Skip\n    | Next\n    | Concatenation\n    | Alteration\n    | Epsilon\n    | OptionalWhitespace;\n\ninterface BaseExpression<T, V = string> {\n    type: T;\n    value: V;\n    comment?: {\n        left: string[];\n        right: string[];\n    };\n}\n\nexport type Nonterminal = BaseExpression<\"nonterminal\">;\n\nexport type Literal = BaseExpression<\"literal\">;\nexport type Regex = BaseExpression<\"regex\", RegExp>;\nexport type Epsilon = BaseExpression<\"epsilon\">;\n\nexport type Group = BaseExpression<\"group\", Expression>;\nexport type ManyGroup = BaseExpression<\"many\", Expression>;\nexport type OptionalGroup = BaseExpression<\"optional\", Expression>;\n\nexport type Optional = BaseExpression<\"optional\", Expression>;\nexport type OptionalWhitespace = BaseExpression<\"optionalWhitespace\", undefined>;\n\nexport type Minus = BaseExpression<\"minus\", [Expression, Expression]>;\n\nexport type Many = BaseExpression<\"many\", Expression>;\nexport type Many1 = BaseExpression<\"many1\", Expression>;\nexport type Skip = BaseExpression<\"skip\", [Expression, Expression]>;\nexport type Next = BaseExpression<\"next\", [Expression, Expression]>;\n\nexport type Concatenation = BaseExpression<\"concatenation\", Expression[]>;\nexport type Alteration = BaseExpression<\"alternation\", Expression[]>;\n\nexport type ProductionRule = {\n    expression: Expression;\n    name: string;\n    comment: {\n        above: string[];\n        below: string[];\n    };\n};\n\nexport type AST = Map<string, ProductionRule>;\nexport type Nonterminals = { [key: string]: Parser<any> };\n\nconst operatorToType = {\n    \"|\": \"alternation\",\n    \",\": \"concatenation\",\n    \"-\": \"minus\",\n    \"<<\": \"skip\",\n    \">>\": \"next\",\n    \"*\": \"many\",\n    \"+\": \"many1\",\n    \"?\": \"optional\",\n    \"?w\": \"optionalWhitespace\",\n};\n\nconst reduceBinaryExpression = ([left, rightExpression]) => {\n    if (rightExpression.length === 0) {\n        return left;\n    }\n    return rightExpression.reduce((acc, [op, right]) => {\n        return {\n            type: operatorToType[op],\n            value: [acc, right],\n        };\n    }, left);\n};\n\nconst mapFactor = ([term, op]) => {\n    if (op === undefined) {\n        return term;\n    }\n    const type = operatorToType[op];\n    return {\n        type,\n        value: term,\n    } as Expression;\n};\n\ntype Options = {\n    debug: boolean;\n    comments: boolean;\n};\n\nconst defaultOptions = {\n    debug: false,\n    comments: true,\n} as Options;\n\nexport class EBNFGrammar {\n    options: Options;\n\n    constructor(options?: Partial<Options>) {\n        this.options = {\n            ...defaultOptions,\n            ...(options ?? {}),\n        };\n    }\n\n    identifier() {\n        return regex(/[_a-zA-Z][_a-zA-Z0-9]*/).trim();\n    }\n\n    literal() {\n        return this.trimBigComment(\n            any(\n                regex(/[^\"]+/).wrap(string('\"'), string('\"')),\n                regex(/[^']+/).wrap(string(\"'\"), string(\"'\"))\n            ).map((value) => {\n                return {\n                    type: \"literal\",\n                    value,\n                } as Literal;\n            })\n        );\n    }\n\n    epsilon() {\n        return any(string(\"epsilon\"), string(\"Îµ\"))\n            .trim()\n            .map((value) => {\n                return {\n                    type: \"epsilon\",\n                    value: undefined,\n                } as Epsilon;\n            });\n    }\n\n    nonterminal() {\n        return this.identifier().map((value) => {\n            return {\n                type: \"nonterminal\",\n                value,\n            } as Nonterminal;\n        });\n    }\n\n    @lazy\n    bigComment() {\n        return regex(/\\/\\*[^\\*]*\\*\\//).trim();\n    }\n\n    @lazy\n    comment() {\n        return regex(/\\/\\/.*/)\n            .or(this.bigComment())\n            .trim();\n    }\n\n    trimBigComment(e: Parser<any>) {\n        return e\n            .trim(this.bigComment().many(), false)\n            .map(([left, expression, right]) => {\n                expression.comment = {\n                    left,\n                    right,\n                };\n                return expression as unknown as Expression;\n            }) as Parser<Expression>;\n    }\n\n    @lazy\n    group() {\n        return this.rhs()\n            .trim()\n            .wrap(string(\"(\"), string(\")\"))\n            .map((value) => {\n                return {\n                    type: \"group\",\n                    value,\n                } as Group;\n            });\n    }\n\n    @lazy\n    regex() {\n        return regex(/[^\\/]*/)\n            .wrap(string(\"/\"), string(\"/\"))\n            .map((value) => {\n                return {\n                    type: \"regex\",\n                    value: new RegExp(value),\n                } as Regex;\n            });\n    }\n\n    @lazy\n    optionalGroup() {\n        return this.rhs()\n            .trim()\n            .wrap(string(\"[\"), string(\"]\"))\n            .map((value) => {\n                return {\n                    type: \"optional\",\n                    value,\n                } as Optional;\n            });\n    }\n\n    @lazy\n    manyGroup() {\n        return this.rhs()\n            .trim()\n            .wrap(string(\"{\"), string(\"}\"))\n            .map((value) => {\n                return {\n                    type: \"many\",\n                    value,\n                } as Many;\n            });\n    }\n\n    @lazy\n    lhs() {\n        return this.identifier();\n    }\n\n    @lazy\n    term() {\n        return any(\n            this.epsilon(),\n            this.group(),\n            this.optionalGroup(),\n            this.manyGroup(),\n            this.nonterminal(),\n            this.literal(),\n            this.regex()\n        );\n    }\n\n    @lazy\n    factor() {\n        return this.trimBigComment(\n            all(\n                this.term(),\n                any(\n                    string(\"?w\").trim(),\n                    string(\"?\").trim(),\n                    string(\"*\").trim(),\n                    string(\"+\").trim()\n                ).opt()\n            ).map(mapFactor)\n        ) as Parser<Expression>;\n    }\n\n    @lazy\n    binaryFactor() {\n        return all(\n            this.factor(),\n            all(\n                any(string(\"<<\").trim(), string(\">>\").trim(), string(\"-\").trim()),\n                this.factor()\n            ).many()\n        ).map(reduceBinaryExpression);\n    }\n\n    @lazy\n    concatenation() {\n        return this.binaryFactor()\n            .sepBy(string(\",\").trim())\n            .map((value) => {\n                if (value.length === 1) {\n                    return value[0];\n                }\n\n                return {\n                    type: \"concatenation\",\n                    value,\n                } as Concatenation;\n            });\n    }\n\n    @lazy\n    alternation() {\n        return this.concatenation()\n            .sepBy(string(\"|\").trim())\n            .map((value) => {\n                if (value.length === 1) {\n                    return value[0];\n                }\n\n                return {\n                    type: \"alternation\",\n                    value,\n                } as Alteration;\n            });\n    }\n\n    @lazy\n    rhs() {\n        return this.alternation();\n    }\n\n    @lazy\n    productionRule() {\n        return all(\n            this.lhs(),\n            string(\"=\").trim(),\n            this.rhs(),\n            any(string(\";\"), string(\".\")).trim()\n        ).map(([name, , expression]) => {\n            return { name, expression } as ProductionRule;\n        });\n    }\n\n    @lazy\n    grammar() {\n        return this.productionRule()\n            .trim(this.comment().many(), false)\n            .map(([above, rule, below]) => {\n                rule.comment = {\n                    above,\n                    below,\n                };\n                return rule;\n            })\n            .many(1);\n    }\n}\n","import {\n    Alteration,\n    AST,\n    Concatenation,\n    Epsilon,\n    Expression,\n    Nonterminal,\n    ProductionRule,\n} from \"./grammar\";\n\nexport function topologicalSort(ast: AST) {\n    const visited = new Set<string>();\n    const order: ProductionRule[] = [];\n\n    function visit(node: string, stack: Set<string>) {\n        if (stack.has(node) || visited.has(node)) {\n            return;\n        }\n\n        stack.add(node);\n        const productionRule = ast.get(node)!;\n\n        if (!productionRule) {\n            return;\n        }\n\n        const expr = productionRule.expression;\n\n        if (expr.type === \"nonterminal\") {\n            visit(expr.value, stack);\n        } else if (expr.value instanceof Array) {\n            for (const child of expr.value) {\n                if (child.type === \"nonterminal\") {\n                    visit(child.value, stack);\n                }\n            }\n        }\n\n        visited.add(node);\n        stack.delete(node);\n\n        order.unshift(ast.get(node) as ProductionRule);\n    }\n\n    for (const [name] of ast) {\n        visit(name, new Set<string>());\n    }\n\n    const newAST = new Map() as AST;\n    for (const rule of order) {\n        newAST.set(rule.name, rule);\n    }\n\n    return newAST;\n}\n\nexport const findCommonPrefix = (\n    e1: Expression,\n    e2: Expression\n): [Expression | null, Expression, Expression] => {\n    if (!e1?.type || !e2?.type || e1.type !== e2.type) {\n        return undefined;\n    }\n\n    switch (e1.type) {\n        case \"literal\":\n        case \"nonterminal\": {\n            if (e1.value !== e2.value) {\n                return undefined;\n            } else {\n                return [e1, { type: \"epsilon\" }, { type: \"epsilon\" }] as [\n                    Expression,\n                    Expression,\n                    Expression\n                ];\n            }\n        }\n        case \"group\":\n        case \"optional\":\n        case \"optionalWhitespace\":\n        case \"many\":\n        case \"many1\": {\n            const common = findCommonPrefix(e1.value, e2.value as Expression);\n            if (!common) {\n                return undefined;\n            } else {\n                return [\n                    {\n                        type: e1.type,\n                        value: common[0],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[1],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[2],\n                    },\n                ] as [Expression, Expression, Expression];\n            }\n        }\n\n        case \"concatenation\": {\n            const commons = e1.value.map((_, i) =>\n                findCommonPrefix(e1.value[i], e2.value[i])\n            );\n            if (commons.some((x) => x === undefined)) {\n                return undefined;\n            }\n\n            const prefixes = commons.map((x) => x[0]);\n            const e1s = commons.map((x) => x[1]);\n            const e2s = commons.map((x) => x[2]);\n\n            const startIx = prefixes.lastIndexOf(null);\n            if (startIx === prefixes.length - 1) {\n                return undefined;\n            }\n            const prefix = prefixes.slice(startIx + 1);\n            return [\n                {\n                    type: \"concatenation\",\n                    value: prefix,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e1s,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e2s,\n                },\n            ];\n        }\n\n        case \"alternation\":\n            // TODO! This is not correct\n            for (const e of e1.value) {\n                const common = findCommonPrefix(e, e2);\n                if (common) {\n                    return common;\n                }\n            }\n            for (const e of e2.value as Expression[]) {\n                const common = findCommonPrefix(e1, e);\n                if (common) {\n                    return common;\n                }\n            }\n            return undefined;\n    }\n    return undefined;\n};\n\nexport const comparePrefix = (prefix: Expression, expr: Expression): boolean => {\n    if (prefix.type !== expr.type) {\n        return false;\n    }\n    switch (prefix.type) {\n        case \"literal\":\n        case \"nonterminal\":\n            return prefix.value === expr.value;\n        case \"group\":\n        case \"optional\":\n        case \"many\":\n        case \"many1\":\n            return comparePrefix(prefix.value, expr.value as Expression);\n        case \"minus\":\n        case \"skip\":\n        case \"next\":\n            return (\n                comparePrefix(prefix.value[0], expr.value[0]) &&\n                comparePrefix(prefix.value[1], expr.value[1])\n            );\n        case \"concatenation\":\n            return prefix.value.every((e, i) => comparePrefix(e, expr.value[i]));\n        case \"alternation\":\n            return prefix.value.some((e, i) => comparePrefix(e, expr.value[i]));\n        case \"epsilon\":\n            return true;\n    }\n};\n\nexport function rewriteTreeLeftRecursion(name: string, expr: Alteration) {\n    const prefixMap = new Map<Expression, Expression[]>();\n    let commonPrefix: Expression | null = null;\n\n    for (let i = 0; i < expr.value.length - 1; i++) {\n        const e1 = expr.value[i];\n        const e2 = expr.value[i + 1];\n\n        const common = findCommonPrefix(e1, e2);\n        if (common) {\n            const [prefix, te1, te2] = common;\n\n            if (commonPrefix !== null && comparePrefix(prefix, commonPrefix)) {\n                prefixMap.get(commonPrefix)!.push(te2);\n            } else {\n                prefixMap.set(prefix, [te1, te2]);\n                commonPrefix = prefix;\n            }\n            if (i === expr.value.length - 2) {\n                expr.value.shift();\n            }\n            expr.value.shift();\n            i -= 1;\n        }\n    }\n\n    for (const [prefix, expressions] of prefixMap) {\n        const alternation = {\n            type: \"alternation\",\n            value: expressions,\n        } as Alteration;\n        const newExpr = {\n            type: \"concatenation\",\n            value: [\n                {\n                    type: \"group\",\n                    value: alternation,\n                },\n                {\n                    type: \"group\",\n                    value: prefix,\n                },\n            ],\n        } as Concatenation;\n\n        expr.value.push(newExpr);\n    }\n}\n\nconst removeDirectLeftRecursionProduction = (\n    name: string,\n    expr: Alteration,\n    tailName: string\n) => {\n    const head = [];\n    const tail = [];\n\n    const APrime = {\n        type: \"nonterminal\",\n        value: tailName,\n    } as Nonterminal;\n\n    for (let i = 0; i < expr.value.length; i++) {\n        const e = expr.value[i];\n\n        if (e.type === \"concatenation\" && e.value[0].value === name) {\n            tail.push({\n                type: \"concatenation\",\n                value: [...e.value.slice(1), APrime],\n            });\n        } else {\n            head.push({\n                type: \"concatenation\",\n                value: [e, APrime],\n            });\n        }\n    }\n\n    if (tail.length === 0) {\n        return [undefined, undefined];\n    }\n\n    tail.push({\n        type: \"epsilon\",\n    } as Epsilon);\n\n    return [\n        {\n            type: \"alternation\",\n            value: head,\n        } as Alteration,\n        {\n            type: \"alternation\",\n            value: tail,\n        } as Alteration,\n    ] as const;\n};\n\nexport function removeDirectLeftRecursion(ast: AST) {\n    const newNodes = new Map() as AST;\n\n    let uniqueIndex = 0;\n    for (const [name, productionRule] of ast) {\n        const { expression } = productionRule;\n\n        if (expression.type === \"alternation\") {\n            const tailName = `${name}_${uniqueIndex++}`;\n\n            const [head, tail] = removeDirectLeftRecursionProduction(\n                name,\n                expression,\n                tailName\n            );\n\n            if (head) {\n                newNodes.set(tailName, {\n                    name: tailName,\n                    expression: tail,\n                } as ProductionRule);\n                newNodes.set(name, {\n                    name,\n                    expression: head,\n                    comment: productionRule.comment,\n                } as ProductionRule);\n            }\n        }\n    }\n\n    if (newNodes.size === 0) {\n        return ast;\n    }\n    for (const [name, productionRule] of newNodes) {\n        ast.set(name, productionRule);\n    }\n\n    for (const [name, productionRule] of ast) {\n        const { expression } = productionRule;\n        if (expression.type === \"alternation\") {\n            rewriteTreeLeftRecursion(name, expression);\n        }\n    }\n}\n\nexport function removeIndirectLeftRecursion(ast: AST) {\n    let i = 0;\n\n    let uniqueIndex = 0;\n    const betas = new Map<string, Expression>();\n\n    const recurse = (name: string, expr: Expression) => {\n        if (expr.type === \"concatenation\") {\n            if (expr.value[0].type === \"nonterminal\" && expr.value[0].value === name) {\n                const beta = {\n                    type: \"concatenation\",\n                    value: expr.value.slice(1, expr.value.length),\n                } as Concatenation;\n                const aj = expr.value.shift();\n                const tailName = `${name}_${uniqueIndex++}`;\n            }\n        }\n    };\n\n    for (const [name, expression] of ast) {\n        recurse(name, expression);\n\n        i += 1;\n    }\n}\n\nexport function removeAllLeftRecursion(ast: AST) {\n    const newAST = topologicalSort(ast);\n\n    // removeIndirectLeftRecursion(newAST);\n    removeDirectLeftRecursion(newAST);\n\n    return newAST;\n}\n","import { Parser, all, any, eof, regex, string } from \"../parse\";\nimport { Expression, Nonterminals, AST, EBNFGrammar, ProductionRule } from \"./grammar\";\nimport { removeAllLeftRecursion } from \"./optimize\";\n\nexport function generateASTFromEBNF(input: string) {\n    const parser = new EBNFGrammar().grammar();\n    const parsed = parser.parse(input);\n\n    if (!parsed) {\n        throw new Error(\"Failed to parse EBNF grammar\");\n    }\n\n    return parsed.reduce((acc, productionRule, ix) => {\n        return acc.set(productionRule.name, productionRule);\n    }, new Map<string, ProductionRule>()) as AST;\n}\n\nexport function generateParserFromAST(ast: AST) {\n    function generateParser(name: string, expr: Expression): Parser<any> {\n        switch (expr.type) {\n            case \"literal\":\n                return string(expr.value);\n            case \"nonterminal\":\n                const l = Parser.lazy(() => {\n                    return nonterminals[expr.value];\n                });\n                l.context.name = expr.value as any;\n                return l;\n\n            case \"epsilon\":\n                return eof().opt();\n\n            case \"group\":\n                return generateParser(name, expr.value);\n\n            case \"regex\":\n                return regex(expr.value);\n\n            case \"optionalWhitespace\":\n                return generateParser(name, expr.value).trim();\n\n            case \"optional\":\n                return generateParser(name, expr.value).opt();\n            case \"many\":\n                return generateParser(name, expr.value).many();\n            case \"many1\":\n                return generateParser(name, expr.value).many(1);\n            case \"skip\":\n                return generateParser(name, expr.value[0]).skip(\n                    generateParser(name, expr.value[1])\n                );\n            case \"next\":\n                return generateParser(name, expr.value[0]).next(\n                    generateParser(name, expr.value[1])\n                );\n            case \"minus\":\n                return generateParser(name, expr.value[0]).not(\n                    generateParser(name, expr.value[1])\n                );\n            case \"concatenation\": {\n                const parsers = expr.value.map((x) => generateParser(name, x));\n                if (parsers.at(-1)?.context?.name === \"eof\") {\n                    parsers.pop();\n                }\n                return all(...parsers);\n            }\n            case \"alternation\": {\n                return any(...expr.value.map((x) => generateParser(name, x)));\n            }\n        }\n    }\n\n    const nonterminals: Nonterminals = {};\n\n    for (const [name, productionRule] of ast.entries()) {\n        nonterminals[name] = generateParser(name, productionRule.expression);\n    }\n    return nonterminals;\n}\n\nexport function generateParserFromEBNF(input: string, optimizeGraph: boolean = false) {\n    let ast = generateASTFromEBNF(input);\n\n    if (optimizeGraph) {\n        ast = removeAllLeftRecursion(ast);\n    }\n    const nonterminals = generateParserFromAST(ast);\n    return [nonterminals, ast] as const;\n}\n"],"names":["operatorToType","reduceBinaryExpression","left","rightExpression","acc","op","right","mapFactor","term","defaultOptions","EBNFGrammar","options","__publicField","regex","any","string","value","e","expression","all","name","above","rule","below","__decorateClass","lazy","topologicalSort","ast","visited","order","visit","node","stack","productionRule","expr","child","newAST","findCommonPrefix","e1","e2","common","commons","_","i","x","prefixes","e1s","e2s","startIx","comparePrefix","prefix","rewriteTreeLeftRecursion","prefixMap","commonPrefix","te1","te2","expressions","newExpr","removeDirectLeftRecursionProduction","tailName","head","tail","APrime","removeDirectLeftRecursion","newNodes","uniqueIndex","removeIndirectLeftRecursion","recurse","removeAllLeftRecursion","generateASTFromEBNF","input","parsed","ix","generateParserFromAST","generateParser","Parser","nonterminals","eof","parsers","_b","_a","generateParserFromEBNF","optimizeGraph"],"mappings":"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"}