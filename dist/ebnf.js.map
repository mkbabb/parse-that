{"version":3,"file":"ebnf.js","sources":["../src/ebnf/grammar.ts","../src/ebnf/optimize.ts","../src/ebnf/generate.ts","../src/ebnf/transform.ts"],"sourcesContent":["import { Parser, string, lazy, all, any, regex } from \"../parse\";\n\nexport type Expression =\n    | Literal\n    | Comment\n    | Nonterminal\n    | Group\n    | Regex\n    | Optional\n    | Minus\n    | Many\n    | Many1\n    | Skip\n    | Next\n    | Concatenation\n    | Alteration\n    | Epsilon\n    | OptionalWhitespace\n    | Coalesce\n    | EOF;\n\nexport interface Literal {\n    type: \"literal\";\n    value: string;\n}\n\nexport interface Comment {\n    type: \"comment\";\n    value: string;\n}\n\nexport interface Nonterminal {\n    type: \"nonterminal\";\n    value: string;\n}\n\nexport interface Epsilon {\n    type: \"epsilon\";\n    value: undefined;\n}\n\nexport interface EOF {\n    type: \"eof\";\n    value: undefined;\n}\n\nexport interface OptionalWhitespace {\n    type: \"optionalWhitespace\";\n    value: undefined;\n}\n\nexport interface Coalesce {\n    type: \"coalesce\";\n    value: Expression[];\n}\n\nexport interface Group {\n    type: \"group\";\n    value: Expression;\n}\n\nexport interface Regex {\n    type: \"regex\";\n    value: RegExp;\n}\n\nexport interface Optional {\n    type: \"optional\";\n    value: Expression;\n}\n\nexport interface Minus {\n    type: \"minus\";\n    value: [Expression, Expression];\n}\n\nexport interface Many {\n    type: \"many\";\n    value: Expression;\n}\n\nexport interface Many1 {\n    type: \"many1\";\n    value: Expression;\n}\n\nexport interface Skip {\n    type: \"skip\";\n    value: [Expression, Expression];\n}\n\nexport interface Next {\n    type: \"next\";\n    value: [Expression, Expression];\n}\n\nexport interface Concatenation {\n    type: \"concatenation\";\n    value: Expression[];\n}\n\nexport interface Alteration {\n    type: \"alternation\";\n    value: Expression[];\n}\n\nexport type ProductionRule = {\n    type: \"productionRule\" | \"comment\";\n    expression: Expression;\n    name?: string;\n};\n\nexport type AST = Map<string, Expression>;\nexport type Nonterminals = { [key: string]: Parser<any> };\n\nconst comma = string(\",\").trim();\nconst equalSign = string(\"=\").trim();\n\nconst semicolon = string(\";\").trim();\nconst dot = string(\".\").trim();\nconst questionMark = string(\"?\").trim();\nconst optionalWhitespace = string(\"?w\").trim();\nconst coalsece = string(\"??\").trim();\nconst pipe = string(\"|\").trim();\n\nconst plus = string(\"+\").trim();\nconst minus = string(\"-\").trim();\nconst mul = string(\"*\").trim();\nconst div = string(\"/\").trim();\n\nconst leftShift = string(\">>\").trim();\nconst rightShift = string(\"<<\").trim();\n\nconst terminator = any(semicolon, dot);\n\nexport class EBNFGrammar {\n    identifier() {\n        return regex(/[_a-zA-Z][_a-zA-Z0-9]*/).trim();\n    }\n\n    literal() {\n        return any(\n            regex(/[^\"]+/).wrap(string('\"'), string('\"')),\n            regex(/[^']+/).wrap(string(\"'\"), string(\"'\"))\n        ).map((value) => {\n            return {\n                type: \"literal\",\n                value,\n            } as Literal;\n        });\n    }\n\n    epsilon() {\n        return any(string(\"epsilon\"), string(\"ε\"), string(\"ϵ\"))\n            .trim()\n            .map((value) => {\n                return {\n                    type: \"epsilon\",\n                    value: undefined,\n                } as Epsilon;\n            });\n    }\n\n    nonterminal() {\n        return this.identifier().map((value) => {\n            return {\n                type: \"nonterminal\",\n                value,\n            } as Nonterminal;\n        });\n    }\n\n    @lazy\n    group() {\n        return this.expression()\n            .trim()\n            .wrap(string(\"(\"), string(\")\"))\n            .map((value) => {\n                return {\n                    type: \"group\",\n                    value,\n                } as Group;\n            });\n    }\n\n    eof() {\n        return string(\"$\")\n            .trim()\n            .map((value) => {\n                return {\n                    type: \"eof\",\n                    value,\n                } as EOF;\n            });\n    }\n\n    @lazy\n    regex() {\n        return regex(/[^\\/]*/)\n            .wrap(string(\"/\"), string(\"/\"))\n            .map((value) => {\n                return {\n                    type: \"regex\",\n                    value: new RegExp(value),\n                } as Regex;\n            });\n    }\n\n    optional() {\n        return this.term()\n            .skip(questionMark)\n            .map((value) => {\n                return {\n                    type: \"optional\",\n                    value,\n                } as Optional;\n            });\n    }\n\n    @lazy\n    optionalGroup() {\n        return this.expression()\n            .trim()\n            .wrap(string(\"[\"), string(\"]\"))\n            .map((value) => {\n                return {\n                    type: \"optional\",\n                    value,\n                } as Optional;\n            });\n    }\n\n    optionalWhitespace() {\n        return this.term()\n            .skip(optionalWhitespace)\n            .map((value) => {\n                return {\n                    type: \"optionalWhitespace\",\n                    value,\n                } as OptionalWhitespace;\n            });\n    }\n\n    @lazy\n    coalesce() {\n        return all(this.term().skip(coalsece), this.factor()).map(([left, right]) => {\n            return {\n                type: \"coalesce\",\n                value: [left, right],\n            } as Coalesce;\n        });\n    }\n\n    subtraction() {\n        return all(this.term().skip(minus), this.term()).map(([left, right]) => {\n            return {\n                type: \"minus\",\n                value: [left, right],\n            } as Minus;\n        });\n    }\n\n    @lazy\n    manyGroup() {\n        return this.expression()\n            .trim()\n            .wrap(string(\"{\"), string(\"}\"))\n            .map((value) => {\n                return {\n                    type: \"many\",\n                    value,\n                } as Many;\n            });\n    }\n\n    many() {\n        return this.term()\n            .skip(mul)\n            .map((value) => {\n                return {\n                    type: \"many\",\n                    value,\n                } as Many;\n            });\n    }\n\n    many1() {\n        return this.term()\n            .skip(plus)\n            .map((value) => {\n                return {\n                    type: \"many1\",\n                    value,\n                } as Many1;\n            });\n    }\n\n    @lazy\n    next() {\n        return all(this.factor().skip(leftShift), any(this.skip(), this.factor())).map(\n            ([left, right]) => {\n                return {\n                    type: \"next\",\n                    value: [left, right],\n                } as Next;\n            }\n        );\n    }\n\n    @lazy\n    skip() {\n        return all(any(this.next(), this.factor()).skip(rightShift), this.factor()).map(\n            ([left, right]) => {\n                return {\n                    type: \"skip\",\n                    value: [left, right],\n                } as Skip;\n            }\n        );\n    }\n\n    concatenation() {\n        return any(this.skip(), this.next(), this.factor())\n            .sepBy(comma, 1)\n            .map((value) => {\n                return {\n                    type: \"concatenation\",\n                    value,\n                } as Concatenation;\n            });\n    }\n\n    alternation() {\n        return any(this.concatenation(), this.skip(), this.next(), this.factor())\n            .sepBy(pipe, 1)\n            .map((value) => {\n                return {\n                    type: \"alternation\",\n                    value,\n                } as Alteration;\n            });\n    }\n\n    bigComment() {\n        return regex(/\\/\\*[^]*?\\*\\//)\n            .trim()\n            .map((value) => {\n                return {\n                    type: \"comment\",\n                    expression: {\n                        type: \"literal\",\n                        value,\n                    } as Literal,\n                } as ProductionRule;\n            });\n    }\n\n    term() {\n        return any(\n            this.epsilon(),\n            this.literal(),\n            this.nonterminal(),\n            this.regex(),\n            this.group(),\n            this.optionalGroup(),\n            this.manyGroup(),\n            this.eof()\n        )\n            .then(this.bigComment().opt())\n            .map(([left, comment]) => {\n                if (comment) {\n                    left.comment = comment;\n                }\n                return left as unknown as Expression;\n            }) as Parser<Expression>;\n    }\n\n    factor() {\n        return any(\n            this.coalesce(),\n            this.optionalWhitespace(),\n            this.optional(),\n            this.many(),\n            this.many1(),\n            this.subtraction(),\n            this.term()\n        ) as Parser<Expression>;\n    }\n\n    comment() {\n        return regex(/\\/\\/.*/)\n            .trim()\n            .map((value) => {\n                return {\n                    type: \"comment\",\n                    expression: {\n                        type: \"literal\",\n                        value,\n                    } as Literal,\n                } as ProductionRule;\n            })\n            .or(this.bigComment()) as unknown as Parser<ProductionRule>;\n    }\n\n    expression() {\n        return any(\n            this.alternation(),\n            this.concatenation(),\n            this.skip(),\n            this.next(),\n            this.factor()\n        ) as Parser<Expression>;\n    }\n\n    productionRule() {\n        return all(\n            this.identifier().skip(equalSign),\n            this.expression().skip(terminator)\n        ).map(([name, expression]) => {\n            return { name, expression, type: \"productionRule\" } as ProductionRule;\n        });\n    }\n\n    grammar() {\n        return all(this.comment().many(), this.productionRule(), this.comment().many())\n            .map(([above, rule, below]) => {\n                rule.comment = {\n                    above,\n                    below,\n                };\n                return rule;\n            })\n            .many(1);\n    }\n}\n","import {\n    Alteration,\n    AST,\n    Concatenation,\n    Epsilon,\n    Expression,\n    Nonterminal,\n    ProductionRule,\n} from \"./grammar\";\n\nexport function topologicalSort(ast: AST) {\n    const visited = new Set<string>();\n    const order: ProductionRule[] = [];\n\n    function visit(node: string, stack: Set<string>) {\n        if (stack.has(node) || visited.has(node)) {\n            return;\n        }\n\n        stack.add(node);\n        const expr = ast.get(node)!;\n        if (!expr) {\n            return;\n        }\n\n        if (expr.type === \"nonterminal\") {\n            visit(expr.value, stack);\n        } else if (expr.type === \"concatenation\" || expr.type === \"alternation\") {\n            for (const child of expr.value) {\n                if (child.type === \"nonterminal\") {\n                    visit(child.value, stack);\n                }\n            }\n        }\n\n        visited.add(node);\n        stack.delete(node);\n        order.unshift({ name: node, expression: expr });\n    }\n\n    for (const [name] of ast) {\n        visit(name, new Set<string>());\n    }\n\n    const newAST = new Map<string, Expression>();\n    for (const rule of order) {\n        newAST.set(rule.name, rule.expression);\n    }\n\n    return newAST;\n}\n\nexport const findCommonPrefix = (\n    e1: Expression,\n    e2: Expression\n): [Expression | null, Expression, Expression] => {\n    if (!e1?.type || !e2?.type || e1.type !== e2.type) {\n        return undefined;\n    }\n\n    switch (e1.type) {\n        case \"literal\":\n        case \"nonterminal\": {\n            if (e1.value !== e2.value) {\n                return undefined;\n            } else {\n                return [e1, { type: \"epsilon\" }, { type: \"epsilon\" }] as [\n                    Expression,\n                    Expression,\n                    Expression\n                ];\n            }\n        }\n\n        case \"group\":\n        case \"optional\":\n        case \"many\":\n        case \"many1\": {\n            const common = findCommonPrefix(e1.value, e2.value as Expression);\n            if (!common) {\n                return undefined;\n            } else {\n                return [\n                    {\n                        type: e1.type,\n                        value: common[0],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[1],\n                    },\n                    {\n                        type: e1.type,\n                        value: common[2],\n                    },\n                ] as [Expression, Expression, Expression];\n            }\n        }\n\n        case \"concatenation\": {\n            const commons = e1.value.map((_, i) =>\n                findCommonPrefix(e1.value[i], e2.value[i])\n            );\n            if (commons.some((x) => x === undefined)) {\n                return undefined;\n            }\n\n            const prefixes = commons.map((x) => x[0]);\n            const e1s = commons.map((x) => x[1]);\n            const e2s = commons.map((x) => x[2]);\n\n            const startIx = prefixes.lastIndexOf(null);\n            if (startIx === prefixes.length - 1) {\n                return undefined;\n            }\n\n            const prefix = prefixes.slice(startIx + 1);\n            return [\n                {\n                    type: \"concatenation\",\n                    value: prefix,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e1s,\n                },\n                {\n                    type: \"concatenation\",\n                    value: e2s,\n                },\n            ];\n        }\n\n        case \"alternation\":\n            // TODO! This is not correct\n            for (const e of e1.value) {\n                const common = findCommonPrefix(e, e2);\n                if (common) {\n                    return common;\n                }\n            }\n            for (const e of e2.value as Expression[]) {\n                const common = findCommonPrefix(e1, e);\n                if (common) {\n                    return common;\n                }\n            }\n            return undefined;\n    }\n    return undefined;\n};\n\nexport const comparePrefix = (prefix: Expression, expr: Expression): boolean => {\n    if (prefix.type !== expr.type) {\n        return false;\n    }\n    switch (prefix.type) {\n        case \"literal\":\n        case \"nonterminal\":\n            return prefix.value === expr.value;\n        case \"group\":\n        case \"optional\":\n        case \"many\":\n        case \"many1\":\n            return comparePrefix(prefix.value, expr.value as Expression);\n        case \"minus\":\n        case \"skip\":\n        case \"next\":\n            return (\n                comparePrefix(prefix.value[0], expr.value[0]) &&\n                comparePrefix(prefix.value[1], expr.value[1])\n            );\n        case \"concatenation\":\n            return prefix.value.every((e, i) => comparePrefix(e, expr.value[i]));\n        case \"alternation\":\n            return prefix.value.some((e, i) => comparePrefix(e, expr.value[i]));\n        case \"epsilon\":\n            return true;\n    }\n};\n\nexport function rewriteTreeLeftRecursion(name: string, expr: Alteration) {\n    const prefixMap = new Map<Expression, Expression[]>();\n    let commonPrefix: Expression | null = null;\n\n    for (let i = 0; i < expr.value.length - 1; i++) {\n        const e1 = expr.value[i];\n        const e2 = expr.value[i + 1];\n\n        const common = findCommonPrefix(e1, e2);\n        if (common) {\n            const [prefix, te1, te2] = common;\n\n            if (commonPrefix !== null && comparePrefix(prefix, commonPrefix)) {\n                prefixMap.get(commonPrefix)!.push(te2);\n            } else {\n                prefixMap.set(prefix, [te1, te2]);\n                commonPrefix = prefix;\n            }\n            if (i === expr.value.length - 2) {\n                expr.value.shift();\n            }\n            expr.value.shift();\n            i -= 1;\n        }\n    }\n\n    for (const [prefix, expressions] of prefixMap) {\n        const alternation = {\n            type: \"alternation\",\n            value: expressions,\n        } as Alteration;\n        const newExpr = {\n            type: \"concatenation\",\n            value: [\n                {\n                    type: \"group\",\n                    value: alternation,\n                },\n                {\n                    type: \"group\",\n                    value: prefix,\n                },\n            ],\n        } as Concatenation;\n\n        expr.value.push(newExpr);\n    }\n}\n\nconst removeDirectLeftRecursionProduction = (\n    name: string,\n    expr: Alteration,\n    tailName: string\n) => {\n    const head = [];\n    const tail = [];\n\n    const APrime = {\n        type: \"nonterminal\",\n        value: tailName,\n    } as Nonterminal;\n\n    for (let i = 0; i < expr.value.length; i++) {\n        const e = expr.value[i];\n\n        if (e.type === \"concatenation\" && e.value[0].value === name) {\n            tail.push({\n                type: \"concatenation\",\n                value: [...e.value.slice(1), APrime],\n            });\n        } else {\n            head.push({\n                type: \"concatenation\",\n                value: [e, APrime],\n            });\n        }\n    }\n\n    // No direct left recursion\n    if (tail.length === 0) {\n        return [undefined, undefined];\n    }\n\n    tail.push({\n        type: \"epsilon\",\n    } as Epsilon);\n\n    return [\n        {\n            type: \"alternation\",\n            value: head,\n        } as Alteration,\n        {\n            type: \"alternation\",\n            value: tail,\n        } as Alteration,\n    ] as const;\n};\n\nexport function removeDirectLeftRecursion(ast: AST) {\n    const newNodes = new Map() as AST;\n\n    let uniqueIndex = 0;\n    for (const [name, expression] of ast) {\n        if (expression.type === \"alternation\") {\n            const tailName = `${name}_${uniqueIndex++}`;\n\n            const [head, tail] = removeDirectLeftRecursionProduction(\n                name,\n                expression,\n                tailName\n            );\n            if (head) {\n                newNodes.set(tailName, tail);\n                newNodes.set(name, head);\n            }\n        }\n    }\n\n    if (newNodes.size === 0) {\n        return ast;\n    }\n    for (const [name, expression] of newNodes) {\n        ast.set(name, expression);\n    }\n\n    for (const [name, expression] of ast) {\n        if (expression.type === \"alternation\") {\n            rewriteTreeLeftRecursion(name, expression);\n        }\n    }\n}\n\nexport function removeIndirectLeftRecursion(ast: AST) {\n    let i = 0;\n\n    let uniqueIndex = 0;\n    const betas = new Map<string, Expression>();\n\n    const recurse = (name: string, expr: Expression) => {\n        if (expr.type === \"concatenation\") {\n            if (expr.value[0].type === \"nonterminal\" && expr.value[0].value === name) {\n                const beta = {\n                    type: \"concatenation\",\n                    value: expr.value.slice(1, expr.value.length),\n                } as Concatenation;\n                const aj = expr.value.shift();\n                const tailName = `${name}_${uniqueIndex++}`;\n            }\n        }\n    };\n\n    for (const [name, expression] of ast) {\n        recurse(name, expression);\n\n        i += 1;\n    }\n}\n\nexport function removeAllLeftRecursion(ast: AST) {\n    const newAST = topologicalSort(ast);\n\n    // removeIndirectLeftRecursion(newAST);\n    removeDirectLeftRecursion(newAST);\n\n    return newAST;\n}\n","import { Parser, all, any, eof, regex, string } from \"../parse\";\nimport { Expression, Nonterminals, AST, EBNFGrammar } from \"./grammar\";\nimport { removeAllLeftRecursion } from \"./optimize\";\n\nexport function generateASTFromEBNF(input: string) {\n    const parser = new EBNFGrammar().grammar().trim();\n    const parsed = parser.parse(input);\n\n    if (!parsed) {\n        throw new Error(\"Failed to parse EBNF grammar\");\n    }\n\n    return parsed.reduce((acc, { name, expression, type }, ix) => {\n        acc.set(name, expression);\n        return acc;\n    }, new Map<string, Expression>()) as AST;\n}\n\nexport function generateParserFromAST(ast: AST) {\n    function generateParser(name: string, expr: Expression): Parser<any> {\n        switch (expr.type) {\n            case \"literal\":\n                return string(expr.value);\n            case \"nonterminal\":\n                const l = Parser.lazy(() => {\n                    return nonterminals[expr.value];\n                });\n                l.context.name = expr.value as any;\n                return l;\n\n            case \"comment\":\n            case \"epsilon\":\n                return eof().opt();\n\n            case \"eof\":\n                return eof();\n\n            case \"group\":\n                return generateParser(name, expr.value);\n\n            case \"regex\":\n                return regex(expr.value);\n\n            case \"optionalWhitespace\":\n                return generateParser(name, expr.value).trim();\n\n            case \"coalesce\":\n                return any(...expr.value.map((x) => generateParser(name, x)));\n\n            case \"optional\":\n                return generateParser(name, expr.value).opt();\n            case \"many\":\n                return generateParser(name, expr.value).many();\n            case \"many1\":\n                return generateParser(name, expr.value).many(1);\n            case \"skip\":\n                return generateParser(name, expr.value[0]).skip(\n                    generateParser(name, expr.value[1])\n                );\n            case \"next\":\n                return generateParser(name, expr.value[0]).next(\n                    generateParser(name, expr.value[1])\n                );\n            case \"minus\":\n                return generateParser(name, expr.value[0]).not(\n                    generateParser(name, expr.value[1])\n                );\n            case \"concatenation\": {\n                const parsers = expr.value.map((x) => generateParser(name, x));\n                if (parsers.at(-1)?.context?.name === \"eof\") {\n                    parsers.pop();\n                }\n                return all(...parsers);\n            }\n            case \"alternation\": {\n                return any(...expr.value.map((x) => generateParser(name, x)));\n            }\n        }\n    }\n\n    const nonterminals: Nonterminals = {};\n\n    for (const [name, expression] of ast.entries()) {\n        nonterminals[name] = generateParser(name, expression);\n    }\n    return nonterminals;\n}\n\nexport function generateParserFromEBNF(input: string, optimizeGraph: boolean = false) {\n    let ast = generateASTFromEBNF(input);\n\n    if (optimizeGraph) {\n        ast = removeAllLeftRecursion(ast);\n    }\n    const nonterminals = generateParserFromAST(ast);\n    return [nonterminals, ast] as const;\n}\n\nexport const addNonterminalsDebugging = (\n    nonterminals: Nonterminals,\n    logger: (...args: any[]) => void\n) => {\n    Object.entries(nonterminals).forEach(([k, v]) => {\n        nonterminals[k] = v.debug(k, false, logger);\n    });\n};\n","import { Expression, AST } from \"./grammar\";\n\nimport { generateParserFromEBNF } from \"./generate\";\n\nfunction breakLineOnSeparator(input: string, separator: string): string {\n    const lines = input.split(separator);\n\n    if (lines.length === 1) {\n        return input;\n    }\n\n    input = lines\n        .map((line, i) => {\n            if (i === lines.length - 1) {\n                return separator + line;\n            } else if (i === 0) {\n                return line;\n            }\n\n            const groups = line.split(\",\");\n\n            if (groups.length > 1) {\n                return `\\n\\t${separator} ` + line;\n            } else {\n                return separator + line;\n            }\n        })\n        .join(\"\");\n\n    const maxLineLength = 66;\n\n    if (input.length > maxLineLength) {\n        let di = maxLineLength;\n\n        for (let i = 0; i < input.length; i += di) {\n            const nearestSepIx = i === 0 ? maxLineLength : i + di;\n            const nearestSep = input.indexOf(separator, nearestSepIx);\n\n            if (nearestSep === -1) {\n                break;\n            }\n            input =\n                input.slice(0, nearestSep) +\n                `\\n\\t${separator}` +\n                input.slice(nearestSep + 1);\n        }\n    }\n\n    return input;\n}\n\nconst nonterminalsToTrim = [\n    \"symbol\",\n    \"identifier\",\n    \"terminal\",\n    \"pipe\",\n    \"comma\",\n    \"plus\",\n    \"minus\",\n    \"star\",\n    \"div\",\n    \"question\",\n    \"eof\",\n    \"optional_whitespace\",\n    \"regex\",\n    \"rhs\",\n    \"rule\",\n    \"grammar\",\n];\n\nexport const EBNFParser = (grammar: string) => {\n    const [nonterminals, ast] = generateParserFromEBNF(grammar);\n\n    for (const name of nonterminalsToTrim) {\n        nonterminals[name] = nonterminals[name].trim();\n    }\n\n    nonterminals.symbol = nonterminals.symbol;\n\n    nonterminals.identifier = nonterminals.identifier.map((v) => {\n        return v.flat().join(\"\");\n    });\n\n    nonterminals.terminal = nonterminals.terminal.map((v) => {\n        return v.flat().join(\"\");\n    });\n\n    nonterminals.regex = nonterminals.regex.map((v) => {\n        const s = v.flat().join(\"\");\n        return s;\n    });\n\n    nonterminals.rhs = nonterminals.rhs.map((v) => {\n        const a = v instanceof Array ? v.flat(Infinity) : v;\n        const s = a.join(\" \");\n        return breakLineOnSeparator(s, \"|\");\n    });\n\n    nonterminals.rule = nonterminals.rule.map((v) => {\n        const s = v.flat().join(\" \");\n        return s;\n    });\n\n    return nonterminals.grammar.map((rules) => {\n        let lastIx = 0;\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i];\n\n            if (rule.length > 80) {\n                rules[i] = rule + \"\\n\";\n                if (i > 0 && lastIx !== i - 1) {\n                    rules[i - 1] = rules[i - 1] + \"\\n\";\n                }\n                lastIx = i;\n            } else if (i - lastIx > 2) {\n                rules[i] = rule + \"\\n\";\n                lastIx = i;\n            }\n        }\n        return rules.join(\"\\n\");\n    });\n\n    // debugging(nonterminals);\n};\n\nfunction escapeRegExp(string: string): string {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\ntype TextMateProductionRule = {\n    name: string;\n    match: string;\n};\n\ntype TextMateLanguage = {\n    name: string;\n    scopeName: string;\n    fileTypes: string[];\n    patterns: TextMateProductionRule[];\n};\n\nfunction transformEBNFASTToTextMateRegExp(expression: Expression): string {\n    switch (expression.type) {\n        case \"literal\":\n            return escapeRegExp(expression.value);\n        case \"nonterminal\":\n            return `($${expression.value})`;\n        case \"epsilon\":\n            return \"\";\n        case \"group\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})`;\n        case \"regex\":\n            return expression.value.source;\n        case \"optional\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})?`;\n        case \"minus\":\n            return `${transformEBNFASTToTextMateRegExp(\n                expression.value[0]\n            )}(?!${transformEBNFASTToTextMateRegExp(expression.value[1])})`;\n        case \"many\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})*`;\n        case \"many1\":\n            return `(${transformEBNFASTToTextMateRegExp(expression.value)})+`;\n        case \"skip\":\n            return `${transformEBNFASTToTextMateRegExp(\n                expression.value[0]\n            )}(?:${transformEBNFASTToTextMateRegExp(expression.value[1])})?`;\n        case \"next\":\n            return `${transformEBNFASTToTextMateRegExp(\n                expression.value[0]\n            )}(?=${transformEBNFASTToTextMateRegExp(expression.value[1])})`;\n        case \"concatenation\":\n            return expression.value.map(transformEBNFASTToTextMateRegExp).join(\"\");\n        case \"alternation\":\n            return expression.value\n                .map((expr) => `(${transformEBNFASTToTextMateRegExp(expr)})`)\n                .join(\"|\");\n    }\n}\n\nexport function transformEBNFASTToTextMateLanguage(ast: AST): TextMateLanguage {\n    const rules: TextMateProductionRule[] = [];\n\n    // Traverse the EBNF AST and transform each production rule into a TextMate production rule\n    for (const [name, expr] of ast) {\n        rules.push({\n            name,\n            match: transformEBNFASTToTextMateRegExp(expr),\n        });\n    }\n    // Create and return the TextMate language object\n    return {\n        name: \"EEBNF\",\n        scopeName: \"source.eebnf\",\n        fileTypes: [\"eebnf\"],\n        patterns: rules,\n    };\n}\n"],"names":["comma","string","equalSign","semicolon","dot","questionMark","optionalWhitespace","coalsece","pipe","plus","minus","mul","leftShift","rightShift","terminator","any","EBNFGrammar","regex","value","all","left","right","comment","name","expression","above","rule","below","__decorateClass","lazy","topologicalSort","ast","visited","order","visit","node","stack","expr","child","newAST","findCommonPrefix","e1","e2","common","commons","_","i","x","prefixes","e1s","e2s","startIx","e","comparePrefix","prefix","rewriteTreeLeftRecursion","prefixMap","commonPrefix","te1","te2","expressions","newExpr","removeDirectLeftRecursionProduction","tailName","head","tail","APrime","removeDirectLeftRecursion","newNodes","uniqueIndex","removeIndirectLeftRecursion","recurse","removeAllLeftRecursion","generateASTFromEBNF","input","parsed","acc","type","ix","generateParserFromAST","generateParser","l","Parser","nonterminals","eof","parsers","_b","_a","generateParserFromEBNF","optimizeGraph","addNonterminalsDebugging","logger","k","v","breakLineOnSeparator","separator","lines","line","maxLineLength","di","nearestSepIx","nearestSep","nonterminalsToTrim","EBNFParser","grammar","s","rules","lastIx","escapeRegExp","transformEBNFASTToTextMateRegExp","transformEBNFASTToTextMateLanguage"],"mappings":"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"}